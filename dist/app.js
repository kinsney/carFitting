/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Vue = __webpack_require__(12);
	var store = __webpack_require__(13);
	var THREE = __webpack_require__(26);
	var audio = document.querySelector('audio');
	var iploader = document.querySelector('.ip-loader');
	var jsonLoader = new THREE.JSONLoader();
	var images = ['bump/matting.jpg', 'garage/garage.jpg', 'ground/sandy.jpg', 'ground/sphere002.png', 'ground/cylinder001.png', 'ground/rectangle1408.png', 'ground/box03.png', 'ground/gas_station.png', 'ground/cylinder002.png', 'chassis/a3/rvent.png', 'chassis/a3/chassis.png', 'wheels/19/brake.png', 'wheels/19/tyre19.png', 'chassis/a3/interior.png', 'chassis/a3/cvent.png', 'chassis/a3/fvent.png', 'lab/Obj_000002.png', 'lab/Obj_000069.png'];['ground', 'garage', 'lab'].forEach(function (situation) {
	  images = images.concat([situation + '/px.jpg', situation + '/nx.jpg', situation + '/py.jpg', situation + '/ny.jpg', situation + '/pz.jpg', situation + '/nz.jpg']);
	});
	var jsonArray = ['chassis/a3/hood-area.json', 'chassis/a3/fbumper-area.json', 'chassis/a3/body-area.json', 'chassis/a3/rbumper-area.json', 'chassis/a3/roof-area.json', 'chassis/a3/trunk-area.json', 'chassis/a3/reflector-area.json', 'chassis/a3/glass.json', 'chassis/a3/hood.json', 'chassis/a3/lens.json', 'chassis/a3/rbumper.json', 'chassis/a3/reflector.json', 'chassis/a3/roof.json', 'chassis/a3/chassis.json', 'chassis/a3/interior.json', 'chassis/a3/trunk.json', 'chassis/a3/body.json', 'chassis/a3/fbumper.json', 'lab/lab.json', 'garage/garage.json', 'ground/ground.json', 'wheels/19/caliper.json', 'wheels/19/AEZ-Antigua.json', 'wheels/19/tyre19.json', 'wheels/rim/19.json', 'wheels/tyre/tyre19.json'];

	var totalLength = images.length + jsonArray.length;
	var root = (function (hash) {
	  if (hash[0] !== '#') {
	    return '';
	  } else {
	    var _root = hash.slice(1);
	    return _root.slice(0, hash.lastIndexOf('/'));
	  }
	})(window.location.hash);

	audio.src = root + 'music.mp3';

	function PathLoader(el) {
	  this.el = el;
	  // clear stroke
	  this.el.style.strokeDasharray = this.el.style.strokeDashoffset = this.el.getTotalLength();
	}

	PathLoader.prototype._draw = function (val) {
	  this.el.style.strokeDashoffset = this.el.getTotalLength() * (1 - val);
	};

	PathLoader.prototype.setProgress = function (val, callback) {
	  this._draw(val);
	  if (callback && typeof callback === 'function') {
	    // give it a time (ideally the same like the transition time) so that the last progress increment animation is still visible.
	    setTimeout(callback, 200);
	  }
	};

	PathLoader.prototype.setProgressFn = function (fn) {
	  if (typeof fn === 'function') {
	    fn(this);
	  }
	};

	// add to global namespace
	window.PathLoader = PathLoader;

	var loader = new PathLoader(document.getElementById('ip-loader-circle'));

	function startLoading() {
	  // simulate loading something..
	  var simulationFn = function simulationFn(instance) {
	    var progress = 0,
	        loaded = 0;
	    jsonArray.forEach(function (value) {
	      jsonLoader.load(value, function () {
	        progress = ++loaded / totalLength;
	      });
	    });
	    images.forEach(function (url) {
	      var img = new Image();
	      img.onload = function () {
	        progress = ++loaded / totalLength;
	        img = null;
	      };
	      img.src = url;
	    });
	    __webpack_require__(30);
	    __webpack_require__(59);
	    var interval = setInterval(function () {
	      instance.setProgress(progress);
	      // reached the end
	      if (progress === 1) {
	        iploader.style.opacity = 0;
	        setTimeout(function () {
	          iploader.style.display = 'none';
	        });
	        clearInterval(interval);
	      }
	    }, 80);
	  };
	  loader.setProgressFn(simulationFn);
	}

	startLoading();

/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Vue.js v1.0.10
	 * (c) 2015 Evan You
	 * Released under the MIT License.
	 */
	'use strict';

	function set(obj, key, val) {
	  if (hasOwn(obj, key)) {
	    obj[key] = val;
	    return;
	  }
	  if (obj._isVue) {
	    set(obj._data, key, val);
	    return;
	  }
	  var ob = obj.__ob__;
	  if (!ob) {
	    obj[key] = val;
	    return;
	  }
	  ob.convert(key, val);
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._proxy(key);
	      vm._digest();
	    }
	  }
	}

	/**
	 * Delete a property and trigger change if necessary.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 */

	function del(obj, key) {
	  if (!hasOwn(obj, key)) {
	    return;
	  }
	  delete obj[key];
	  var ob = obj.__ob__;
	  if (!ob) {
	    return;
	  }
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._unproxy(key);
	      vm._digest();
	    }
	  }
	}

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * Check whether the object has the property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @return {Boolean}
	 */

	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}

	/**
	 * Check if an expression is a literal value.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */

	var literalValueRE = /^\s?(true|false|[\d\.]+|'[^']*'|"[^"]*")\s?$/;

	function isLiteral(exp) {
	  return literalValueRE.test(exp);
	}

	/**
	 * Check if a string starts with $ or _
	 *
	 * @param {String} str
	 * @return {Boolean}
	 */

	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}

	/**
	 * Guard text output, make sure undefined outputs
	 * empty string
	 *
	 * @param {*} value
	 * @return {String}
	 */

	function _toString(value) {
	  return value == null ? '' : value.toString();
	}

	/**
	 * Check and convert possible numeric strings to numbers
	 * before setting back to data
	 *
	 * @param {*} value
	 * @return {*|Number}
	 */

	function toNumber(value) {
	  if (typeof value !== 'string') {
	    return value;
	  } else {
	    var parsed = Number(value);
	    return isNaN(parsed) ? value : parsed;
	  }
	}

	/**
	 * Convert string boolean literals into real booleans.
	 *
	 * @param {*} value
	 * @return {*|Boolean}
	 */

	function toBoolean(value) {
	  return value === 'true' ? true : value === 'false' ? false : value;
	}

	/**
	 * Strip quotes from a string
	 *
	 * @param {String} str
	 * @return {String | false}
	 */

	function stripQuotes(str) {
	  var a = str.charCodeAt(0);
	  var b = str.charCodeAt(str.length - 1);
	  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
	}

	/**
	 * Camelize a hyphen-delmited string.
	 *
	 * @param {String} str
	 * @return {String}
	 */

	var camelizeRE = /-(\w)/g;

	function camelize(str) {
	  return str.replace(camelizeRE, toUpper);
	}

	function toUpper(_, c) {
	  return c ? c.toUpperCase() : '';
	}

	/**
	 * Hyphenate a camelCase string.
	 *
	 * @param {String} str
	 * @return {String}
	 */

	var hyphenateRE = /([a-z\d])([A-Z])/g;

	function hyphenate(str) {
	  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
	}

	/**
	 * Converts hyphen/underscore/slash delimitered names into
	 * camelized classNames.
	 *
	 * e.g. my-component => MyComponent
	 *      some_else    => SomeElse
	 *      some/comp    => SomeComp
	 *
	 * @param {String} str
	 * @return {String}
	 */

	var classifyRE = /(?:^|[-_\/])(\w)/g;

	function classify(str) {
	  return str.replace(classifyRE, toUpper);
	}

	/**
	 * Simple bind, faster than native
	 *
	 * @param {Function} fn
	 * @param {Object} ctx
	 * @return {Function}
	 */

	function bind$1(fn, ctx) {
	  return function (a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  };
	}

	/**
	 * Convert an Array-like object to a real Array.
	 *
	 * @param {Array-like} list
	 * @param {Number} [start] - start index
	 * @return {Array}
	 */

	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}

	/**
	 * Mix properties into target object.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 */

	function extend(to, from) {
	  var keys = Object.keys(from);
	  var i = keys.length;
	  while (i--) {
	    to[keys[i]] = from[keys[i]];
	  }
	  return to;
	}

	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */

	function isObject(obj) {
	  return obj !== null && typeof obj === 'object';
	}

	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */

	var toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';

	function isPlainObject(obj) {
	  return toString.call(obj) === OBJECT_STRING;
	}

	/**
	 * Array type check.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */

	var isArray = Array.isArray;

	/**
	 * Define a non-enumerable property
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 * @param {Boolean} [enumerable]
	 */

	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}

	/**
	 * Debounce a function so it only gets called after the
	 * input stops arriving after the given wait period.
	 *
	 * @param {Function} func
	 * @param {Number} wait
	 * @return {Function} - the debounced function
	 */

	function _debounce(func, wait) {
	  var timeout, args, context, timestamp, result;
	  var later = function later() {
	    var last = Date.now() - timestamp;
	    if (last < wait && last >= 0) {
	      timeout = setTimeout(later, wait - last);
	    } else {
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    }
	  };
	  return function () {
	    context = this;
	    args = arguments;
	    timestamp = Date.now();
	    if (!timeout) {
	      timeout = setTimeout(later, wait);
	    }
	    return result;
	  };
	}

	/**
	 * Manual indexOf because it's slightly faster than
	 * native.
	 *
	 * @param {Array} arr
	 * @param {*} obj
	 */

	function indexOf(arr, obj) {
	  var i = arr.length;
	  while (i--) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	}

	/**
	 * Make a cancellable version of an async callback.
	 *
	 * @param {Function} fn
	 * @return {Function}
	 */

	function cancellable(fn) {
	  var cb = function cb() {
	    if (!cb.cancelled) {
	      return fn.apply(this, arguments);
	    }
	  };
	  cb.cancel = function () {
	    cb.cancelled = true;
	  };
	  return cb;
	}

	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 *
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 */

	function looseEqual(a, b) {
	  /* eslint-disable eqeqeq */
	  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
	  /* eslint-enable eqeqeq */
	}

	var hasProto = ('__proto__' in {});

	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';

	var isIE9 = inBrowser && navigator.userAgent.toLowerCase().indexOf('msie 9.0') > 0;

	var isAndroid = inBrowser && navigator.userAgent.toLowerCase().indexOf('android') > 0;

	var transitionProp = undefined;
	var transitionEndEvent = undefined;
	var animationProp = undefined;
	var animationEndEvent = undefined;

	// Transition property/event sniffing
	if (inBrowser && !isIE9) {
	  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
	  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
	  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
	  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
	  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
	  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
	}

	/**
	 * Defer a task to execute it asynchronously. Ideally this
	 * should be executed as a microtask, so we leverage
	 * MutationObserver if it's available, and fallback to
	 * setTimeout(0).
	 *
	 * @param {Function} cb
	 * @param {Object} ctx
	 */

	var nextTick = (function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks = [];
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }
	  /* istanbul ignore if */
	  if (typeof MutationObserver !== 'undefined') {
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(counter);
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function () {
	      counter = (counter + 1) % 2;
	      textNode.data = counter;
	    };
	  } else {
	    timerFunc = setTimeout;
	  }
	  return function (cb, ctx) {
	    var func = ctx ? function () {
	      cb.call(ctx);
	    } : cb;
	    callbacks.push(func);
	    if (pending) return;
	    pending = true;
	    timerFunc(nextTickHandler, 0);
	  };
	})();

	function Cache(limit) {
	  this.size = 0;
	  this.limit = limit;
	  this.head = this.tail = undefined;
	  this._keymap = Object.create(null);
	}

	var p = Cache.prototype;

	/**
	 * Put <value> into the cache associated with <key>.
	 * Returns the entry which was removed to make room for
	 * the new entry. Otherwise undefined is returned.
	 * (i.e. if there was enough room already).
	 *
	 * @param {String} key
	 * @param {*} value
	 * @return {Entry|undefined}
	 */

	p.put = function (key, value) {
	  var entry = {
	    key: key,
	    value: value
	  };
	  this._keymap[key] = entry;
	  if (this.tail) {
	    this.tail.newer = entry;
	    entry.older = this.tail;
	  } else {
	    this.head = entry;
	  }
	  this.tail = entry;
	  if (this.size === this.limit) {
	    return this.shift();
	  } else {
	    this.size++;
	  }
	};

	/**
	 * Purge the least recently used (oldest) entry from the
	 * cache. Returns the removed entry or undefined if the
	 * cache was empty.
	 */

	p.shift = function () {
	  var entry = this.head;
	  if (entry) {
	    this.head = this.head.newer;
	    this.head.older = undefined;
	    entry.newer = entry.older = undefined;
	    this._keymap[entry.key] = undefined;
	  }
	  return entry;
	};

	/**
	 * Get and register recent use of <key>. Returns the value
	 * associated with <key> or undefined if not in cache.
	 *
	 * @param {String} key
	 * @param {Boolean} returnEntry
	 * @return {Entry|*}
	 */

	p.get = function (key, returnEntry) {
	  var entry = this._keymap[key];
	  if (entry === undefined) return;
	  if (entry === this.tail) {
	    return returnEntry ? entry : entry.value;
	  }
	  // HEAD--------------TAIL
	  //   <.older   .newer>
	  //  <--- add direction --
	  //   A  B  C  <D>  E
	  if (entry.newer) {
	    if (entry === this.head) {
	      this.head = entry.newer;
	    }
	    entry.newer.older = entry.older; // C <-- E.
	  }
	  if (entry.older) {
	    entry.older.newer = entry.newer; // C. --> E
	  }
	  entry.newer = undefined; // D --x
	  entry.older = this.tail; // D. --> E
	  if (this.tail) {
	    this.tail.newer = entry; // E. <-- D
	  }
	  this.tail = entry;
	  return returnEntry ? entry : entry.value;
	};

	var cache$1 = new Cache(1000);
	var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
	var reservedArgRE = /^in$|^-?\d+/;

	/**
	 * Parser state
	 */

	var str;
	var dir;
	var c;
	var i;
	var l;
	var lastFilterIndex;
	var inSingle;
	var inDouble;
	var curly;
	var square;
	var paren;
	/**
	 * Push a filter to the current directive object
	 */

	function pushFilter() {
	  var exp = str.slice(lastFilterIndex, i).trim();
	  var filter;
	  if (exp) {
	    filter = {};
	    var tokens = exp.match(filterTokenRE);
	    filter.name = tokens[0];
	    if (tokens.length > 1) {
	      filter.args = tokens.slice(1).map(processFilterArg);
	    }
	  }
	  if (filter) {
	    (dir.filters = dir.filters || []).push(filter);
	  }
	  lastFilterIndex = i + 1;
	}

	/**
	 * Check if an argument is dynamic and strip quotes.
	 *
	 * @param {String} arg
	 * @return {Object}
	 */

	function processFilterArg(arg) {
	  if (reservedArgRE.test(arg)) {
	    return {
	      value: toNumber(arg),
	      dynamic: false
	    };
	  } else {
	    var stripped = stripQuotes(arg);
	    var dynamic = stripped === arg;
	    return {
	      value: dynamic ? arg : stripped,
	      dynamic: dynamic
	    };
	  }
	}

	/**
	 * Parse a directive value and extract the expression
	 * and its filters into a descriptor.
	 *
	 * Example:
	 *
	 * "a + 1 | uppercase" will yield:
	 * {
	 *   expression: 'a + 1',
	 *   filters: [
	 *     { name: 'uppercase', args: null }
	 *   ]
	 * }
	 *
	 * @param {String} str
	 * @return {Object}
	 */

	function parseDirective(s) {

	  var hit = cache$1.get(s);
	  if (hit) {
	    return hit;
	  }

	  // reset parser state
	  str = s;
	  inSingle = inDouble = false;
	  curly = square = paren = 0;
	  lastFilterIndex = 0;
	  dir = {};

	  for (i = 0, l = str.length; i < l; i++) {
	    c = str.charCodeAt(i);
	    if (inSingle) {
	      // check single quote
	      if (c === 0x27) inSingle = !inSingle;
	    } else if (inDouble) {
	      // check double quote
	      if (c === 0x22) inDouble = !inDouble;
	    } else if (c === 0x7C && // pipe
	    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
	      if (dir.expression == null) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        dir.expression = str.slice(0, i).trim();
	      } else {
	        // already has filter
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22:
	          inDouble = true;break; // "
	        case 0x27:
	          inSingle = true;break; // '
	        case 0x28:
	          paren++;break; // (
	        case 0x29:
	          paren--;break; // )
	        case 0x5B:
	          square++;break; // [
	        case 0x5D:
	          square--;break; // ]
	        case 0x7B:
	          curly++;break; // {
	        case 0x7D:
	          curly--;break; // }
	      }
	    }
	  }

	  if (dir.expression == null) {
	    dir.expression = str.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }

	  cache$1.put(s, dir);
	  return dir;
	}

	var directive = Object.freeze({
	  parseDirective: parseDirective
	});

	var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	var cache = undefined;
	var tagRE = undefined;
	var htmlRE = undefined;
	/**
	 * Escape a string so it can be used in a RegExp
	 * constructor.
	 *
	 * @param {String} str
	 */

	function escapeRegex(str) {
	  return str.replace(regexEscapeRE, '\\$&');
	}

	function compileRegex() {
	  var open = escapeRegex(config.delimiters[0]);
	  var close = escapeRegex(config.delimiters[1]);
	  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
	  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
	  tagRE = new RegExp(unsafeOpen + '(.+?)' + unsafeClose + '|' + open + '(.+?)' + close, 'g');
	  htmlRE = new RegExp('^' + unsafeOpen + '.*' + unsafeClose + '$');
	  // reset cache
	  cache = new Cache(1000);
	}

	/**
	 * Parse a template text string into an array of tokens.
	 *
	 * @param {String} text
	 * @return {Array<Object> | null}
	 *               - {String} type
	 *               - {String} value
	 *               - {Boolean} [html]
	 *               - {Boolean} [oneTime]
	 */

	function parseText(text) {
	  if (!cache) {
	    compileRegex();
	  }
	  var hit = cache.get(text);
	  if (hit) {
	    return hit;
	  }
	  text = text.replace(/\n/g, '');
	  if (!tagRE.test(text)) {
	    return null;
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index, html, value, first, oneTime;
	  /* eslint-disable no-cond-assign */
	  while (match = tagRE.exec(text)) {
	    /* eslint-enable no-cond-assign */
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push({
	        value: text.slice(lastIndex, index)
	      });
	    }
	    // tag token
	    html = htmlRE.test(match[0]);
	    value = html ? match[1] : match[2];
	    first = value.charCodeAt(0);
	    oneTime = first === 42; // *
	    value = oneTime ? value.slice(1) : value;
	    tokens.push({
	      tag: true,
	      value: value.trim(),
	      html: html,
	      oneTime: oneTime
	    });
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push({
	      value: text.slice(lastIndex)
	    });
	  }
	  cache.put(text, tokens);
	  return tokens;
	}

	/**
	 * Format a list of tokens into an expression.
	 * e.g. tokens parsed from 'a {{b}} c' can be serialized
	 * into one single expression as '"a " + b + " c"'.
	 *
	 * @param {Array} tokens
	 * @return {String}
	 */

	function tokensToExp(tokens) {
	  if (tokens.length > 1) {
	    return tokens.map(function (token) {
	      return formatToken(token);
	    }).join('+');
	  } else {
	    return formatToken(tokens[0], true);
	  }
	}

	/**
	 * Format a single token.
	 *
	 * @param {Object} token
	 * @param {Boolean} single
	 * @return {String}
	 */

	function formatToken(token, single) {
	  return token.tag ? inlineFilters(token.value, single) : '"' + token.value + '"';
	}

	/**
	 * For an attribute with multiple interpolation tags,
	 * e.g. attr="some-{{thing | filter}}", in order to combine
	 * the whole thing into a single watchable expression, we
	 * have to inline those filters. This function does exactly
	 * that. This is a bit hacky but it avoids heavy changes
	 * to directive parser and watcher mechanism.
	 *
	 * @param {String} exp
	 * @param {Boolean} single
	 * @return {String}
	 */

	var filterRE$1 = /[^|]\|[^|]/;
	function inlineFilters(exp, single) {
	  if (!filterRE$1.test(exp)) {
	    return single ? exp : '(' + exp + ')';
	  } else {
	    var dir = parseDirective(exp);
	    if (!dir.filters) {
	      return '(' + exp + ')';
	    } else {
	      return 'this._applyFilters(' + dir.expression + // value
	      ',null,' + // oldValue (null for read)
	      JSON.stringify(dir.filters) + // filter descriptors
	      ',false)'; // write?
	    }
	  }
	}

	var text$1 = Object.freeze({
	  compileRegex: compileRegex,
	  parseText: parseText,
	  tokensToExp: tokensToExp
	});

	var delimiters = ['{{', '}}'];
	var unsafeDelimiters = ['{{{', '}}}'];

	var config = Object.defineProperties({

	  /**
	   * Whether to print debug messages.
	   * Also enables stack trace for warnings.
	   *
	   * @type {Boolean}
	   */

	  debug: false,

	  /**
	   * Whether to suppress warnings.
	   *
	   * @type {Boolean}
	   */

	  silent: false,

	  /**
	   * Whether to use async rendering.
	   */

	  async: true,

	  /**
	   * Whether to warn against errors caught when evaluating
	   * expressions.
	   */

	  warnExpressionErrors: true,

	  /**
	   * Whether or not to handle fully object properties which
	   * are already backed by getters and seters. Depending on
	   * use case and environment, this might introduce non-neglible
	   * performance penalties.
	   */
	  convertAllProperties: false,

	  /**
	   * Internal flag to indicate the delimiters have been
	   * changed.
	   *
	   * @type {Boolean}
	   */

	  _delimitersChanged: true,

	  /**
	   * List of asset types that a component can own.
	   *
	   * @type {Array}
	   */

	  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],

	  /**
	   * prop binding modes
	   */

	  _propBindingModes: {
	    ONE_WAY: 0,
	    TWO_WAY: 1,
	    ONE_TIME: 2
	  },

	  /**
	   * Max circular updates allowed in a batcher flush cycle.
	   */

	  _maxUpdateCount: 100

	}, {
	  delimiters: { /**
	                 * Interpolation delimiters. Changing these would trigger
	                 * the text parser to re-compile the regular expressions.
	                 *
	                 * @type {Array<String>}
	                 */

	    get: function get() {
	      return delimiters;
	    },
	    set: function set(val) {
	      delimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  },
	  unsafeDelimiters: {
	    get: function get() {
	      return unsafeDelimiters;
	    },
	    set: function set(val) {
	      unsafeDelimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  }
	});

	var warn = undefined;

	if (false) {
	  (function () {
	    var hasConsole = typeof console !== 'undefined';
	    warn = function (msg, e) {
	      if (hasConsole && (!config.silent || config.debug)) {
	        console.warn('[Vue warn]: ' + msg);
	        /* istanbul ignore if */
	        if (config.debug) {
	          if (e) {
	            throw e;
	          } else {
	            console.warn(new Error('Warning Stack Trace').stack);
	          }
	        }
	      }
	    };
	  })();
	}

	/**
	 * Append with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */

	function appendWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    target.appendChild(el);
	  }, vm, cb);
	}

	/**
	 * InsertBefore with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */

	function beforeWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    before(el, target);
	  }, vm, cb);
	}

	/**
	 * Remove with transition.
	 *
	 * @param {Element} el
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */

	function removeWithTransition(el, vm, cb) {
	  applyTransition(el, -1, function () {
	    remove(el);
	  }, vm, cb);
	}

	/**
	 * Apply transitions with an operation callback.
	 *
	 * @param {Element} el
	 * @param {Number} direction
	 *                  1: enter
	 *                 -1: leave
	 * @param {Function} op - the actual DOM operation
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */

	function applyTransition(el, direction, op, vm, cb) {
	  var transition = el.__v_trans;
	  if (!transition ||
	  // skip if there are no js hooks and CSS transition is
	  // not supported
	  !transition.hooks && !transitionEndEvent ||
	  // skip transitions for initial compile
	  !vm._isCompiled ||
	  // if the vm is being manipulated by a parent directive
	  // during the parent's compilation phase, skip the
	  // animation.
	  vm.$parent && !vm.$parent._isCompiled) {
	    op();
	    if (cb) cb();
	    return;
	  }
	  var action = direction > 0 ? 'enter' : 'leave';
	  transition[action](op, cb);
	}

	/**
	 * Query an element selector if it's not an element already.
	 *
	 * @param {String|Element} el
	 * @return {Element}
	 */

	function query(el) {
	  if (typeof el === 'string') {
	    var selector = el;
	    el = document.querySelector(el);
	    if (!el) {
	      ("production") !== 'production' && warn('Cannot find element: ' + selector);
	    }
	  }
	  return el;
	}

	/**
	 * Check if a node is in the document.
	 * Note: document.documentElement.contains should work here
	 * but always returns false for comment nodes in phantomjs,
	 * making unit tests difficult. This is fixed by doing the
	 * contains() check on the node's parentNode instead of
	 * the node itself.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */

	function inDoc(node) {
	  var doc = document.documentElement;
	  var parent = node && node.parentNode;
	  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
	}

	/**
	 * Get and remove an attribute from a node.
	 *
	 * @param {Node} node
	 * @param {String} _attr
	 */

	function getAttr(node, _attr) {
	  var val = node.getAttribute(_attr);
	  if (val !== null) {
	    node.removeAttribute(_attr);
	  }
	  return val;
	}

	/**
	 * Get an attribute with colon or v-bind: prefix.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {String|null}
	 */

	function getBindAttr(node, name) {
	  var val = getAttr(node, ':' + name);
	  if (val === null) {
	    val = getAttr(node, 'v-bind:' + name);
	  }
	  return val;
	}

	/**
	 * Insert el before target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */

	function before(el, target) {
	  target.parentNode.insertBefore(el, target);
	}

	/**
	 * Insert el after target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */

	function after(el, target) {
	  if (target.nextSibling) {
	    before(el, target.nextSibling);
	  } else {
	    target.parentNode.appendChild(el);
	  }
	}

	/**
	 * Remove el from DOM
	 *
	 * @param {Element} el
	 */

	function remove(el) {
	  el.parentNode.removeChild(el);
	}

	/**
	 * Prepend el to target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */

	function prepend(el, target) {
	  if (target.firstChild) {
	    before(el, target.firstChild);
	  } else {
	    target.appendChild(el);
	  }
	}

	/**
	 * Replace target with el
	 *
	 * @param {Element} target
	 * @param {Element} el
	 */

	function replace(target, el) {
	  var parent = target.parentNode;
	  if (parent) {
	    parent.replaceChild(el, target);
	  }
	}

	/**
	 * Add event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 */

	function on$1(el, event, cb) {
	  el.addEventListener(event, cb);
	}

	/**
	 * Remove event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 */

	function off(el, event, cb) {
	  el.removeEventListener(event, cb);
	}

	/**
	 * Add class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {Strong} cls
	 */

	function addClass(el, cls) {
	  if (el.classList) {
	    el.classList.add(cls);
	  } else {
	    var cur = ' ' + (el.getAttribute('class') || '') + ' ';
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      el.setAttribute('class', (cur + cls).trim());
	    }
	  }
	}

	/**
	 * Remove class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {Strong} cls
	 */

	function removeClass(el, cls) {
	  if (el.classList) {
	    el.classList.remove(cls);
	  } else {
	    var cur = ' ' + (el.getAttribute('class') || '') + ' ';
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    el.setAttribute('class', cur.trim());
	  }
	  if (!el.className) {
	    el.removeAttribute('class');
	  }
	}

	/**
	 * Extract raw content inside an element into a temporary
	 * container div
	 *
	 * @param {Element} el
	 * @param {Boolean} asFragment
	 * @return {Element}
	 */

	function extractContent(el, asFragment) {
	  var child;
	  var rawContent;
	  /* istanbul ignore if */
	  if (isTemplate(el) && el.content instanceof DocumentFragment) {
	    el = el.content;
	  }
	  if (el.hasChildNodes()) {
	    trimNode(el);
	    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
	    /* eslint-disable no-cond-assign */
	    while (child = el.firstChild) {
	      /* eslint-enable no-cond-assign */
	      rawContent.appendChild(child);
	    }
	  }
	  return rawContent;
	}

	/**
	 * Trim possible empty head/tail textNodes inside a parent.
	 *
	 * @param {Node} node
	 */

	function trimNode(node) {
	  trim(node, node.firstChild);
	  trim(node, node.lastChild);
	}

	function trim(parent, node) {
	  if (node && node.nodeType === 3 && !node.data.trim()) {
	    parent.removeChild(node);
	  }
	}

	/**
	 * Check if an element is a template tag.
	 * Note if the template appears inside an SVG its tagName
	 * will be in lowercase.
	 *
	 * @param {Element} el
	 */

	function isTemplate(el) {
	  return el.tagName && el.tagName.toLowerCase() === 'template';
	}

	/**
	 * Create an "anchor" for performing dom insertion/removals.
	 * This is used in a number of scenarios:
	 * - fragment instance
	 * - v-html
	 * - v-if
	 * - v-for
	 * - component
	 *
	 * @param {String} content
	 * @param {Boolean} persist - IE trashes empty textNodes on
	 *                            cloneNode(true), so in certain
	 *                            cases the anchor needs to be
	 *                            non-empty to be persisted in
	 *                            templates.
	 * @return {Comment|Text}
	 */

	function createAnchor(content, persist) {
	  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
	  anchor.__vue_anchor = true;
	  return anchor;
	}

	/**
	 * Find a component ref attribute that starts with $.
	 *
	 * @param {Element} node
	 * @return {String|undefined}
	 */

	var refRE = /^v-ref:/;

	function findRef(node) {
	  if (node.hasAttributes()) {
	    var attrs = node.attributes;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      var name = attrs[i].name;
	      if (refRE.test(name)) {
	        return camelize(name.replace(refRE, ''));
	      }
	    }
	  }
	}

	/**
	 * Map a function to a range of nodes .
	 *
	 * @param {Node} node
	 * @param {Node} end
	 * @param {Function} op
	 */

	function mapNodeRange(node, end, op) {
	  var next;
	  while (node !== end) {
	    next = node.nextSibling;
	    op(node);
	    node = next;
	  }
	  op(end);
	}

	/**
	 * Remove a range of nodes with transition, store
	 * the nodes in a fragment with correct ordering,
	 * and call callback when done.
	 *
	 * @param {Node} start
	 * @param {Node} end
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Function} cb
	 */

	function removeNodeRange(start, end, vm, frag, cb) {
	  var done = false;
	  var removed = 0;
	  var nodes = [];
	  mapNodeRange(start, end, function (node) {
	    if (node === end) done = true;
	    nodes.push(node);
	    removeWithTransition(node, vm, onRemoved);
	  });
	  function onRemoved() {
	    removed++;
	    if (done && removed >= nodes.length) {
	      for (var i = 0; i < nodes.length; i++) {
	        frag.appendChild(nodes[i]);
	      }
	      cb && cb();
	    }
	  }
	}

	var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/;

	/**
	 * Check if an element is a component, if yes return its
	 * component id.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */

	function checkComponentAttr(el, options) {
	  var tag = el.tagName.toLowerCase();
	  var hasAttrs = el.hasAttributes();
	  if (!commonTagRE.test(tag) && tag !== 'component') {
	    if (resolveAsset(options, 'components', tag)) {
	      return { id: tag };
	    } else {
	      var is = hasAttrs && getIsBinding(el);
	      if (is) {
	        return is;
	      } else if (false) {
	        if (tag.indexOf('-') > -1 || /HTMLUnknownElement/.test(el.toString()) &&
	        // Chrome returns unknown for several HTML5 elements.
	        // https://code.google.com/p/chromium/issues/detail?id=540526
	        !/^(data|time|rtc|rb)$/.test(tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly?');
	        }
	      }
	    }
	  } else if (hasAttrs) {
	    return getIsBinding(el);
	  }
	}

	/**
	 * Get "is" binding from an element.
	 *
	 * @param {Element} el
	 * @return {Object|undefined}
	 */

	function getIsBinding(el) {
	  // dynamic syntax
	  var exp = getAttr(el, 'is');
	  if (exp != null) {
	    return { id: exp };
	  } else {
	    exp = getBindAttr(el, 'is');
	    if (exp != null) {
	      return { id: exp, dynamic: true };
	    }
	  }
	}

	/**
	 * Set a prop's initial value on a vm and its data object.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */

	function initProp(vm, prop, value) {
	  var key = prop.path;
	  vm[key] = vm._data[key] = assertProp(prop, value) ? value : undefined;
	}

	/**
	 * Assert whether a prop is valid.
	 *
	 * @param {Object} prop
	 * @param {*} value
	 */

	function assertProp(prop, value) {
	  // if a prop is not provided and is not required,
	  // skip the check.
	  if (prop.raw === null && !prop.required) {
	    return true;
	  }
	  var options = prop.options;
	  var type = options.type;
	  var valid = true;
	  var expectedType;
	  if (type) {
	    if (type === String) {
	      expectedType = 'string';
	      valid = typeof value === expectedType;
	    } else if (type === Number) {
	      expectedType = 'number';
	      valid = typeof value === 'number';
	    } else if (type === Boolean) {
	      expectedType = 'boolean';
	      valid = typeof value === 'boolean';
	    } else if (type === Function) {
	      expectedType = 'function';
	      valid = typeof value === 'function';
	    } else if (type === Object) {
	      expectedType = 'object';
	      valid = isPlainObject(value);
	    } else if (type === Array) {
	      expectedType = 'array';
	      valid = isArray(value);
	    } else {
	      valid = value instanceof type;
	    }
	  }
	  if (!valid) {
	    ("production") !== 'production' && warn('Invalid prop: type check failed for ' + prop.path + '="' + prop.raw + '".' + ' Expected ' + formatType(expectedType) + ', got ' + formatValue(value) + '.');
	    return false;
	  }
	  var validator = options.validator;
	  if (validator) {
	    if (!validator.call(null, value)) {
	      ("production") !== 'production' && warn('Invalid prop: custom validator check failed for ' + prop.path + '="' + prop.raw + '"');
	      return false;
	    }
	  }
	  return true;
	}

	function formatType(val) {
	  return val ? val.charAt(0).toUpperCase() + val.slice(1) : 'custom type';
	}

	function formatValue(val) {
	  return Object.prototype.toString.call(val).slice(8, -1);
	}

	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 *
	 * All strategy functions follow the same signature:
	 *
	 * @param {*} parentVal
	 * @param {*} childVal
	 * @param {Vue} [vm]
	 */

	var strats = config.optionMergeStrategies = Object.create(null);

	/**
	 * Helper that recursively merges two data objects together.
	 */

	function mergeData(to, from) {
	  var key, toVal, fromVal;
	  for (key in from) {
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isObject(toVal) && isObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}

	/**
	 * Data
	 */

	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (typeof childVal !== 'function') {
	      ("production") !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.');
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(childVal.call(this), parentVal.call(this));
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	};

	/**
	 * El
	 */

	strats.el = function (parentVal, childVal, vm) {
	  if (!vm && childVal && typeof childVal !== 'function') {
	    ("production") !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.');
	    return;
	  }
	  var ret = childVal || parentVal;
	  // invoke the element factory if this is instance merge
	  return vm && typeof ret === 'function' ? ret.call(vm) : ret;
	};

	/**
	 * Hooks and param attributes are merged as arrays.
	 */

	strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = function (parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
	};

	/**
	 * 0.11 deprecation warning
	 */

	strats.paramAttributes = function () {
	  /* istanbul ignore next */
	  ("production") !== 'production' && warn('"paramAttributes" option has been deprecated in 0.12. ' + 'Use "props" instead.');
	};

	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */

	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal);
	  return childVal ? extend(res, guardArrayAssets(childVal)) : res;
	}

	config._assetTypes.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});

	/**
	 * Events & Watchers.
	 *
	 * Events & watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */

	strats.watch = strats.events = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : [child];
	  }
	  return ret;
	};

	/**
	 * Other object hashes.
	 */

	strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  extend(ret, childVal);
	  return ret;
	};

	/**
	 * Default strategy.
	 */

	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};

	/**
	 * Make sure component options get converted to actual
	 * constructors.
	 *
	 * @param {Object} options
	 */

	function guardComponents(options) {
	  if (options.components) {
	    var components = options.components = guardArrayAssets(options.components);
	    var def;
	    var ids = Object.keys(components);
	    for (var i = 0, l = ids.length; i < l; i++) {
	      var key = ids[i];
	      if (commonTagRE.test(key)) {
	        ("production") !== 'production' && warn('Do not use built-in HTML elements as component ' + 'id: ' + key);
	        continue;
	      }
	      def = components[key];
	      if (isPlainObject(def)) {
	        components[key] = Vue.extend(def);
	      }
	    }
	  }
	}

	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 *
	 * @param {Object} options
	 */

	function guardProps(options) {
	  var props = options.props;
	  var i, val;
	  if (isArray(props)) {
	    options.props = {};
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        options.props[val] = null;
	      } else if (val.name) {
	        options.props[val.name] = val;
	      }
	    }
	  } else if (isPlainObject(props)) {
	    var keys = Object.keys(props);
	    i = keys.length;
	    while (i--) {
	      val = props[keys[i]];
	      if (typeof val === 'function') {
	        props[keys[i]] = { type: val };
	      }
	    }
	  }
	}

	/**
	 * Guard an Array-format assets option and converted it
	 * into the key-value Object format.
	 *
	 * @param {Object|Array} assets
	 * @return {Object}
	 */

	function guardArrayAssets(assets) {
	  if (isArray(assets)) {
	    var res = {};
	    var i = assets.length;
	    var asset;
	    while (i--) {
	      asset = assets[i];
	      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
	      if (!id) {
	        ("production") !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
	      } else {
	        res[id] = asset;
	      }
	    }
	    return res;
	  }
	  return assets;
	}

	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 *
	 * @param {Object} parent
	 * @param {Object} child
	 * @param {Vue} [vm] - if vm is present, indicates this is
	 *                     an instantiation merge.
	 */

	function mergeOptions(parent, child, vm) {
	  guardComponents(child);
	  guardProps(child);
	  var options = {};
	  var key;
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      parent = mergeOptions(parent, child.mixins[i], vm);
	    }
	  }
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}

	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 *
	 * @param {Object} options
	 * @param {String} type
	 * @param {String} id
	 * @return {Object|Function}
	 */

	function resolveAsset(options, type, id) {
	  var assets = options[type];
	  var camelizedId;
	  return assets[id] ||
	  // camelCase ID
	  assets[camelizedId = camelize(id)] ||
	  // Pascal Case ID
	  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
	}

	/**
	 * Assert asset exists
	 */

	function assertAsset(val, type, id) {
	  if (!val) {
	    ("production") !== 'production' && warn('Failed to resolve ' + type + ': ' + id);
	  }
	}

	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto)

	/**
	 * Intercept mutating methods and emit events
	 */

	;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break;
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) ob.observeArray(inserted);
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});

	/**
	 * Swap the element at the given index with a new value
	 * and emits corresponding event.
	 *
	 * @param {Number} index
	 * @param {*} val
	 * @return {*} - replaced element
	 */

	def(arrayProto, '$set', function $set(index, val) {
	  if (index >= this.length) {
	    this.length = index + 1;
	  }
	  return this.splice(index, 1, val)[0];
	});

	/**
	 * Convenience method to remove the element at given index.
	 *
	 * @param {Number} index
	 * @param {*} val
	 */

	def(arrayProto, '$remove', function $remove(item) {
	  /* istanbul ignore if */
	  if (!this.length) return;
	  var index = indexOf(this, item);
	  if (index > -1) {
	    return this.splice(index, 1);
	  }
	});

	var uid$3 = 0;

	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 *
	 * @constructor
	 */
	function Dep() {
	  this.id = uid$3++;
	  this.subs = [];
	}

	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;

	/**
	 * Add a directive subscriber.
	 *
	 * @param {Directive} sub
	 */

	Dep.prototype.addSub = function (sub) {
	  this.subs.push(sub);
	};

	/**
	 * Remove a directive subscriber.
	 *
	 * @param {Directive} sub
	 */

	Dep.prototype.removeSub = function (sub) {
	  this.subs.$remove(sub);
	};

	/**
	 * Add self as a dependency to the target watcher.
	 */

	Dep.prototype.depend = function () {
	  Dep.target.addDep(this);
	};

	/**
	 * Notify all subscribers of a new value.
	 */

	Dep.prototype.notify = function () {
	  // stablize the subscriber list first
	  var subs = toArray(this.subs);
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};

	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 *
	 * @param {Array|Object} value
	 * @constructor
	 */

	function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  def(value, '__ob__', this);
	  if (isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	}

	// Instance methods

	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 *
	 * @param {Object} obj
	 */

	Observer.prototype.walk = function (obj) {
	  var keys = Object.keys(obj);
	  var i = keys.length;
	  while (i--) {
	    this.convert(keys[i], obj[keys[i]]);
	  }
	};

	/**
	 * Observe a list of Array items.
	 *
	 * @param {Array} items
	 */

	Observer.prototype.observeArray = function (items) {
	  var i = items.length;
	  while (i--) {
	    observe(items[i]);
	  }
	};

	/**
	 * Convert a property into getter/setter so we can emit
	 * the events when the property is accessed/changed.
	 *
	 * @param {String} key
	 * @param {*} val
	 */

	Observer.prototype.convert = function (key, val) {
	  defineReactive(this.value, key, val);
	};

	/**
	 * Add an owner vm, so that when $set/$delete mutations
	 * happen we can notify owner vms to proxy the keys and
	 * digest the watchers. This is only called when the object
	 * is observed as an instance's root $data.
	 *
	 * @param {Vue} vm
	 */

	Observer.prototype.addVm = function (vm) {
	  (this.vms || (this.vms = [])).push(vm);
	};

	/**
	 * Remove an owner vm. This is called when the object is
	 * swapped out as an instance's $data object.
	 *
	 * @param {Vue} vm
	 */

	Observer.prototype.removeVm = function (vm) {
	  this.vms.$remove(vm);
	};

	// helpers

	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 *
	 * @param {Object|Array} target
	 * @param {Object} proto
	 */

	function protoAugment(target, src) {
	  target.__proto__ = src;
	}

	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 *
	 * @param {Object|Array} target
	 * @param {Object} proto
	 */

	function copyAugment(target, src, keys) {
	  var i = keys.length;
	  var key;
	  while (i--) {
	    key = keys[i];
	    def(target, key, src[key]);
	  }
	}

	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 *
	 * @param {*} value
	 * @param {Vue} [vm]
	 * @return {Observer|undefined}
	 * @static
	 */

	function observe(value, vm) {
	  if (!value || typeof value !== 'object') {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if ((isArray(value) || isPlainObject(value)) && !Object.isFrozen(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (ob && vm) {
	    ob.addVm(vm);
	  }
	  return ob;
	}

	/**
	 * Define a reactive property on an Object.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 */

	function defineReactive(obj, key, val) {
	  var dep = new Dep();

	  // cater for pre-defined getter/setters
	  var getter, setter;
	  if (config.convertAllProperties) {
	    var property = Object.getOwnPropertyDescriptor(obj, key);
	    if (property && property.configurable === false) {
	      return;
	    }
	    getter = property && property.get;
	    setter = property && property.set;
	  }

	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (isArray(value)) {
	          for (var e, i = 0, l = value.length; i < l; i++) {
	            e = value[i];
	            e && e.__ob__ && e.__ob__.dep.depend();
	          }
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      if (newVal === value) {
	        return;
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}

	var util = Object.freeze({
		defineReactive: defineReactive,
		set: set,
		del: del,
		hasOwn: hasOwn,
		isLiteral: isLiteral,
		isReserved: isReserved,
		_toString: _toString,
		toNumber: toNumber,
		toBoolean: toBoolean,
		stripQuotes: stripQuotes,
		camelize: camelize,
		hyphenate: hyphenate,
		classify: classify,
		bind: bind$1,
		toArray: toArray,
		extend: extend,
		isObject: isObject,
		isPlainObject: isPlainObject,
		def: def,
		debounce: _debounce,
		indexOf: indexOf,
		cancellable: cancellable,
		looseEqual: looseEqual,
		isArray: isArray,
		hasProto: hasProto,
		inBrowser: inBrowser,
		isIE9: isIE9,
		isAndroid: isAndroid,
		get transitionProp () { return transitionProp; },
		get transitionEndEvent () { return transitionEndEvent; },
		get animationProp () { return animationProp; },
		get animationEndEvent () { return animationEndEvent; },
		nextTick: nextTick,
		query: query,
		inDoc: inDoc,
		getAttr: getAttr,
		getBindAttr: getBindAttr,
		before: before,
		after: after,
		remove: remove,
		prepend: prepend,
		replace: replace,
		on: on$1,
		off: off,
		addClass: addClass,
		removeClass: removeClass,
		extractContent: extractContent,
		trimNode: trimNode,
		isTemplate: isTemplate,
		createAnchor: createAnchor,
		findRef: findRef,
		mapNodeRange: mapNodeRange,
		removeNodeRange: removeNodeRange,
		mergeOptions: mergeOptions,
		resolveAsset: resolveAsset,
		assertAsset: assertAsset,
		checkComponentAttr: checkComponentAttr,
		initProp: initProp,
		assertProp: assertProp,
		commonTagRE: commonTagRE,
		get warn () { return warn; }
	});

	var uid = 0;

	function initMixin (Vue) {

	  /**
	   * The main init sequence. This is called for every
	   * instance, including ones that are created from extended
	   * constructors.
	   *
	   * @param {Object} options - this options object should be
	   *                           the result of merging class
	   *                           options and the options passed
	   *                           in to the constructor.
	   */

	  Vue.prototype._init = function (options) {

	    options = options || {};

	    this.$el = null;
	    this.$parent = options.parent;
	    this.$root = this.$parent ? this.$parent.$root : this;
	    this.$children = [];
	    this.$refs = {}; // child vm references
	    this.$els = {}; // element references
	    this._watchers = []; // all watchers as an array
	    this._directives = []; // all directives

	    // a uid
	    this._uid = uid++;

	    // a flag to avoid this being observed
	    this._isVue = true;

	    // events bookkeeping
	    this._events = {}; // registered callbacks
	    this._eventsCount = {}; // for $broadcast optimization

	    // fragment instance properties
	    this._isFragment = false;
	    this._fragment = // @type {DocumentFragment}
	    this._fragmentStart = // @type {Text|Comment}
	    this._fragmentEnd = null; // @type {Text|Comment}

	    // lifecycle state
	    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = false;
	    this._unlinkFn = null;

	    // context:
	    // if this is a transcluded component, context
	    // will be the common parent vm of this instance
	    // and its host.
	    this._context = options._context || this.$parent;

	    // scope:
	    // if this is inside an inline v-for, the scope
	    // will be the intermediate scope created for this
	    // repeat fragment. this is used for linking props
	    // and container directives.
	    this._scope = options._scope;

	    // fragment:
	    // if this instance is compiled inside a Fragment, it
	    // needs to reigster itself as a child of that fragment
	    // for attach/detach to work properly.
	    this._frag = options._frag;
	    if (this._frag) {
	      this._frag.children.push(this);
	    }

	    // push self into parent / transclusion host
	    if (this.$parent) {
	      this.$parent.$children.push(this);
	    }

	    // merge options.
	    options = this.$options = mergeOptions(this.constructor.options, options, this);

	    // set ref
	    this._updateRef();

	    // initialize data as empty object.
	    // it will be filled up in _initScope().
	    this._data = {};

	    // call init hook
	    this._callHook('init');

	    // initialize data observation and scope inheritance.
	    this._initState();

	    // setup event system and option events.
	    this._initEvents();

	    // call created hook
	    this._callHook('created');

	    // if `el` option is passed, start compilation.
	    if (options.el) {
	      this.$mount(options.el);
	    }
	  };
	}

	var pathCache = new Cache(1000);

	// actions
	var APPEND = 0;
	var PUSH = 1;
	var INC_SUB_PATH_DEPTH = 2;
	var PUSH_SUB_PATH = 3;

	// states
	var BEFORE_PATH = 0;
	var IN_PATH = 1;
	var BEFORE_IDENT = 2;
	var IN_IDENT = 3;
	var IN_SUB_PATH = 4;
	var IN_SINGLE_QUOTE = 5;
	var IN_DOUBLE_QUOTE = 6;
	var AFTER_PATH = 7;
	var ERROR = 8;

	var pathStateMachine = [];

	pathStateMachine[BEFORE_PATH] = {
	  'ws': [BEFORE_PATH],
	  'ident': [IN_IDENT, APPEND],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};

	pathStateMachine[IN_PATH] = {
	  'ws': [IN_PATH],
	  '.': [BEFORE_IDENT],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};

	pathStateMachine[BEFORE_IDENT] = {
	  'ws': [BEFORE_IDENT],
	  'ident': [IN_IDENT, APPEND]
	};

	pathStateMachine[IN_IDENT] = {
	  'ident': [IN_IDENT, APPEND],
	  '0': [IN_IDENT, APPEND],
	  'number': [IN_IDENT, APPEND],
	  'ws': [IN_PATH, PUSH],
	  '.': [BEFORE_IDENT, PUSH],
	  '[': [IN_SUB_PATH, PUSH],
	  'eof': [AFTER_PATH, PUSH]
	};

	pathStateMachine[IN_SUB_PATH] = {
	  "'": [IN_SINGLE_QUOTE, APPEND],
	  '"': [IN_DOUBLE_QUOTE, APPEND],
	  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
	  ']': [IN_PATH, PUSH_SUB_PATH],
	  'eof': ERROR,
	  'else': [IN_SUB_PATH, APPEND]
	};

	pathStateMachine[IN_SINGLE_QUOTE] = {
	  "'": [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_SINGLE_QUOTE, APPEND]
	};

	pathStateMachine[IN_DOUBLE_QUOTE] = {
	  '"': [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_DOUBLE_QUOTE, APPEND]
	};

	/**
	 * Determine the type of a character in a keypath.
	 *
	 * @param {Char} ch
	 * @return {String} type
	 */

	function getPathCharType(ch) {
	  if (ch === undefined) {
	    return 'eof';
	  }

	  var code = ch.charCodeAt(0);

	  switch (code) {
	    case 0x5B: // [
	    case 0x5D: // ]
	    case 0x2E: // .
	    case 0x22: // "
	    case 0x27: // '
	    case 0x30:
	      // 0
	      return ch;

	    case 0x5F: // _
	    case 0x24:
	      // $
	      return 'ident';

	    case 0x20: // Space
	    case 0x09: // Tab
	    case 0x0A: // Newline
	    case 0x0D: // Return
	    case 0xA0: // No-break space
	    case 0xFEFF: // Byte Order Mark
	    case 0x2028: // Line Separator
	    case 0x2029:
	      // Paragraph Separator
	      return 'ws';
	  }

	  // a-z, A-Z
	  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
	    return 'ident';
	  }

	  // 1-9
	  if (code >= 0x31 && code <= 0x39) {
	    return 'number';
	  }

	  return 'else';
	}

	/**
	 * Format a subPath, return its plain form if it is
	 * a literal string or number. Otherwise prepend the
	 * dynamic indicator (*).
	 *
	 * @param {String} path
	 * @return {String}
	 */

	function formatSubPath(path) {
	  var trimmed = path.trim();
	  // invalid leading 0
	  if (path.charAt(0) === '0' && isNaN(path)) {
	    return false;
	  }
	  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
	}

	/**
	 * Parse a string path into an array of segments
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */

	function parse(path) {
	  var keys = [];
	  var index = -1;
	  var mode = BEFORE_PATH;
	  var subPathDepth = 0;
	  var c, newChar, key, type, transition, action, typeMap;

	  var actions = [];

	  actions[PUSH] = function () {
	    if (key !== undefined) {
	      keys.push(key);
	      key = undefined;
	    }
	  };

	  actions[APPEND] = function () {
	    if (key === undefined) {
	      key = newChar;
	    } else {
	      key += newChar;
	    }
	  };

	  actions[INC_SUB_PATH_DEPTH] = function () {
	    actions[APPEND]();
	    subPathDepth++;
	  };

	  actions[PUSH_SUB_PATH] = function () {
	    if (subPathDepth > 0) {
	      subPathDepth--;
	      mode = IN_SUB_PATH;
	      actions[APPEND]();
	    } else {
	      subPathDepth = 0;
	      key = formatSubPath(key);
	      if (key === false) {
	        return false;
	      } else {
	        actions[PUSH]();
	      }
	    }
	  };

	  function maybeUnescapeQuote() {
	    var nextChar = path[index + 1];
	    if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
	      index++;
	      newChar = '\\' + nextChar;
	      actions[APPEND]();
	      return true;
	    }
	  }

	  while (mode != null) {
	    index++;
	    c = path[index];

	    if (c === '\\' && maybeUnescapeQuote()) {
	      continue;
	    }

	    type = getPathCharType(c);
	    typeMap = pathStateMachine[mode];
	    transition = typeMap[type] || typeMap['else'] || ERROR;

	    if (transition === ERROR) {
	      return; // parse error
	    }

	    mode = transition[0];
	    action = actions[transition[1]];
	    if (action) {
	      newChar = transition[2];
	      newChar = newChar === undefined ? c : newChar;
	      if (action() === false) {
	        return;
	      }
	    }

	    if (mode === AFTER_PATH) {
	      keys.raw = path;
	      return keys;
	    }
	  }
	}

	/**
	 * External parse that check for a cache hit first
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */

	function parsePath(path) {
	  var hit = pathCache.get(path);
	  if (!hit) {
	    hit = parse(path);
	    if (hit) {
	      pathCache.put(path, hit);
	    }
	  }
	  return hit;
	}

	/**
	 * Get from an object from a path string
	 *
	 * @param {Object} obj
	 * @param {String} path
	 */

	function getPath(obj, path) {
	  return parseExpression(path).get(obj);
	}

	/**
	 * Warn against setting non-existent root path on a vm.
	 */

	var warnNonExistent;
	if (false) {
	  warnNonExistent = function (path) {
	    warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.');
	  };
	}

	/**
	 * Set on an object from a path
	 *
	 * @param {Object} obj
	 * @param {String | Array} path
	 * @param {*} val
	 */

	function setPath(obj, path, val) {
	  var original = obj;
	  if (typeof path === 'string') {
	    path = parse(path);
	  }
	  if (!path || !isObject(obj)) {
	    return false;
	  }
	  var last, key;
	  for (var i = 0, l = path.length; i < l; i++) {
	    last = obj;
	    key = path[i];
	    if (key.charAt(0) === '*') {
	      key = parseExpression(key.slice(1)).get.call(original, original);
	    }
	    if (i < l - 1) {
	      obj = obj[key];
	      if (!isObject(obj)) {
	        obj = {};
	        if (false) {
	          warnNonExistent(path);
	        }
	        set(last, key, obj);
	      }
	    } else {
	      if (isArray(obj)) {
	        obj.$set(key, val);
	      } else if (key in obj) {
	        obj[key] = val;
	      } else {
	        if (false) {
	          warnNonExistent(path);
	        }
	        set(obj, key, val);
	      }
	    }
	  }
	  return true;
	}

	var path = Object.freeze({
	  parsePath: parsePath,
	  getPath: getPath,
	  setPath: setPath
	});

	var expressionCache = new Cache(1000);

	var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
	var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');

	// keywords that don't make sense inside expressions
	var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'proctected,static,interface,private,public';
	var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');

	var wsRE = /\s/g;
	var newlineRE = /\n/g;
	var saveRE = /[\{,]\s*[\w\$_]+\s*:|('[^']*'|"[^"]*")|new |typeof |void /g;
	var restoreRE = /"(\d+)"/g;
	var pathTestRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
	var pathReplaceRE = /[^\w$\.]([A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\])*)/g;
	var booleanLiteralRE = /^(true|false)$/;

	/**
	 * Save / Rewrite / Restore
	 *
	 * When rewriting paths found in an expression, it is
	 * possible for the same letter sequences to be found in
	 * strings and Object literal property keys. Therefore we
	 * remove and store these parts in a temporary array, and
	 * restore them after the path rewrite.
	 */

	var saved = [];

	/**
	 * Save replacer
	 *
	 * The save regex can match two possible cases:
	 * 1. An opening object literal
	 * 2. A string
	 * If matched as a plain string, we need to escape its
	 * newlines, since the string needs to be preserved when
	 * generating the function body.
	 *
	 * @param {String} str
	 * @param {String} isString - str if matched as a string
	 * @return {String} - placeholder with index
	 */

	function save(str, isString) {
	  var i = saved.length;
	  saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
	  return '"' + i + '"';
	}

	/**
	 * Path rewrite replacer
	 *
	 * @param {String} raw
	 * @return {String}
	 */

	function rewrite(raw) {
	  var c = raw.charAt(0);
	  var path = raw.slice(1);
	  if (allowedKeywordsRE.test(path)) {
	    return raw;
	  } else {
	    path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
	    return c + 'scope.' + path;
	  }
	}

	/**
	 * Restore replacer
	 *
	 * @param {String} str
	 * @param {String} i - matched save index
	 * @return {String}
	 */

	function restore(str, i) {
	  return saved[i];
	}

	/**
	 * Rewrite an expression, prefixing all path accessors with
	 * `scope.` and generate getter/setter functions.
	 *
	 * @param {String} exp
	 * @return {Function}
	 */

	function compileGetter(exp) {
	  if (improperKeywordsRE.test(exp)) {
	    ("production") !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
	  }
	  // reset state
	  saved.length = 0;
	  // save strings and object literal keys
	  var body = exp.replace(saveRE, save).replace(wsRE, '');
	  // rewrite all paths
	  // pad 1 space here becaue the regex matches 1 extra char
	  body = (' ' + body).replace(pathReplaceRE, rewrite).replace(restoreRE, restore);
	  return makeGetterFn(body);
	}

	/**
	 * Build a getter function. Requires eval.
	 *
	 * We isolate the try/catch so it doesn't affect the
	 * optimization of the parse function when it is not called.
	 *
	 * @param {String} body
	 * @return {Function|undefined}
	 */

	function makeGetterFn(body) {
	  try {
	    return new Function('scope', 'return ' + body + ';');
	  } catch (e) {
	    ("production") !== 'production' && warn('Invalid expression. ' + 'Generated function body: ' + body);
	  }
	}

	/**
	 * Compile a setter function for the expression.
	 *
	 * @param {String} exp
	 * @return {Function|undefined}
	 */

	function compileSetter(exp) {
	  var path = parsePath(exp);
	  if (path) {
	    return function (scope, val) {
	      setPath(scope, path, val);
	    };
	  } else {
	    ("production") !== 'production' && warn('Invalid setter expression: ' + exp);
	  }
	}

	/**
	 * Parse an expression into re-written getter/setters.
	 *
	 * @param {String} exp
	 * @param {Boolean} needSet
	 * @return {Function}
	 */

	function parseExpression(exp, needSet) {
	  exp = exp.trim();
	  // try cache
	  var hit = expressionCache.get(exp);
	  if (hit) {
	    if (needSet && !hit.set) {
	      hit.set = compileSetter(hit.exp);
	    }
	    return hit;
	  }
	  var res = { exp: exp };
	  res.get = isSimplePath(exp) && exp.indexOf('[') < 0
	  // optimized super simple getter
	  ? makeGetterFn('scope.' + exp)
	  // dynamic getter
	  : compileGetter(exp);
	  if (needSet) {
	    res.set = compileSetter(exp);
	  }
	  expressionCache.put(exp, res);
	  return res;
	}

	/**
	 * Check if an expression is a simple path.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */

	function isSimplePath(exp) {
	  return pathTestRE.test(exp) &&
	  // don't treat true/false as paths
	  !booleanLiteralRE.test(exp) &&
	  // Math constants e.g. Math.PI, Math.E etc.
	  exp.slice(0, 5) !== 'Math.';
	}

	var expression = Object.freeze({
	  parseExpression: parseExpression,
	  isSimplePath: isSimplePath
	});

	// we have two separate queues: one for directive updates
	// and one for user watcher registered via $watch().
	// we want to guarantee directive updates to be called
	// before user watchers so that when user watchers are
	// triggered, the DOM would have already been in updated
	// state.
	var queue = [];
	var userQueue = [];
	var has = {};
	var circular = {};
	var waiting = false;
	var internalQueueDepleted = false;

	/**
	 * Reset the batcher's state.
	 */

	function resetBatcherState() {
	  queue = [];
	  userQueue = [];
	  has = {};
	  circular = {};
	  waiting = internalQueueDepleted = false;
	}

	/**
	 * Flush both queues and run the watchers.
	 */

	function flushBatcherQueue() {
	  runBatcherQueue(queue);
	  internalQueueDepleted = true;
	  runBatcherQueue(userQueue);
	  // dev tool hook
	  /* istanbul ignore if */
	  if (false) {
	    if (inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {
	      window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('flush');
	    }
	  }
	  resetBatcherState();
	}

	/**
	 * Run the watchers in a single queue.
	 *
	 * @param {Array} queue
	 */

	function runBatcherQueue(queue) {
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (var i = 0; i < queue.length; i++) {
	    var watcher = queue[i];
	    var id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (false) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > config._maxUpdateCount) {
	        queue.splice(has[id], 1);
	        warn('You may have an infinite update loop for watcher ' + 'with expression: ' + watcher.expression);
	      }
	    }
	  }
	}

	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 *
	 * @param {Watcher} watcher
	 *   properties:
	 *   - {Number} id
	 *   - {Function} run
	 */

	function pushWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    // if an internal watcher is pushed, but the internal
	    // queue is already depleted, we run it immediately.
	    if (internalQueueDepleted && !watcher.user) {
	      watcher.run();
	      return;
	    }
	    // push watcher into appropriate queue
	    var q = watcher.user ? userQueue : queue;
	    has[id] = q.length;
	    q.push(watcher);
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushBatcherQueue);
	    }
	  }
	}

	var uid$2 = 0;

	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 *
	 * @param {Vue} vm
	 * @param {String} expression
	 * @param {Function} cb
	 * @param {Object} options
	 *                 - {Array} filters
	 *                 - {Boolean} twoWay
	 *                 - {Boolean} deep
	 *                 - {Boolean} user
	 *                 - {Boolean} sync
	 *                 - {Boolean} lazy
	 *                 - {Function} [preProcess]
	 *                 - {Function} [postProcess]
	 * @constructor
	 */
	function Watcher(vm, expOrFn, cb, options) {
	  // mix in options
	  if (options) {
	    extend(this, options);
	  }
	  var isFn = typeof expOrFn === 'function';
	  this.vm = vm;
	  vm._watchers.push(this);
	  this.expression = isFn ? expOrFn.toString() : expOrFn;
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = Object.create(null);
	  this.newDeps = null;
	  this.prevError = null; // for async error stacks
	  // parse expression for getter/setter
	  if (isFn) {
	    this.getter = expOrFn;
	    this.setter = undefined;
	  } else {
	    var res = parseExpression(expOrFn, this.twoWay);
	    this.getter = res.get;
	    this.setter = res.set;
	  }
	  this.value = this.lazy ? undefined : this.get();
	  // state for avoiding false triggers for deep and Array
	  // watchers during vm._digest()
	  this.queued = this.shallow = false;
	}

	/**
	 * Add a dependency to this directive.
	 *
	 * @param {Dep} dep
	 */

	Watcher.prototype.addDep = function (dep) {
	  var id = dep.id;
	  if (!this.newDeps[id]) {
	    this.newDeps[id] = dep;
	    if (!this.deps[id]) {
	      this.deps[id] = dep;
	      dep.addSub(this);
	    }
	  }
	};

	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */

	Watcher.prototype.get = function () {
	  this.beforeGet();
	  var scope = this.scope || this.vm;
	  var value;
	  try {
	    value = this.getter.call(scope, scope);
	  } catch (e) {
	    if (false) {
	      warn('Error when evaluating expression "' + this.expression + '". ' + (config.debug ? '' : 'Turn on debug mode to see stack trace.'), e);
	    }
	  }
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  if (this.preProcess) {
	    value = this.preProcess(value);
	  }
	  if (this.filters) {
	    value = scope._applyFilters(value, null, this.filters, false);
	  }
	  if (this.postProcess) {
	    value = this.postProcess(value);
	  }
	  this.afterGet();
	  return value;
	};

	/**
	 * Set the corresponding value with the setter.
	 *
	 * @param {*} value
	 */

	Watcher.prototype.set = function (value) {
	  var scope = this.scope || this.vm;
	  if (this.filters) {
	    value = scope._applyFilters(value, this.value, this.filters, true);
	  }
	  try {
	    this.setter.call(scope, scope, value);
	  } catch (e) {
	    if (false) {
	      warn('Error when evaluating setter "' + this.expression + '"', e);
	    }
	  }
	  // two-way sync for v-for alias
	  var forContext = scope.$forContext;
	  if (forContext && forContext.alias === this.expression) {
	    if (forContext.filters) {
	      ("production") !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.');
	      return;
	    }
	    forContext._withLock(function () {
	      if (scope.$key) {
	        // original is an object
	        forContext.rawValue[scope.$key] = value;
	      } else {
	        forContext.rawValue.$set(scope.$index, value);
	      }
	    });
	  }
	};

	/**
	 * Prepare for dependency collection.
	 */

	Watcher.prototype.beforeGet = function () {
	  Dep.target = this;
	  this.newDeps = Object.create(null);
	};

	/**
	 * Clean up for dependency collection.
	 */

	Watcher.prototype.afterGet = function () {
	  Dep.target = null;
	  var ids = Object.keys(this.deps);
	  var i = ids.length;
	  while (i--) {
	    var id = ids[i];
	    if (!this.newDeps[id]) {
	      this.deps[id].removeSub(this);
	    }
	  }
	  this.deps = this.newDeps;
	};

	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 *
	 * @param {Boolean} shallow
	 */

	Watcher.prototype.update = function (shallow) {
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync || !config.async) {
	    this.run();
	  } else {
	    // if queued, only overwrite shallow with non-shallow,
	    // but not the other way around.
	    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
	    this.queued = true;
	    // record before-push error stack in debug mode
	    /* istanbul ignore if */
	    if (false) {
	      this.prevError = new Error('[vue] async stack trace');
	    }
	    pushWatcher(this);
	  }
	};

	/**
	 * Batcher job interface.
	 * Will be called by the batcher.
	 */

	Watcher.prototype.run = function () {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and Array watchers should fire even
	    // when the value is the same, because the value may
	    // have mutated; but only do so if this is a
	    // non-shallow update (caused by a vm digest).
	    (isArray(value) || this.deep) && !this.shallow) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      // in debug + async mode, when a watcher callbacks
	      // throws, we also throw the saved before-push error
	      // so the full cross-tick stack trace is available.
	      var prevError = this.prevError;
	      /* istanbul ignore if */
	      if (false) {
	        this.prevError = null;
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          nextTick(function () {
	            throw prevError;
	          }, 0);
	          throw e;
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	    this.queued = this.shallow = false;
	  }
	};

	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */

	Watcher.prototype.evaluate = function () {
	  // avoid overwriting another watcher that is being
	  // collected.
	  var current = Dep.target;
	  this.value = this.get();
	  this.dirty = false;
	  Dep.target = current;
	};

	/**
	 * Depend on all deps collected by this watcher.
	 */

	Watcher.prototype.depend = function () {
	  var depIds = Object.keys(this.deps);
	  var i = depIds.length;
	  while (i--) {
	    this.deps[depIds[i]].depend();
	  }
	};

	/**
	 * Remove self from all dependencies' subcriber list.
	 */

	Watcher.prototype.teardown = function () {
	  if (this.active) {
	    // remove self from vm's watcher list
	    // we can skip this if the vm if being destroyed
	    // which can improve teardown performance.
	    if (!this.vm._isBeingDestroyed) {
	      this.vm._watchers.$remove(this);
	    }
	    var depIds = Object.keys(this.deps);
	    var i = depIds.length;
	    while (i--) {
	      this.deps[depIds[i]].removeSub(this);
	    }
	    this.active = false;
	    this.vm = this.cb = this.value = null;
	  }
	};

	/**
	 * Recrusively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 *
	 * @param {*} val
	 */

	function traverse(val) {
	  var i, keys;
	  if (isArray(val)) {
	    i = val.length;
	    while (i--) traverse(val[i]);
	  } else if (isObject(val)) {
	    keys = Object.keys(val);
	    i = keys.length;
	    while (i--) traverse(val[keys[i]]);
	  }
	}

	var cloak = {
	  bind: function bind() {
	    var el = this.el;
	    this.vm.$once('hook:compiled', function () {
	      el.removeAttribute('v-cloak');
	    });
	  }
	};

	var ref = {
	  bind: function bind() {
	    ("production") !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.');
	  }
	};

	var el = {

	  priority: 1500,

	  bind: function bind() {
	    /* istanbul ignore if */
	    if (!this.arg) {
	      return;
	    }
	    var id = this.id = camelize(this.arg);
	    var refs = (this._scope || this.vm).$els;
	    if (hasOwn(refs, id)) {
	      refs[id] = this.el;
	    } else {
	      defineReactive(refs, id, this.el);
	    }
	  },

	  unbind: function unbind() {
	    var refs = (this._scope || this.vm).$els;
	    if (refs[this.id] === this.el) {
	      refs[this.id] = null;
	    }
	  }
	};

	var prefixes = ['-webkit-', '-moz-', '-ms-'];
	var camelPrefixes = ['Webkit', 'Moz', 'ms'];
	var importantRE = /!important;?$/;
	var propCache = Object.create(null);

	var testEl = null;

	var style = {

	  deep: true,

	  update: function update(value) {
	    if (typeof value === 'string') {
	      this.el.style.cssText = value;
	    } else if (isArray(value)) {
	      this.handleObject(value.reduce(extend, {}));
	    } else {
	      this.handleObject(value || {});
	    }
	  },

	  handleObject: function handleObject(value) {
	    // cache object styles so that only changed props
	    // are actually updated.
	    var cache = this.cache || (this.cache = {});
	    var name, val;
	    for (name in cache) {
	      if (!(name in value)) {
	        this.handleSingle(name, null);
	        delete cache[name];
	      }
	    }
	    for (name in value) {
	      val = value[name];
	      if (val !== cache[name]) {
	        cache[name] = val;
	        this.handleSingle(name, val);
	      }
	    }
	  },

	  handleSingle: function handleSingle(prop, value) {
	    prop = normalize(prop);
	    if (!prop) return; // unsupported prop
	    // cast possible numbers/booleans into strings
	    if (value != null) value += '';
	    if (value) {
	      var isImportant = importantRE.test(value) ? 'important' : '';
	      if (isImportant) {
	        value = value.replace(importantRE, '').trim();
	      }
	      this.el.style.setProperty(prop, value, isImportant);
	    } else {
	      this.el.style.removeProperty(prop);
	    }
	  }

	};

	/**
	 * Normalize a CSS property name.
	 * - cache result
	 * - auto prefix
	 * - camelCase -> dash-case
	 *
	 * @param {String} prop
	 * @return {String}
	 */

	function normalize(prop) {
	  if (propCache[prop]) {
	    return propCache[prop];
	  }
	  var res = prefix(prop);
	  propCache[prop] = propCache[res] = res;
	  return res;
	}

	/**
	 * Auto detect the appropriate prefix for a CSS property.
	 * https://gist.github.com/paulirish/523692
	 *
	 * @param {String} prop
	 * @return {String}
	 */

	function prefix(prop) {
	  prop = hyphenate(prop);
	  var camel = camelize(prop);
	  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
	  if (!testEl) {
	    testEl = document.createElement('div');
	  }
	  if (camel in testEl.style) {
	    return prop;
	  }
	  var i = prefixes.length;
	  var prefixed;
	  while (i--) {
	    prefixed = camelPrefixes[i] + upper;
	    if (prefixed in testEl.style) {
	      return prefixes[i] + prop;
	    }
	  }
	}

	// xlink
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	var xlinkRE = /^xlink:/;

	// these input element attributes should also set their
	// corresponding properties
	var inputProps = {
	  value: 1,
	  checked: 1,
	  selected: 1
	};

	// these attributes should set a hidden property for
	// binding v-model to object values
	var modelProps = {
	  value: '_value',
	  'true-value': '_trueValue',
	  'false-value': '_falseValue'
	};

	// check for attributes that prohibit interpolations
	var disallowedInterpAttrRE = /^v-|^:|^@|^(is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;

	var bind = {

	  priority: 850,

	  bind: function bind() {
	    var attr = this.arg;
	    var tag = this.el.tagName;
	    // should be deep watch on object mode
	    if (!attr) {
	      this.deep = true;
	    }
	    // handle interpolation bindings
	    if (this.descriptor.interp) {
	      // only allow binding on native attributes
	      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
	        ("production") !== 'production' && warn(attr + '="' + this.descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.');
	        this.el.removeAttribute(attr);
	        this.invalid = true;
	      }

	      /* istanbul ignore if */
	      if (false) {
	        var raw = attr + '="' + this.descriptor.raw + '": ';
	        // warn src
	        if (attr === 'src') {
	          warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.');
	        }

	        // warn style
	        if (attr === 'style') {
	          warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.');
	        }
	      }
	    }
	  },

	  update: function update(value) {
	    if (this.invalid) {
	      return;
	    }
	    var attr = this.arg;
	    if (this.arg) {
	      this.handleSingle(attr, value);
	    } else {
	      this.handleObject(value || {});
	    }
	  },

	  // share object handler with v-bind:class
	  handleObject: style.handleObject,

	  handleSingle: function handleSingle(attr, value) {
	    if (inputProps[attr] && attr in this.el) {
	      this.el[attr] = attr === 'value' ? value || '' : // IE9 will set input.value to "null" for null...
	      value;
	    }
	    // set model props
	    var modelProp = modelProps[attr];
	    if (modelProp) {
	      this.el[modelProp] = value;
	      // update v-model if present
	      var model = this.el.__v_model;
	      if (model) {
	        model.listener();
	      }
	    }
	    // do not set value attribute for textarea
	    if (attr === 'value' && this.el.tagName === 'TEXTAREA') {
	      this.el.removeAttribute(attr);
	      return;
	    }
	    // update attribute
	    if (value != null && value !== false) {
	      if (xlinkRE.test(attr)) {
	        this.el.setAttributeNS(xlinkNS, attr, value);
	      } else {
	        this.el.setAttribute(attr, value);
	      }
	    } else {
	      this.el.removeAttribute(attr);
	    }
	  }
	};

	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  'delete': 46,
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40
	};

	function keyFilter(handler, keys) {
	  var codes = keys.map(function (key) {
	    var charCode = key.charCodeAt(0);
	    if (charCode > 47 && charCode < 58) {
	      return parseInt(key, 10);
	    }
	    if (key.length === 1) {
	      charCode = key.toUpperCase().charCodeAt(0);
	      if (charCode > 64 && charCode < 91) {
	        return charCode;
	      }
	    }
	    return keyCodes[key];
	  });
	  return function keyHandler(e) {
	    if (codes.indexOf(e.keyCode) > -1) {
	      return handler.call(this, e);
	    }
	  };
	}

	function stopFilter(handler) {
	  return function stopHandler(e) {
	    e.stopPropagation();
	    return handler.call(this, e);
	  };
	}

	function preventFilter(handler) {
	  return function preventHandler(e) {
	    e.preventDefault();
	    return handler.call(this, e);
	  };
	}

	var on = {

	  acceptStatement: true,
	  priority: 700,

	  bind: function bind() {
	    // deal with iframes
	    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
	      var self = this;
	      this.iframeBind = function () {
	        on$1(self.el.contentWindow, self.arg, self.handler);
	      };
	      this.on('load', this.iframeBind);
	    }
	  },

	  update: function update(handler) {
	    // stub a noop for v-on with no value,
	    // e.g. @mousedown.prevent
	    if (!this.descriptor.raw) {
	      handler = function () {};
	    }

	    if (typeof handler !== 'function') {
	      ("production") !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler);
	      return;
	    }

	    // apply modifiers
	    if (this.modifiers.stop) {
	      handler = stopFilter(handler);
	    }
	    if (this.modifiers.prevent) {
	      handler = preventFilter(handler);
	    }
	    // key filter
	    var keys = Object.keys(this.modifiers).filter(function (key) {
	      return key !== 'stop' && key !== 'prevent';
	    });
	    if (keys.length) {
	      handler = keyFilter(handler, keys);
	    }

	    this.reset();
	    this.handler = handler;

	    if (this.iframeBind) {
	      this.iframeBind();
	    } else {
	      on$1(this.el, this.arg, this.handler);
	    }
	  },

	  reset: function reset() {
	    var el = this.iframeBind ? this.el.contentWindow : this.el;
	    if (this.handler) {
	      off(el, this.arg, this.handler);
	    }
	  },

	  unbind: function unbind() {
	    this.reset();
	  }
	};

	var checkbox = {

	  bind: function bind() {
	    var self = this;
	    var el = this.el;

	    this.getValue = function () {
	      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
	    };

	    function getBooleanValue() {
	      var val = el.checked;
	      if (val && el.hasOwnProperty('_trueValue')) {
	        return el._trueValue;
	      }
	      if (!val && el.hasOwnProperty('_falseValue')) {
	        return el._falseValue;
	      }
	      return val;
	    }

	    this.listener = function () {
	      var model = self._watcher.value;
	      if (isArray(model)) {
	        var val = self.getValue();
	        if (el.checked) {
	          if (indexOf(model, val) < 0) {
	            model.push(val);
	          }
	        } else {
	          model.$remove(val);
	        }
	      } else {
	        self.set(getBooleanValue());
	      }
	    };

	    this.on('change', this.listener);
	    if (el.checked) {
	      this.afterBind = this.listener;
	    }
	  },

	  update: function update(value) {
	    var el = this.el;
	    if (isArray(value)) {
	      el.checked = indexOf(value, this.getValue()) > -1;
	    } else {
	      if (el.hasOwnProperty('_trueValue')) {
	        el.checked = looseEqual(value, el._trueValue);
	      } else {
	        el.checked = !!value;
	      }
	    }
	  }
	};

	var select = {

	  bind: function bind() {
	    var self = this;
	    var el = this.el;

	    // method to force update DOM using latest value.
	    this.forceUpdate = function () {
	      if (self._watcher) {
	        self.update(self._watcher.get());
	      }
	    };

	    // check if this is a multiple select
	    var multiple = this.multiple = el.hasAttribute('multiple');

	    // attach listener
	    this.listener = function () {
	      var value = getValue(el, multiple);
	      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
	      self.set(value);
	    };
	    this.on('change', this.listener);

	    // if has initial value, set afterBind
	    var initValue = getValue(el, multiple, true);
	    if (multiple && initValue.length || !multiple && initValue !== null) {
	      this.afterBind = this.listener;
	    }

	    // All major browsers except Firefox resets
	    // selectedIndex with value -1 to 0 when the element
	    // is appended to a new parent, therefore we have to
	    // force a DOM update whenever that happens...
	    this.vm.$on('hook:attached', this.forceUpdate);
	  },

	  update: function update(value) {
	    var el = this.el;
	    el.selectedIndex = -1;
	    var multi = this.multiple && isArray(value);
	    var options = el.options;
	    var i = options.length;
	    var op, val;
	    while (i--) {
	      op = options[i];
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      /* eslint-disable eqeqeq */
	      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
	      /* eslint-enable eqeqeq */
	    }
	  },

	  unbind: function unbind() {
	    /* istanbul ignore next */
	    this.vm.$off('hook:attached', this.forceUpdate);
	  }
	};

	/**
	 * Get select value
	 *
	 * @param {SelectElement} el
	 * @param {Boolean} multi
	 * @param {Boolean} init
	 * @return {Array|*}
	 */

	function getValue(el, multi, init) {
	  var res = multi ? [] : null;
	  var op, val, selected;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    op = el.options[i];
	    selected = init ? op.hasAttribute('selected') : op.selected;
	    if (selected) {
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      if (multi) {
	        res.push(val);
	      } else {
	        return val;
	      }
	    }
	  }
	  return res;
	}

	/**
	 * Native Array.indexOf uses strict equal, but in this
	 * case we need to match string/numbers with custom equal.
	 *
	 * @param {Array} arr
	 * @param {*} val
	 */

	function indexOf$1(arr, val) {
	  var i = arr.length;
	  while (i--) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}

	var radio = {

	  bind: function bind() {
	    var self = this;
	    var el = this.el;

	    this.getValue = function () {
	      // value overwrite via v-bind:value
	      if (el.hasOwnProperty('_value')) {
	        return el._value;
	      }
	      var val = el.value;
	      if (self.params.number) {
	        val = toNumber(val);
	      }
	      return val;
	    };

	    this.listener = function () {
	      self.set(self.getValue());
	    };
	    this.on('change', this.listener);

	    if (el.checked) {
	      this.afterBind = this.listener;
	    }
	  },

	  update: function update(value) {
	    this.el.checked = looseEqual(value, this.getValue());
	  }
	};

	var text$2 = {

	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	    var isRange = el.type === 'range';
	    var lazy = this.params.lazy;
	    var number = this.params.number;
	    var debounce = this.params.debounce;

	    // handle composition events.
	    //   http://blog.evanyou.me/2014/01/03/composition-event/
	    // skip this for Android because it handles composition
	    // events quite differently. Android doesn't trigger
	    // composition events for language input methods e.g.
	    // Chinese, but instead triggers them for spelling
	    // suggestions... (see Discussion/#162)
	    var composing = false;
	    if (!isAndroid && !isRange) {
	      this.on('compositionstart', function () {
	        composing = true;
	      });
	      this.on('compositionend', function () {
	        composing = false;
	        // in IE11 the "compositionend" event fires AFTER
	        // the "input" event, so the input handler is blocked
	        // at the end... have to call it here.
	        //
	        // #1327: in lazy mode this is unecessary.
	        if (!lazy) {
	          self.listener();
	        }
	      });
	    }

	    // prevent messing with the input when user is typing,
	    // and force update on blur.
	    this.focused = false;
	    if (!isRange) {
	      this.on('focus', function () {
	        self.focused = true;
	      });
	      this.on('blur', function () {
	        self.focused = false;
	        self.listener();
	      });
	    }

	    // Now attach the main listener
	    this.listener = function () {
	      if (composing) return;
	      var val = number || isRange ? toNumber(el.value) : el.value;
	      self.set(val);
	      // force update on next tick to avoid lock & same value
	      // also only update when user is not typing
	      nextTick(function () {
	        if (self._bound && !self.focused) {
	          self.update(self._watcher.value);
	        }
	      });
	    };

	    // apply debounce
	    if (debounce) {
	      this.listener = _debounce(this.listener, debounce);
	    }

	    // Support jQuery events, since jQuery.trigger() doesn't
	    // trigger native events in some cases and some plugins
	    // rely on $.trigger()
	    //
	    // We want to make sure if a listener is attached using
	    // jQuery, it is also removed with jQuery, that's why
	    // we do the check for each directive instance and
	    // store that check result on itself. This also allows
	    // easier test coverage control by unsetting the global
	    // jQuery variable in tests.
	    this.hasjQuery = typeof jQuery === 'function';
	    if (this.hasjQuery) {
	      jQuery(el).on('change', this.listener);
	      if (!lazy) {
	        jQuery(el).on('input', this.listener);
	      }
	    } else {
	      this.on('change', this.listener);
	      if (!lazy) {
	        this.on('input', this.listener);
	      }
	    }

	    // IE9 doesn't fire input event on backspace/del/cut
	    if (!lazy && isIE9) {
	      this.on('cut', function () {
	        nextTick(self.listener);
	      });
	      this.on('keyup', function (e) {
	        if (e.keyCode === 46 || e.keyCode === 8) {
	          self.listener();
	        }
	      });
	    }

	    // set initial value if present
	    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
	      this.afterBind = this.listener;
	    }
	  },

	  update: function update(value) {
	    this.el.value = _toString(value);
	  },

	  unbind: function unbind() {
	    var el = this.el;
	    if (this.hasjQuery) {
	      jQuery(el).off('change', this.listener);
	      jQuery(el).off('input', this.listener);
	    }
	  }
	};

	var handlers = {
	  text: text$2,
	  radio: radio,
	  select: select,
	  checkbox: checkbox
	};

	var model = {

	  priority: 800,
	  twoWay: true,
	  handlers: handlers,
	  params: ['lazy', 'number', 'debounce'],

	  /**
	   * Possible elements:
	   *   <select>
	   *   <textarea>
	   *   <input type="*">
	   *     - text
	   *     - checkbox
	   *     - radio
	   *     - number
	   */

	  bind: function bind() {
	    // friendly warning...
	    this.checkFilters();
	    if (this.hasRead && !this.hasWrite) {
	      ("production") !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model. You might want to use a two-way filter ' + 'to ensure correct behavior.');
	    }
	    var el = this.el;
	    var tag = el.tagName;
	    var handler;
	    if (tag === 'INPUT') {
	      handler = handlers[el.type] || handlers.text;
	    } else if (tag === 'SELECT') {
	      handler = handlers.select;
	    } else if (tag === 'TEXTAREA') {
	      handler = handlers.text;
	    } else {
	      ("production") !== 'production' && warn('v-model does not support element type: ' + tag);
	      return;
	    }
	    el.__v_model = this;
	    handler.bind.call(this);
	    this.update = handler.update;
	    this._unbind = handler.unbind;
	  },

	  /**
	   * Check read/write filter stats.
	   */

	  checkFilters: function checkFilters() {
	    var filters = this.filters;
	    if (!filters) return;
	    var i = filters.length;
	    while (i--) {
	      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
	      if (typeof filter === 'function' || filter.read) {
	        this.hasRead = true;
	      }
	      if (filter.write) {
	        this.hasWrite = true;
	      }
	    }
	  },

	  unbind: function unbind() {
	    this.el.__v_model = null;
	    this._unbind && this._unbind();
	  }
	};

	var show = {

	  bind: function bind() {
	    // check else block
	    var next = this.el.nextElementSibling;
	    if (next && getAttr(next, 'v-else') !== null) {
	      this.elseEl = next;
	    }
	  },

	  update: function update(value) {
	    this.apply(this.el, value);
	    if (this.elseEl) {
	      this.apply(this.elseEl, !value);
	    }
	  },

	  apply: function apply(el, value) {
	    applyTransition(el, value ? 1 : -1, function () {
	      el.style.display = value ? '' : 'none';
	    }, this.vm);
	  }
	};

	var templateCache = new Cache(1000);
	var idSelectorCache = new Cache(1000);

	var map = {
	  efault: [0, '', ''],
	  legend: [1, '<fieldset>', '</fieldset>'],
	  tr: [2, '<table><tbody>', '</tbody></table>'],
	  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
	};

	map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

	map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];

	map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];

	map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];

	/**
	 * Check if a node is a supported template node with a
	 * DocumentFragment content.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */

	function isRealTemplate(node) {
	  return isTemplate(node) && node.content instanceof DocumentFragment;
	}

	var tagRE$1 = /<([\w:]+)/;
	var entityRE = /&\w+;|&#\d+;|&#x[\dA-F]+;/;

	/**
	 * Convert a string template to a DocumentFragment.
	 * Determines correct wrapping by tag types. Wrapping
	 * strategy found in jQuery & component/domify.
	 *
	 * @param {String} templateString
	 * @param {Boolean} raw
	 * @return {DocumentFragment}
	 */

	function stringToFragment(templateString, raw) {
	  // try a cache hit first
	  var hit = templateCache.get(templateString);
	  if (hit) {
	    return hit;
	  }

	  var frag = document.createDocumentFragment();
	  var tagMatch = templateString.match(tagRE$1);
	  var entityMatch = entityRE.test(templateString);

	  if (!tagMatch && !entityMatch) {
	    // text only, return a single text node.
	    frag.appendChild(document.createTextNode(templateString));
	  } else {

	    var tag = tagMatch && tagMatch[1];
	    var wrap = map[tag] || map.efault;
	    var depth = wrap[0];
	    var prefix = wrap[1];
	    var suffix = wrap[2];
	    var node = document.createElement('div');

	    if (!raw) {
	      templateString = templateString.trim();
	    }
	    node.innerHTML = prefix + templateString + suffix;
	    while (depth--) {
	      node = node.lastChild;
	    }

	    var child;
	    /* eslint-disable no-cond-assign */
	    while (child = node.firstChild) {
	      /* eslint-enable no-cond-assign */
	      frag.appendChild(child);
	    }
	  }

	  templateCache.put(templateString, frag);
	  return frag;
	}

	/**
	 * Convert a template node to a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {DocumentFragment}
	 */

	function nodeToFragment(node) {
	  // if its a template tag and the browser supports it,
	  // its content is already a document fragment.
	  if (isRealTemplate(node)) {
	    trimNode(node.content);
	    return node.content;
	  }
	  // script template
	  if (node.tagName === 'SCRIPT') {
	    return stringToFragment(node.textContent);
	  }
	  // normal node, clone it to avoid mutating the original
	  var clonedNode = cloneNode(node);
	  var frag = document.createDocumentFragment();
	  var child;
	  /* eslint-disable no-cond-assign */
	  while (child = clonedNode.firstChild) {
	    /* eslint-enable no-cond-assign */
	    frag.appendChild(child);
	  }
	  trimNode(frag);
	  return frag;
	}

	// Test for the presence of the Safari template cloning bug
	// https://bugs.webkit.org/showug.cgi?id=137755
	var hasBrokenTemplate = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var a = document.createElement('div');
	    a.innerHTML = '<template>1</template>';
	    return !a.cloneNode(true).firstChild.innerHTML;
	  } else {
	    return false;
	  }
	})();

	// Test for IE10/11 textarea placeholder clone bug
	var hasTextareaCloneBug = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var t = document.createElement('textarea');
	    t.placeholder = 't';
	    return t.cloneNode(true).value === 't';
	  } else {
	    return false;
	  }
	})();

	/**
	 * 1. Deal with Safari cloning nested <template> bug by
	 *    manually cloning all template instances.
	 * 2. Deal with IE10/11 textarea placeholder bug by setting
	 *    the correct value after cloning.
	 *
	 * @param {Element|DocumentFragment} node
	 * @return {Element|DocumentFragment}
	 */

	function cloneNode(node) {
	  if (!node.querySelectorAll) {
	    return node.cloneNode();
	  }
	  var res = node.cloneNode(true);
	  var i, original, cloned;
	  /* istanbul ignore if */
	  if (hasBrokenTemplate) {
	    var tempClone = res;
	    if (isRealTemplate(node)) {
	      node = node.content;
	      tempClone = res.content;
	    }
	    original = node.querySelectorAll('template');
	    if (original.length) {
	      cloned = tempClone.querySelectorAll('template');
	      i = cloned.length;
	      while (i--) {
	        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
	      }
	    }
	  }
	  /* istanbul ignore if */
	  if (hasTextareaCloneBug) {
	    if (node.tagName === 'TEXTAREA') {
	      res.value = node.value;
	    } else {
	      original = node.querySelectorAll('textarea');
	      if (original.length) {
	        cloned = res.querySelectorAll('textarea');
	        i = cloned.length;
	        while (i--) {
	          cloned[i].value = original[i].value;
	        }
	      }
	    }
	  }
	  return res;
	}

	/**
	 * Process the template option and normalizes it into a
	 * a DocumentFragment that can be used as a partial or a
	 * instance template.
	 *
	 * @param {*} template
	 *        Possible values include:
	 *        - DocumentFragment object
	 *        - Node object of type Template
	 *        - id selector: '#some-template-id'
	 *        - template string: '<div><span>{{msg}}</span></div>'
	 * @param {Boolean} shouldClone
	 * @param {Boolean} raw
	 *        inline HTML interpolation. Do not check for id
	 *        selector and keep whitespace in the string.
	 * @return {DocumentFragment|undefined}
	 */

	function parseTemplate(template, shouldClone, raw) {
	  var node, frag;

	  // if the template is already a document fragment,
	  // do nothing
	  if (template instanceof DocumentFragment) {
	    trimNode(template);
	    return shouldClone ? cloneNode(template) : template;
	  }

	  if (typeof template === 'string') {
	    // id selector
	    if (!raw && template.charAt(0) === '#') {
	      // id selector can be cached too
	      frag = idSelectorCache.get(template);
	      if (!frag) {
	        node = document.getElementById(template.slice(1));
	        if (node) {
	          frag = nodeToFragment(node);
	          // save selector to cache
	          idSelectorCache.put(template, frag);
	        }
	      }
	    } else {
	      // normal string template
	      frag = stringToFragment(template, raw);
	    }
	  } else if (template.nodeType) {
	    // a direct node
	    frag = nodeToFragment(template);
	  }

	  return frag && shouldClone ? cloneNode(frag) : frag;
	}

	var template = Object.freeze({
	  cloneNode: cloneNode,
	  parseTemplate: parseTemplate
	});

	/**
	 * Abstraction for a partially-compiled fragment.
	 * Can optionally compile content with a child scope.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Vue} [host]
	 * @param {Object} [scope]
	 */
	function Fragment(linker, vm, frag, host, scope, parentFrag) {
	  this.children = [];
	  this.childFrags = [];
	  this.vm = vm;
	  this.scope = scope;
	  this.inserted = false;
	  this.parentFrag = parentFrag;
	  if (parentFrag) {
	    parentFrag.childFrags.push(this);
	  }
	  this.unlink = linker(vm, frag, host, scope, this);
	  var single = this.single = frag.childNodes.length === 1 &&
	  // do not go single mode if the only node is an anchor
	  !frag.childNodes[0].__vue_anchor;
	  if (single) {
	    this.node = frag.childNodes[0];
	    this.before = singleBefore;
	    this.remove = singleRemove;
	  } else {
	    this.node = createAnchor('fragment-start');
	    this.end = createAnchor('fragment-end');
	    this.frag = frag;
	    prepend(this.node, frag);
	    frag.appendChild(this.end);
	    this.before = multiBefore;
	    this.remove = multiRemove;
	  }
	  this.node.__vfrag__ = this;
	}

	/**
	 * Call attach/detach for all components contained within
	 * this fragment. Also do so recursively for all child
	 * fragments.
	 *
	 * @param {Function} hook
	 */

	Fragment.prototype.callHook = function (hook) {
	  var i, l;
	  for (i = 0, l = this.children.length; i < l; i++) {
	    hook(this.children[i]);
	  }
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    this.childFrags[i].callHook(hook);
	  }
	};

	/**
	 * Destroy the fragment.
	 */

	Fragment.prototype.destroy = function () {
	  if (this.parentFrag) {
	    this.parentFrag.childFrags.$remove(this);
	  }
	  this.unlink();
	};

	/**
	 * Insert fragment before target, single node version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */

	function singleBefore(target, withTransition) {
	  this.inserted = true;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  method(this.node, target, this.vm);
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}

	/**
	 * Remove fragment, single node version
	 */

	function singleRemove() {
	  this.inserted = false;
	  var shouldCallRemove = inDoc(this.node);
	  var self = this;
	  self.callHook(destroyChild);
	  removeWithTransition(this.node, this.vm, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}

	/**
	 * Insert fragment before target, multi-nodes version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */

	function multiBefore(target, withTransition) {
	  this.inserted = true;
	  var vm = this.vm;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  mapNodeRange(this.node, this.end, function (node) {
	    method(node, target, vm);
	  });
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}

	/**
	 * Remove fragment, multi-nodes version
	 */

	function multiRemove() {
	  this.inserted = false;
	  var self = this;
	  var shouldCallRemove = inDoc(this.node);
	  self.callHook(destroyChild);
	  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}

	/**
	 * Call attach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */

	function attach(child) {
	  if (!child._isAttached) {
	    child._callHook('attached');
	  }
	}

	/**
	 * Call destroy for all contained instances,
	 * with remove:false and defer:true.
	 * Defer is necessary because we need to
	 * keep the children to call detach hooks
	 * on them.
	 *
	 * @param {Vue} child
	 */

	function destroyChild(child) {
	  child.$destroy(false, true);
	}

	/**
	 * Call detach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */

	function detach(child) {
	  if (child._isAttached) {
	    child._callHook('detached');
	  }
	}

	var linkerCache = new Cache(5000);

	/**
	 * A factory that can be used to create instances of a
	 * fragment. Caches the compiled linker if possible.
	 *
	 * @param {Vue} vm
	 * @param {Element|String} el
	 */
	function FragmentFactory(vm, el) {
	  this.vm = vm;
	  var template;
	  var isString = typeof el === 'string';
	  if (isString || isTemplate(el)) {
	    template = parseTemplate(el, true);
	  } else {
	    template = document.createDocumentFragment();
	    template.appendChild(el);
	  }
	  this.template = template;
	  // linker can be cached, but only for components
	  var linker;
	  var cid = vm.constructor.cid;
	  if (cid > 0) {
	    var cacheId = cid + (isString ? el : el.outerHTML);
	    linker = linkerCache.get(cacheId);
	    if (!linker) {
	      linker = compile(template, vm.$options, true);
	      linkerCache.put(cacheId, linker);
	    }
	  } else {
	    linker = compile(template, vm.$options, true);
	  }
	  this.linker = linker;
	}

	/**
	 * Create a fragment instance with given host and scope.
	 *
	 * @param {Vue} host
	 * @param {Object} scope
	 * @param {Fragment} parentFrag
	 */

	FragmentFactory.prototype.create = function (host, scope, parentFrag) {
	  var frag = cloneNode(this.template);
	  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
	};

	var vIf = {

	  priority: 2000,

	  bind: function bind() {
	    var el = this.el;
	    if (!el.__vue__) {
	      // check else block
	      var next = el.nextElementSibling;
	      if (next && getAttr(next, 'v-else') !== null) {
	        remove(next);
	        this.elseFactory = new FragmentFactory(this.vm, next);
	      }
	      // check main block
	      this.anchor = createAnchor('v-if');
	      replace(el, this.anchor);
	      this.factory = new FragmentFactory(this.vm, el);
	    } else {
	      ("production") !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.');
	      this.invalid = true;
	    }
	  },

	  update: function update(value) {
	    if (this.invalid) return;
	    if (value) {
	      if (!this.frag) {
	        this.insert();
	      }
	    } else {
	      this.remove();
	    }
	  },

	  insert: function insert() {
	    if (this.elseFrag) {
	      this.elseFrag.remove();
	      this.elseFrag = null;
	    }
	    this.frag = this.factory.create(this._host, this._scope, this._frag);
	    this.frag.before(this.anchor);
	  },

	  remove: function remove() {
	    if (this.frag) {
	      this.frag.remove();
	      this.frag = null;
	    }
	    if (this.elseFactory && !this.elseFrag) {
	      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
	      this.elseFrag.before(this.anchor);
	    }
	  },

	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	  }
	};

	var uid$1 = 0;

	var vFor = {

	  priority: 2000,

	  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],

	  bind: function bind() {
	    // support "item in items" syntax
	    var inMatch = this.expression.match(/(.*) in (.*)/);
	    if (inMatch) {
	      var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
	      if (itMatch) {
	        this.iterator = itMatch[1].trim();
	        this.alias = itMatch[2].trim();
	      } else {
	        this.alias = inMatch[1].trim();
	      }
	      this.expression = inMatch[2];
	    }

	    if (!this.alias) {
	      ("production") !== 'production' && warn('Alias is required in v-for.');
	      return;
	    }

	    // uid as a cache identifier
	    this.id = '__v-for__' + ++uid$1;

	    // check if this is an option list,
	    // so that we know if we need to update the <select>'s
	    // v-model when the option list has changed.
	    // because v-model has a lower priority than v-for,
	    // the v-model is not bound here yet, so we have to
	    // retrive it in the actual updateModel() function.
	    var tag = this.el.tagName;
	    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';

	    // setup anchor nodes
	    this.start = createAnchor('v-for-start');
	    this.end = createAnchor('v-for-end');
	    replace(this.el, this.end);
	    before(this.start, this.end);

	    // cache
	    this.cache = Object.create(null);

	    // fragment factory
	    this.factory = new FragmentFactory(this.vm, this.el);
	  },

	  update: function update(data) {
	    this.diff(data);
	    this.updateRef();
	    this.updateModel();
	  },

	  /**
	   * Diff, based on new data and old data, determine the
	   * minimum amount of DOM manipulations needed to make the
	   * DOM reflect the new data Array.
	   *
	   * The algorithm diffs the new data Array by storing a
	   * hidden reference to an owner vm instance on previously
	   * seen data. This allows us to achieve O(n) which is
	   * better than a levenshtein distance based algorithm,
	   * which is O(m * n).
	   *
	   * @param {Array} data
	   */

	  diff: function diff(data) {
	    // check if the Array was converted from an Object
	    var item = data[0];
	    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');

	    var trackByKey = this.params.trackBy;
	    var oldFrags = this.frags;
	    var frags = this.frags = new Array(data.length);
	    var alias = this.alias;
	    var iterator = this.iterator;
	    var start = this.start;
	    var end = this.end;
	    var inDocument = inDoc(start);
	    var init = !oldFrags;
	    var i, l, frag, key, value, primitive;

	    // First pass, go through the new Array and fill up
	    // the new frags array. If a piece of data has a cached
	    // instance for it, we reuse it. Otherwise build a new
	    // instance.
	    for (i = 0, l = data.length; i < l; i++) {
	      item = data[i];
	      key = convertedFromObject ? item.$key : null;
	      value = convertedFromObject ? item.$value : item;
	      primitive = !isObject(value);
	      frag = !init && this.getCachedFrag(value, i, key);
	      if (frag) {
	        // reusable fragment
	        frag.reused = true;
	        // update $index
	        frag.scope.$index = i;
	        // update $key
	        if (key) {
	          frag.scope.$key = key;
	        }
	        // update iterator
	        if (iterator) {
	          frag.scope[iterator] = key !== null ? key : i;
	        }
	        // update data for track-by, object repeat &
	        // primitive values.
	        if (trackByKey || convertedFromObject || primitive) {
	          frag.scope[alias] = value;
	        }
	      } else {
	        // new isntance
	        frag = this.create(value, alias, i, key);
	        frag.fresh = !init;
	      }
	      frags[i] = frag;
	      if (init) {
	        frag.before(end);
	      }
	    }

	    // we're done for the initial render.
	    if (init) {
	      return;
	    }

	    // Second pass, go through the old fragments and
	    // destroy those who are not reused (and remove them
	    // from cache)
	    var removalIndex = 0;
	    var totalRemoved = oldFrags.length - frags.length;
	    for (i = 0, l = oldFrags.length; i < l; i++) {
	      frag = oldFrags[i];
	      if (!frag.reused) {
	        this.deleteCachedFrag(frag);
	        this.remove(frag, removalIndex++, totalRemoved, inDocument);
	      }
	    }

	    // Final pass, move/insert new fragments into the
	    // right place.
	    var targetPrev, prevEl, currentPrev;
	    var insertionIndex = 0;
	    for (i = 0, l = frags.length; i < l; i++) {
	      frag = frags[i];
	      // this is the frag that we should be after
	      targetPrev = frags[i - 1];
	      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
	      if (frag.reused && !frag.staggerCb) {
	        currentPrev = findPrevFrag(frag, start, this.id);
	        if (currentPrev !== targetPrev && (!currentPrev ||
	        // optimization for moving a single item.
	        // thanks to suggestions by @livoras in #1807
	        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
	          this.move(frag, prevEl);
	        }
	      } else {
	        // new instance, or still in stagger.
	        // insert with updated stagger index.
	        this.insert(frag, insertionIndex++, prevEl, inDocument);
	      }
	      frag.reused = frag.fresh = false;
	    }
	  },

	  /**
	   * Create a new fragment instance.
	   *
	   * @param {*} value
	   * @param {String} alias
	   * @param {Number} index
	   * @param {String} [key]
	   * @return {Fragment}
	   */

	  create: function create(value, alias, index, key) {
	    var host = this._host;
	    // create iteration scope
	    var parentScope = this._scope || this.vm;
	    var scope = Object.create(parentScope);
	    // ref holder for the scope
	    scope.$refs = Object.create(parentScope.$refs);
	    scope.$els = Object.create(parentScope.$els);
	    // make sure point $parent to parent scope
	    scope.$parent = parentScope;
	    // for two-way binding on alias
	    scope.$forContext = this;
	    // define scope properties
	    defineReactive(scope, alias, value);
	    defineReactive(scope, '$index', index);
	    if (key) {
	      defineReactive(scope, '$key', key);
	    } else if (scope.$key) {
	      // avoid accidental fallback
	      def(scope, '$key', null);
	    }
	    if (this.iterator) {
	      defineReactive(scope, this.iterator, key !== null ? key : index);
	    }
	    var frag = this.factory.create(host, scope, this._frag);
	    frag.forId = this.id;
	    this.cacheFrag(value, frag, index, key);
	    return frag;
	  },

	  /**
	   * Update the v-ref on owner vm.
	   */

	  updateRef: function updateRef() {
	    var ref = this.descriptor.ref;
	    if (!ref) return;
	    var hash = (this._scope || this.vm).$refs;
	    var refs;
	    if (!this.fromObject) {
	      refs = this.frags.map(findVmFromFrag);
	    } else {
	      refs = {};
	      this.frags.forEach(function (frag) {
	        refs[frag.scope.$key] = findVmFromFrag(frag);
	      });
	    }
	    hash[ref] = refs;
	  },

	  /**
	   * For option lists, update the containing v-model on
	   * parent <select>.
	   */

	  updateModel: function updateModel() {
	    if (this.isOption) {
	      var parent = this.start.parentNode;
	      var model = parent && parent.__v_model;
	      if (model) {
	        model.forceUpdate();
	      }
	    }
	  },

	  /**
	   * Insert a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Node} prevEl
	   * @param {Boolean} inDocument
	   */

	  insert: function insert(frag, index, prevEl, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	    }
	    var staggerAmount = this.getStagger(frag, index, null, 'enter');
	    if (inDocument && staggerAmount) {
	      // create an anchor and insert it synchronously,
	      // so that we can resolve the correct order without
	      // worrying about some elements not inserted yet
	      var anchor = frag.staggerAnchor;
	      if (!anchor) {
	        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
	        anchor.__vfrag__ = frag;
	      }
	      after(anchor, prevEl);
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.before(anchor);
	        remove(anchor);
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      frag.before(prevEl.nextSibling);
	    }
	  },

	  /**
	   * Remove a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {Boolean} inDocument
	   */

	  remove: function remove(frag, index, total, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	      // it's not possible for the same frag to be removed
	      // twice, so if we have a pending stagger callback,
	      // it means this frag is queued for enter but removed
	      // before its transition started. Since it is already
	      // destroyed, we can just leave it in detached state.
	      return;
	    }
	    var staggerAmount = this.getStagger(frag, index, total, 'leave');
	    if (inDocument && staggerAmount) {
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.remove();
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      frag.remove();
	    }
	  },

	  /**
	   * Move a fragment to a new position.
	   * Force no transition.
	   *
	   * @param {Fragment} frag
	   * @param {Node} prevEl
	   */

	  move: function move(frag, prevEl) {
	    frag.before(prevEl.nextSibling, false);
	  },

	  /**
	   * Cache a fragment using track-by or the object key.
	   *
	   * @param {*} value
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {String} [key]
	   */

	  cacheFrag: function cacheFrag(value, frag, index, key) {
	    var trackByKey = this.params.trackBy;
	    var cache = this.cache;
	    var primitive = !isObject(value);
	    var id;
	    if (key || trackByKey || primitive) {
	      id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
	      if (!cache[id]) {
	        cache[id] = frag;
	      } else if (trackByKey !== '$index') {
	        ("production") !== 'production' && this.warnDuplicate(value);
	      }
	    } else {
	      id = this.id;
	      if (hasOwn(value, id)) {
	        if (value[id] === null) {
	          value[id] = frag;
	        } else {
	          ("production") !== 'production' && this.warnDuplicate(value);
	        }
	      } else {
	        def(value, id, frag);
	      }
	    }
	    frag.raw = value;
	  },

	  /**
	   * Get a cached fragment from the value/index/key
	   *
	   * @param {*} value
	   * @param {Number} index
	   * @param {String} key
	   * @return {Fragment}
	   */

	  getCachedFrag: function getCachedFrag(value, index, key) {
	    var trackByKey = this.params.trackBy;
	    var primitive = !isObject(value);
	    var frag;
	    if (key || trackByKey || primitive) {
	      var id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
	      frag = this.cache[id];
	    } else {
	      frag = value[this.id];
	    }
	    if (frag && (frag.reused || frag.fresh)) {
	      ("production") !== 'production' && this.warnDuplicate(value);
	    }
	    return frag;
	  },

	  /**
	   * Delete a fragment from cache.
	   *
	   * @param {Fragment} frag
	   */

	  deleteCachedFrag: function deleteCachedFrag(frag) {
	    var value = frag.raw;
	    var trackByKey = this.params.trackBy;
	    var scope = frag.scope;
	    var index = scope.$index;
	    // fix #948: avoid accidentally fall through to
	    // a parent repeater which happens to have $key.
	    var key = hasOwn(scope, '$key') && scope.$key;
	    var primitive = !isObject(value);
	    if (trackByKey || key || primitive) {
	      var id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
	      this.cache[id] = null;
	    } else {
	      value[this.id] = null;
	      frag.raw = null;
	    }
	  },

	  /**
	   * Get the stagger amount for an insertion/removal.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {String} type
	   */

	  getStagger: function getStagger(frag, index, total, type) {
	    type = type + 'Stagger';
	    var trans = frag.node.__v_trans;
	    var hooks = trans && trans.hooks;
	    var hook = hooks && (hooks[type] || hooks.stagger);
	    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
	  },

	  /**
	   * Pre-process the value before piping it through the
	   * filters. This is passed to and called by the watcher.
	   */

	  _preProcess: function _preProcess(value) {
	    // regardless of type, store the un-filtered raw value.
	    this.rawValue = value;
	    return value;
	  },

	  /**
	   * Post-process the value after it has been piped through
	   * the filters. This is passed to and called by the watcher.
	   *
	   * It is necessary for this to be called during the
	   * wathcer's dependency collection phase because we want
	   * the v-for to update when the source Object is mutated.
	   */

	  _postProcess: function _postProcess(value) {
	    if (isArray(value)) {
	      return value;
	    } else if (isPlainObject(value)) {
	      // convert plain object to array.
	      var keys = Object.keys(value);
	      var i = keys.length;
	      var res = new Array(i);
	      var key;
	      while (i--) {
	        key = keys[i];
	        res[i] = {
	          $key: key,
	          $value: value[key]
	        };
	      }
	      return res;
	    } else {
	      if (typeof value === 'number') {
	        value = range(value);
	      }
	      return value || [];
	    }
	  },

	  unbind: function unbind() {
	    if (this.descriptor.ref) {
	      (this._scope || this.vm).$refs[this.descriptor.ref] = null;
	    }
	    if (this.frags) {
	      var i = this.frags.length;
	      var frag;
	      while (i--) {
	        frag = this.frags[i];
	        this.deleteCachedFrag(frag);
	        frag.destroy();
	      }
	    }
	  }
	};

	/**
	 * Helper to find the previous element that is a fragment
	 * anchor. This is necessary because a destroyed frag's
	 * element could still be lingering in the DOM before its
	 * leaving transition finishes, but its inserted flag
	 * should have been set to false so we can skip them.
	 *
	 * If this is a block repeat, we want to make sure we only
	 * return frag that is bound to this v-for. (see #929)
	 *
	 * @param {Fragment} frag
	 * @param {Comment|Text} anchor
	 * @param {String} id
	 * @return {Fragment}
	 */

	function findPrevFrag(frag, anchor, id) {
	  var el = frag.node.previousSibling;
	  /* istanbul ignore if */
	  if (!el) return;
	  frag = el.__vfrag__;
	  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
	    el = el.previousSibling;
	    /* istanbul ignore if */
	    if (!el) return;
	    frag = el.__vfrag__;
	  }
	  return frag;
	}

	/**
	 * Find a vm from a fragment.
	 *
	 * @param {Fragment} frag
	 * @return {Vue|undefined}
	 */

	function findVmFromFrag(frag) {
	  var node = frag.node;
	  // handle multi-node frag
	  if (frag.end) {
	    while (!node.__vue__ && node !== frag.end && node.nextSibling) {
	      node = node.nextSibling;
	    }
	  }
	  return node.__vue__;
	}

	/**
	 * Create a range array from given number.
	 *
	 * @param {Number} n
	 * @return {Array}
	 */

	function range(n) {
	  var i = -1;
	  var ret = new Array(n);
	  while (++i < n) {
	    ret[i] = i;
	  }
	  return ret;
	}

	if (false) {
	  vFor.warnDuplicate = function (value) {
	    warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.');
	  };
	}

	var html = {

	  bind: function bind() {
	    // a comment node means this is a binding for
	    // {{{ inline unescaped html }}}
	    if (this.el.nodeType === 8) {
	      // hold nodes
	      this.nodes = [];
	      // replace the placeholder with proper anchor
	      this.anchor = createAnchor('v-html');
	      replace(this.el, this.anchor);
	    }
	  },

	  update: function update(value) {
	    value = _toString(value);
	    if (this.nodes) {
	      this.swap(value);
	    } else {
	      this.el.innerHTML = value;
	    }
	  },

	  swap: function swap(value) {
	    // remove old nodes
	    var i = this.nodes.length;
	    while (i--) {
	      remove(this.nodes[i]);
	    }
	    // convert new value to a fragment
	    // do not attempt to retrieve from id selector
	    var frag = parseTemplate(value, true, true);
	    // save a reference to these nodes so we can remove later
	    this.nodes = toArray(frag.childNodes);
	    before(frag, this.anchor);
	  }
	};

	var text = {

	  bind: function bind() {
	    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
	  },

	  update: function update(value) {
	    this.el[this.attr] = _toString(value);
	  }
	};

	// must export plain object
	var publicDirectives = {
	  text: text,
	  html: html,
	  'for': vFor,
	  'if': vIf,
	  show: show,
	  model: model,
	  on: on,
	  bind: bind,
	  el: el,
	  ref: ref,
	  cloak: cloak
	};

	var queue$1 = [];
	var queued = false;

	/**
	 * Push a job into the queue.
	 *
	 * @param {Function} job
	 */

	function pushJob(job) {
	  queue$1.push(job);
	  if (!queued) {
	    queued = true;
	    nextTick(flush);
	  }
	}

	/**
	 * Flush the queue, and do one forced reflow before
	 * triggering transitions.
	 */

	function flush() {
	  // Force layout
	  var f = document.documentElement.offsetHeight;
	  for (var i = 0; i < queue$1.length; i++) {
	    queue$1[i]();
	  }
	  queue$1 = [];
	  queued = false;
	  // dummy return, so js linters don't complain about
	  // unused variable f
	  return f;
	}

	var TYPE_TRANSITION = 1;
	var TYPE_ANIMATION = 2;
	var transDurationProp = transitionProp + 'Duration';
	var animDurationProp = animationProp + 'Duration';

	/**
	 * A Transition object that encapsulates the state and logic
	 * of the transition.
	 *
	 * @param {Element} el
	 * @param {String} id
	 * @param {Object} hooks
	 * @param {Vue} vm
	 */
	function Transition(el, id, hooks, vm) {
	  this.id = id;
	  this.el = el;
	  this.enterClass = id + '-enter';
	  this.leaveClass = id + '-leave';
	  this.hooks = hooks;
	  this.vm = vm;
	  // async state
	  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
	  this.justEntered = false;
	  this.entered = this.left = false;
	  this.typeCache = {};
	  // bind
	  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {
	    self[m] = bind$1(self[m], self);
	  });
	}

	var p$1 = Transition.prototype;

	/**
	 * Start an entering transition.
	 *
	 * 1. enter transition triggered
	 * 2. call beforeEnter hook
	 * 3. add enter class
	 * 4. insert/show element
	 * 5. call enter hook (with possible explicit js callback)
	 * 6. reflow
	 * 7. based on transition type:
	 *    - transition:
	 *        remove class now, wait for transitionend,
	 *        then done if there's no explicit js callback.
	 *    - animation:
	 *        wait for animationend, remove class,
	 *        then done if there's no explicit js callback.
	 *    - no css transition:
	 *        done now if there's no explicit js callback.
	 * 8. wait for either done or js callback, then call
	 *    afterEnter hook.
	 *
	 * @param {Function} op - insert/show the element
	 * @param {Function} [cb]
	 */

	p$1.enter = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeEnter');
	  this.cb = cb;
	  addClass(this.el, this.enterClass);
	  op();
	  this.entered = false;
	  this.callHookWithCb('enter');
	  if (this.entered) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.enterCancelled;
	  pushJob(this.enterNextTick);
	};

	/**
	 * The "nextTick" phase of an entering transition, which is
	 * to be pushed into a queue and executed after a reflow so
	 * that removing the class can trigger a CSS transition.
	 */

	p$1.enterNextTick = function () {

	  // Important hack:
	  // in Chrome, if a just-entered element is applied the
	  // leave class while its interpolated property still has
	  // a very small value (within one frame), Chrome will
	  // skip the leave transition entirely and not firing the
	  // transtionend event. Therefore we need to protected
	  // against such cases using a one-frame timeout.
	  this.justEntered = true;
	  var self = this;
	  setTimeout(function () {
	    self.justEntered = false;
	  }, 17);

	  var enterDone = this.enterDone;
	  var type = this.getCssTransitionType(this.enterClass);
	  if (!this.pendingJsCb) {
	    if (type === TYPE_TRANSITION) {
	      // trigger transition by removing enter class now
	      removeClass(this.el, this.enterClass);
	      this.setupCssCb(transitionEndEvent, enterDone);
	    } else if (type === TYPE_ANIMATION) {
	      this.setupCssCb(animationEndEvent, enterDone);
	    } else {
	      enterDone();
	    }
	  } else if (type === TYPE_TRANSITION) {
	    removeClass(this.el, this.enterClass);
	  }
	};

	/**
	 * The "cleanup" phase of an entering transition.
	 */

	p$1.enterDone = function () {
	  this.entered = true;
	  this.cancel = this.pendingJsCb = null;
	  removeClass(this.el, this.enterClass);
	  this.callHook('afterEnter');
	  if (this.cb) this.cb();
	};

	/**
	 * Start a leaving transition.
	 *
	 * 1. leave transition triggered.
	 * 2. call beforeLeave hook
	 * 3. add leave class (trigger css transition)
	 * 4. call leave hook (with possible explicit js callback)
	 * 5. reflow if no explicit js callback is provided
	 * 6. based on transition type:
	 *    - transition or animation:
	 *        wait for end event, remove class, then done if
	 *        there's no explicit js callback.
	 *    - no css transition:
	 *        done if there's no explicit js callback.
	 * 7. wait for either done or js callback, then call
	 *    afterLeave hook.
	 *
	 * @param {Function} op - remove/hide the element
	 * @param {Function} [cb]
	 */

	p$1.leave = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeLeave');
	  this.op = op;
	  this.cb = cb;
	  addClass(this.el, this.leaveClass);
	  this.left = false;
	  this.callHookWithCb('leave');
	  if (this.left) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.leaveCancelled;
	  // only need to handle leaveDone if
	  // 1. the transition is already done (synchronously called
	  //    by the user, which causes this.op set to null)
	  // 2. there's no explicit js callback
	  if (this.op && !this.pendingJsCb) {
	    // if a CSS transition leaves immediately after enter,
	    // the transitionend event never fires. therefore we
	    // detect such cases and end the leave immediately.
	    if (this.justEntered) {
	      this.leaveDone();
	    } else {
	      pushJob(this.leaveNextTick);
	    }
	  }
	};

	/**
	 * The "nextTick" phase of a leaving transition.
	 */

	p$1.leaveNextTick = function () {
	  var type = this.getCssTransitionType(this.leaveClass);
	  if (type) {
	    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
	    this.setupCssCb(event, this.leaveDone);
	  } else {
	    this.leaveDone();
	  }
	};

	/**
	 * The "cleanup" phase of a leaving transition.
	 */

	p$1.leaveDone = function () {
	  this.left = true;
	  this.cancel = this.pendingJsCb = null;
	  this.op();
	  removeClass(this.el, this.leaveClass);
	  this.callHook('afterLeave');
	  if (this.cb) this.cb();
	  this.op = null;
	};

	/**
	 * Cancel any pending callbacks from a previously running
	 * but not finished transition.
	 */

	p$1.cancelPending = function () {
	  this.op = this.cb = null;
	  var hasPending = false;
	  if (this.pendingCssCb) {
	    hasPending = true;
	    off(this.el, this.pendingCssEvent, this.pendingCssCb);
	    this.pendingCssEvent = this.pendingCssCb = null;
	  }
	  if (this.pendingJsCb) {
	    hasPending = true;
	    this.pendingJsCb.cancel();
	    this.pendingJsCb = null;
	  }
	  if (hasPending) {
	    removeClass(this.el, this.enterClass);
	    removeClass(this.el, this.leaveClass);
	  }
	  if (this.cancel) {
	    this.cancel.call(this.vm, this.el);
	    this.cancel = null;
	  }
	};

	/**
	 * Call a user-provided synchronous hook function.
	 *
	 * @param {String} type
	 */

	p$1.callHook = function (type) {
	  if (this.hooks && this.hooks[type]) {
	    this.hooks[type].call(this.vm, this.el);
	  }
	};

	/**
	 * Call a user-provided, potentially-async hook function.
	 * We check for the length of arguments to see if the hook
	 * expects a `done` callback. If true, the transition's end
	 * will be determined by when the user calls that callback;
	 * otherwise, the end is determined by the CSS transition or
	 * animation.
	 *
	 * @param {String} type
	 */

	p$1.callHookWithCb = function (type) {
	  var hook = this.hooks && this.hooks[type];
	  if (hook) {
	    if (hook.length > 1) {
	      this.pendingJsCb = cancellable(this[type + 'Done']);
	    }
	    hook.call(this.vm, this.el, this.pendingJsCb);
	  }
	};

	/**
	 * Get an element's transition type based on the
	 * calculated styles.
	 *
	 * @param {String} className
	 * @return {Number}
	 */

	p$1.getCssTransitionType = function (className) {
	  /* istanbul ignore if */
	  if (!transitionEndEvent ||
	  // skip CSS transitions if page is not visible -
	  // this solves the issue of transitionend events not
	  // firing until the page is visible again.
	  // pageVisibility API is supported in IE10+, same as
	  // CSS transitions.
	  document.hidden ||
	  // explicit js-only transition
	  this.hooks && this.hooks.css === false ||
	  // element is hidden
	  isHidden(this.el)) {
	    return;
	  }
	  var type = this.typeCache[className];
	  if (type) return type;
	  var inlineStyles = this.el.style;
	  var computedStyles = window.getComputedStyle(this.el);
	  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
	  if (transDuration && transDuration !== '0s') {
	    type = TYPE_TRANSITION;
	  } else {
	    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
	    if (animDuration && animDuration !== '0s') {
	      type = TYPE_ANIMATION;
	    }
	  }
	  if (type) {
	    this.typeCache[className] = type;
	  }
	  return type;
	};

	/**
	 * Setup a CSS transitionend/animationend callback.
	 *
	 * @param {String} event
	 * @param {Function} cb
	 */

	p$1.setupCssCb = function (event, cb) {
	  this.pendingCssEvent = event;
	  var self = this;
	  var el = this.el;
	  var onEnd = this.pendingCssCb = function (e) {
	    if (e.target === el) {
	      off(el, event, onEnd);
	      self.pendingCssEvent = self.pendingCssCb = null;
	      if (!self.pendingJsCb && cb) {
	        cb();
	      }
	    }
	  };
	  on$1(el, event, onEnd);
	};

	/**
	 * Check if an element is hidden - in that case we can just
	 * skip the transition alltogether.
	 *
	 * @param {Element} el
	 * @return {Boolean}
	 */

	function isHidden(el) {
	  return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
	}

	var transition = {

	  priority: 1100,

	  update: function update(id, oldId) {
	    var el = this.el;
	    // resolve on owner vm
	    var hooks = resolveAsset(this.vm.$options, 'transitions', id);
	    id = id || 'v';
	    // apply on closest vm
	    el.__v_trans = new Transition(el, id, hooks, this.el.__vue__ || this.vm);
	    if (oldId) {
	      removeClass(el, oldId + '-transition');
	    }
	    addClass(el, id + '-transition');
	  }
	};

	var bindingModes = config._propBindingModes;

	var propDef = {

	  bind: function bind() {

	    var child = this.vm;
	    var parent = child._context;
	    // passed in from compiler directly
	    var prop = this.descriptor.prop;
	    var childKey = prop.path;
	    var parentKey = prop.parentPath;
	    var twoWay = prop.mode === bindingModes.TWO_WAY;

	    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {
	      if (assertProp(prop, val)) {
	        child[childKey] = val;
	      }
	    }, {
	      twoWay: twoWay,
	      filters: prop.filters,
	      // important: props need to be observed on the
	      // v-for scope if present
	      scope: this._scope
	    });

	    // set the child initial value.
	    initProp(child, prop, parentWatcher.value);

	    // setup two-way binding
	    if (twoWay) {
	      // important: defer the child watcher creation until
	      // the created hook (after data observation)
	      var self = this;
	      child.$once('hook:created', function () {
	        self.childWatcher = new Watcher(child, childKey, function (val) {
	          parentWatcher.set(val);
	        }, {
	          // ensure sync upward before parent sync down.
	          // this is necessary in cases e.g. the child
	          // mutates a prop array, then replaces it. (#1683)
	          sync: true
	        });
	      });
	    }
	  },

	  unbind: function unbind() {
	    this.parentWatcher.teardown();
	    if (this.childWatcher) {
	      this.childWatcher.teardown();
	    }
	  }
	};

	var component = {

	  priority: 1500,

	  params: ['keep-alive', 'transition-mode', 'inline-template'],

	  /**
	   * Setup. Two possible usages:
	   *
	   * - static:
	   *   <comp> or <div v-component="comp">
	   *
	   * - dynamic:
	   *   <component :is="view">
	   */

	  bind: function bind() {
	    if (!this.el.__vue__) {
	      // keep-alive cache
	      this.keepAlive = this.params.keepAlive;
	      if (this.keepAlive) {
	        this.cache = {};
	      }
	      // check inline-template
	      if (this.params.inlineTemplate) {
	        // extract inline template as a DocumentFragment
	        this.inlineTemplate = extractContent(this.el, true);
	      }
	      // component resolution related state
	      this.pendingComponentCb = this.Component = null;
	      // transition related state
	      this.pendingRemovals = 0;
	      this.pendingRemovalCb = null;
	      // create a ref anchor
	      this.anchor = createAnchor('v-component');
	      replace(this.el, this.anchor);
	      // remove is attribute.
	      // this is removed during compilation, but because compilation is
	      // cached, when the component is used elsewhere this attribute
	      // will remain at link time.
	      this.el.removeAttribute('is');
	      // remove ref, same as above
	      if (this.descriptor.ref) {
	        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
	      }
	      // if static, build right now.
	      if (this.literal) {
	        this.setComponent(this.expression);
	      }
	    } else {
	      ("production") !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
	    }
	  },

	  /**
	   * Public update, called by the watcher in the dynamic
	   * literal scenario, e.g. <component :is="view">
	   */

	  update: function update(value) {
	    if (!this.literal) {
	      this.setComponent(value);
	    }
	  },

	  /**
	   * Switch dynamic components. May resolve the component
	   * asynchronously, and perform transition based on
	   * specified transition mode. Accepts a few additional
	   * arguments specifically for vue-router.
	   *
	   * The callback is called when the full transition is
	   * finished.
	   *
	   * @param {String} value
	   * @param {Function} [cb]
	   */

	  setComponent: function setComponent(value, cb) {
	    this.invalidatePending();
	    if (!value) {
	      // just remove current
	      this.unbuild(true);
	      this.remove(this.childVM, cb);
	      this.childVM = null;
	    } else {
	      var self = this;
	      this.resolveComponent(value, function () {
	        self.mountComponent(cb);
	      });
	    }
	  },

	  /**
	   * Resolve the component constructor to use when creating
	   * the child vm.
	   */

	  resolveComponent: function resolveComponent(id, cb) {
	    var self = this;
	    this.pendingComponentCb = cancellable(function (Component) {
	      self.ComponentName = Component.options.name || id;
	      self.Component = Component;
	      cb();
	    });
	    this.vm._resolveComponent(id, this.pendingComponentCb);
	  },

	  /**
	   * Create a new instance using the current constructor and
	   * replace the existing instance. This method doesn't care
	   * whether the new component and the old one are actually
	   * the same.
	   *
	   * @param {Function} [cb]
	   */

	  mountComponent: function mountComponent(cb) {
	    // actual mount
	    this.unbuild(true);
	    var self = this;
	    var activateHook = this.Component.options.activate;
	    var cached = this.getCached();
	    var newComponent = this.build();
	    if (activateHook && !cached) {
	      this.waitingFor = newComponent;
	      activateHook.call(newComponent, function () {
	        self.waitingFor = null;
	        self.transition(newComponent, cb);
	      });
	    } else {
	      // update ref for kept-alive component
	      if (cached) {
	        newComponent._updateRef();
	      }
	      this.transition(newComponent, cb);
	    }
	  },

	  /**
	   * When the component changes or unbinds before an async
	   * constructor is resolved, we need to invalidate its
	   * pending callback.
	   */

	  invalidatePending: function invalidatePending() {
	    if (this.pendingComponentCb) {
	      this.pendingComponentCb.cancel();
	      this.pendingComponentCb = null;
	    }
	  },

	  /**
	   * Instantiate/insert a new child vm.
	   * If keep alive and has cached instance, insert that
	   * instance; otherwise build a new one and cache it.
	   *
	   * @param {Object} [extraOptions]
	   * @return {Vue} - the created instance
	   */

	  build: function build(extraOptions) {
	    var cached = this.getCached();
	    if (cached) {
	      return cached;
	    }
	    if (this.Component) {
	      // default options
	      var options = {
	        name: this.ComponentName,
	        el: cloneNode(this.el),
	        template: this.inlineTemplate,
	        // make sure to add the child with correct parent
	        // if this is a transcluded component, its parent
	        // should be the transclusion host.
	        parent: this._host || this.vm,
	        // if no inline-template, then the compiled
	        // linker can be cached for better performance.
	        _linkerCachable: !this.inlineTemplate,
	        _ref: this.descriptor.ref,
	        _asComponent: true,
	        _isRouterView: this._isRouterView,
	        // if this is a transcluded component, context
	        // will be the common parent vm of this instance
	        // and its host.
	        _context: this.vm,
	        // if this is inside an inline v-for, the scope
	        // will be the intermediate scope created for this
	        // repeat fragment. this is used for linking props
	        // and container directives.
	        _scope: this._scope,
	        // pass in the owner fragment of this component.
	        // this is necessary so that the fragment can keep
	        // track of its contained components in order to
	        // call attach/detach hooks for them.
	        _frag: this._frag
	      };
	      // extra options
	      // in 1.0.0 this is used by vue-router only
	      /* istanbul ignore if */
	      if (extraOptions) {
	        extend(options, extraOptions);
	      }
	      var child = new this.Component(options);
	      if (this.keepAlive) {
	        this.cache[this.Component.cid] = child;
	      }
	      /* istanbul ignore if */
	      if (false) {
	        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template);
	      }
	      return child;
	    }
	  },

	  /**
	   * Try to get a cached instance of the current component.
	   *
	   * @return {Vue|undefined}
	   */

	  getCached: function getCached() {
	    return this.keepAlive && this.cache[this.Component.cid];
	  },

	  /**
	   * Teardown the current child, but defers cleanup so
	   * that we can separate the destroy and removal steps.
	   *
	   * @param {Boolean} defer
	   */

	  unbuild: function unbuild(defer) {
	    if (this.waitingFor) {
	      this.waitingFor.$destroy();
	      this.waitingFor = null;
	    }
	    var child = this.childVM;
	    if (!child || this.keepAlive) {
	      if (child) {
	        // remove ref
	        child._updateRef(true);
	      }
	      return;
	    }
	    // the sole purpose of `deferCleanup` is so that we can
	    // "deactivate" the vm right now and perform DOM removal
	    // later.
	    child.$destroy(false, defer);
	  },

	  /**
	   * Remove current destroyed child and manually do
	   * the cleanup after removal.
	   *
	   * @param {Function} cb
	   */

	  remove: function remove(child, cb) {
	    var keepAlive = this.keepAlive;
	    if (child) {
	      // we may have a component switch when a previous
	      // component is still being transitioned out.
	      // we want to trigger only one lastest insertion cb
	      // when the existing transition finishes. (#1119)
	      this.pendingRemovals++;
	      this.pendingRemovalCb = cb;
	      var self = this;
	      child.$remove(function () {
	        self.pendingRemovals--;
	        if (!keepAlive) child._cleanup();
	        if (!self.pendingRemovals && self.pendingRemovalCb) {
	          self.pendingRemovalCb();
	          self.pendingRemovalCb = null;
	        }
	      });
	    } else if (cb) {
	      cb();
	    }
	  },

	  /**
	   * Actually swap the components, depending on the
	   * transition mode. Defaults to simultaneous.
	   *
	   * @param {Vue} target
	   * @param {Function} [cb]
	   */

	  transition: function transition(target, cb) {
	    var self = this;
	    var current = this.childVM;
	    // for devtool inspection
	    if (false) {
	      if (current) current._inactive = true;
	      target._inactive = false;
	    }
	    this.childVM = target;
	    switch (self.params.transitionMode) {
	      case 'in-out':
	        target.$before(self.anchor, function () {
	          self.remove(current, cb);
	        });
	        break;
	      case 'out-in':
	        self.remove(current, function () {
	          target.$before(self.anchor, cb);
	        });
	        break;
	      default:
	        self.remove(current);
	        target.$before(self.anchor, cb);
	    }
	  },

	  /**
	   * Unbind.
	   */

	  unbind: function unbind() {
	    this.invalidatePending();
	    // Do not defer cleanup when unbinding
	    this.unbuild();
	    // destroy all keep-alive cached instances
	    if (this.cache) {
	      for (var key in this.cache) {
	        this.cache[key].$destroy();
	      }
	      this.cache = null;
	    }
	  }
	};

	var vClass = {

	  deep: true,

	  update: function update(value) {
	    if (value && typeof value === 'string') {
	      this.handleObject(stringToObject(value));
	    } else if (isPlainObject(value)) {
	      this.handleObject(value);
	    } else if (isArray(value)) {
	      this.handleArray(value);
	    } else {
	      this.cleanup();
	    }
	  },

	  handleObject: function handleObject(value) {
	    this.cleanup(value);
	    var keys = this.prevKeys = Object.keys(value);
	    for (var i = 0, l = keys.length; i < l; i++) {
	      var key = keys[i];
	      if (value[key]) {
	        addClass(this.el, key);
	      } else {
	        removeClass(this.el, key);
	      }
	    }
	  },

	  handleArray: function handleArray(value) {
	    this.cleanup(value);
	    for (var i = 0, l = value.length; i < l; i++) {
	      if (value[i]) {
	        addClass(this.el, value[i]);
	      }
	    }
	    this.prevKeys = value.slice();
	  },

	  cleanup: function cleanup(value) {
	    if (this.prevKeys) {
	      var i = this.prevKeys.length;
	      while (i--) {
	        var key = this.prevKeys[i];
	        if (key && (!value || !contains$1(value, key))) {
	          removeClass(this.el, key);
	        }
	      }
	    }
	  }
	};

	function stringToObject(value) {
	  var res = {};
	  var keys = value.trim().split(/\s+/);
	  var i = keys.length;
	  while (i--) {
	    res[keys[i]] = true;
	  }
	  return res;
	}

	function contains$1(value, key) {
	  return isArray(value) ? value.indexOf(key) > -1 : hasOwn(value, key);
	}

	var internalDirectives = {
	  style: style,
	  'class': vClass,
	  component: component,
	  prop: propDef,
	  transition: transition
	};

	var propBindingModes = config._propBindingModes;
	var empty = {};

	// regexes
	var identRE = /^[$_a-zA-Z]+[\w$]*$/;
	var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;

	/**
	 * Compile props on a root element and return
	 * a props link function.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Array} propOptions
	 * @return {Function} propsLinkFn
	 */

	function compileProps(el, propOptions) {
	  var props = [];
	  var names = Object.keys(propOptions);
	  var i = names.length;
	  var options, name, attr, value, path, parsed, prop;
	  while (i--) {
	    name = names[i];
	    options = propOptions[name] || empty;

	    if (false) {
	      warn('Do not use $data as prop.');
	      continue;
	    }

	    // props could contain dashes, which will be
	    // interpreted as minus calculations by the parser
	    // so we need to camelize the path here
	    path = camelize(name);
	    if (!identRE.test(path)) {
	      ("production") !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.');
	      continue;
	    }

	    prop = {
	      name: name,
	      path: path,
	      options: options,
	      mode: propBindingModes.ONE_WAY,
	      raw: null
	    };

	    attr = hyphenate(name);
	    // first check dynamic version
	    if ((value = getBindAttr(el, attr)) === null) {
	      if ((value = getBindAttr(el, attr + '.sync')) !== null) {
	        prop.mode = propBindingModes.TWO_WAY;
	      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
	        prop.mode = propBindingModes.ONE_TIME;
	      }
	    }
	    if (value !== null) {
	      // has dynamic binding!
	      prop.raw = value;
	      parsed = parseDirective(value);
	      value = parsed.expression;
	      prop.filters = parsed.filters;
	      // check binding type
	      if (isLiteral(value)) {
	        // for expressions containing literal numbers and
	        // booleans, there's no need to setup a prop binding,
	        // so we can optimize them as a one-time set.
	        prop.optimizedLiteral = true;
	      } else {
	        prop.dynamic = true;
	        // check non-settable path for two-way bindings
	        if (false) {
	          prop.mode = propBindingModes.ONE_WAY;
	          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value);
	        }
	      }
	      prop.parentPath = value;

	      // warn required two-way
	      if (false) {
	        warn('Prop "' + name + '" expects a two-way binding type.');
	      }
	    } else if ((value = getAttr(el, attr)) !== null) {
	      // has literal binding!
	      prop.raw = value;
	    } else if (options.required) {
	      // warn missing required
	      ("production") !== 'production' && warn('Missing required prop: ' + name);
	    }
	    // push prop
	    props.push(prop);
	  }
	  return makePropsLinkFn(props);
	}

	/**
	 * Build a function that applies props to a vm.
	 *
	 * @param {Array} props
	 * @return {Function} propsLinkFn
	 */

	function makePropsLinkFn(props) {
	  return function propsLinkFn(vm, scope) {
	    // store resolved props info
	    vm._props = {};
	    var i = props.length;
	    var prop, path, options, value, raw;
	    while (i--) {
	      prop = props[i];
	      raw = prop.raw;
	      path = prop.path;
	      options = prop.options;
	      vm._props[path] = prop;
	      if (raw === null) {
	        // initialize absent prop
	        initProp(vm, prop, getDefault(vm, options));
	      } else if (prop.dynamic) {
	        // dynamic prop
	        if (vm._context) {
	          if (prop.mode === propBindingModes.ONE_TIME) {
	            // one time binding
	            value = (scope || vm._context).$get(prop.parentPath);
	            initProp(vm, prop, value);
	          } else {
	            // dynamic binding
	            vm._bindDir({
	              name: 'prop',
	              def: propDef,
	              prop: prop
	            }, null, null, scope); // el, host, scope
	          }
	        } else {
	            ("production") !== 'production' && warn('Cannot bind dynamic prop on a root instance' + ' with no parent: ' + prop.name + '="' + raw + '"');
	          }
	      } else if (prop.optimizedLiteral) {
	        // optimized literal, cast it and just set once
	        var stripped = stripQuotes(raw);
	        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
	        initProp(vm, prop, value);
	      } else {
	        // string literal, but we need to cater for
	        // Boolean props with no value
	        value = options.type === Boolean && raw === '' ? true : raw;
	        initProp(vm, prop, value);
	      }
	    }
	  };
	}

	/**
	 * Get the default value of a prop.
	 *
	 * @param {Vue} vm
	 * @param {Object} options
	 * @return {*}
	 */

	function getDefault(vm, options) {
	  // no default, return undefined
	  if (!hasOwn(options, 'default')) {
	    // absent boolean value defaults to false
	    return options.type === Boolean ? false : undefined;
	  }
	  var def = options['default'];
	  // warn against non-factory defaults for Object & Array
	  if (isObject(def)) {
	    ("production") !== 'production' && warn('Object/Array as default prop values will be shared ' + 'across multiple instances. Use a factory function ' + 'to return the default value instead.');
	  }
	  // call factory function for non-Function types
	  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
	}

	// special binding prefixes
	var bindRE = /^v-bind:|^:/;
	var onRE = /^v-on:|^@/;
	var argRE = /:(.*)$/;
	var modifierRE = /\.[^\.]+/g;
	var transitionRE = /^(v-bind:|:)?transition$/;

	// terminal directives
	var terminalDirectives = ['for', 'if'];

	// default directive priority
	var DEFAULT_PRIORITY = 1000;

	/**
	 * Compile a template and return a reusable composite link
	 * function, which recursively contains more link functions
	 * inside. This top level compile function would normally
	 * be called on instance root nodes, but can also be used
	 * for partial compilation if the partial argument is true.
	 *
	 * The returned composite link function, when called, will
	 * return an unlink function that tearsdown all directives
	 * created during the linking phase.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Object} options
	 * @param {Boolean} partial
	 * @return {Function}
	 */

	function compile(el, options, partial) {
	  // link function for the node itself.
	  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
	  // link function for the childNodes
	  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && el.tagName !== 'SCRIPT' && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;

	  /**
	   * A composite linker function to be called on a already
	   * compiled piece of DOM, which instantiates all directive
	   * instances.
	   *
	   * @param {Vue} vm
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host] - host vm of transcluded content
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - link context fragment
	   * @return {Function|undefined}
	   */

	  return function compositeLinkFn(vm, el, host, scope, frag) {
	    // cache childNodes before linking parent, fix #657
	    var childNodes = toArray(el.childNodes);
	    // link
	    var dirs = linkAndCapture(function compositeLinkCapturer() {
	      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);
	      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);
	    }, vm);
	    return makeUnlinkFn(vm, dirs);
	  };
	}

	/**
	 * Apply a linker to a vm/element pair and capture the
	 * directives created during the process.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 */

	function linkAndCapture(linker, vm) {
	  var originalDirCount = vm._directives.length;
	  linker();
	  var dirs = vm._directives.slice(originalDirCount);
	  dirs.sort(directiveComparator);
	  for (var i = 0, l = dirs.length; i < l; i++) {
	    dirs[i]._bind();
	  }
	  return dirs;
	}

	/**
	 * Directive priority sort comparator
	 *
	 * @param {Object} a
	 * @param {Object} b
	 */

	function directiveComparator(a, b) {
	  a = a.descriptor.def.priority || DEFAULT_PRIORITY;
	  b = b.descriptor.def.priority || DEFAULT_PRIORITY;
	  return a > b ? -1 : a === b ? 0 : 1;
	}

	/**
	 * Linker functions return an unlink function that
	 * tearsdown all directives instances generated during
	 * the process.
	 *
	 * We create unlink functions with only the necessary
	 * information to avoid retaining additional closures.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Vue} [context]
	 * @param {Array} [contextDirs]
	 * @return {Function}
	 */

	function makeUnlinkFn(vm, dirs, context, contextDirs) {
	  return function unlink(destroying) {
	    teardownDirs(vm, dirs, destroying);
	    if (context && contextDirs) {
	      teardownDirs(context, contextDirs);
	    }
	  };
	}

	/**
	 * Teardown partial linked directives.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Boolean} destroying
	 */

	function teardownDirs(vm, dirs, destroying) {
	  var i = dirs.length;
	  while (i--) {
	    dirs[i]._teardown();
	    if (!destroying) {
	      vm._directives.$remove(dirs[i]);
	    }
	  }
	}

	/**
	 * Compile link props on an instance.
	 *
	 * @param {Vue} vm
	 * @param {Element} el
	 * @param {Object} props
	 * @param {Object} [scope]
	 * @return {Function}
	 */

	function compileAndLinkProps(vm, el, props, scope) {
	  var propsLinkFn = compileProps(el, props);
	  var propDirs = linkAndCapture(function () {
	    propsLinkFn(vm, scope);
	  }, vm);
	  return makeUnlinkFn(vm, propDirs);
	}

	/**
	 * Compile the root element of an instance.
	 *
	 * 1. attrs on context container (context scope)
	 * 2. attrs on the component template root node, if
	 *    replace:true (child scope)
	 *
	 * If this is a fragment instance, we only need to compile 1.
	 *
	 * @param {Vue} vm
	 * @param {Element} el
	 * @param {Object} options
	 * @param {Object} contextOptions
	 * @return {Function}
	 */

	function compileRoot(el, options, contextOptions) {
	  var containerAttrs = options._containerAttrs;
	  var replacerAttrs = options._replacerAttrs;
	  var contextLinkFn, replacerLinkFn;

	  // only need to compile other attributes for
	  // non-fragment instances
	  if (el.nodeType !== 11) {
	    // for components, container and replacer need to be
	    // compiled separately and linked in different scopes.
	    if (options._asComponent) {
	      // 2. container attributes
	      if (containerAttrs && contextOptions) {
	        contextLinkFn = compileDirectives(containerAttrs, contextOptions);
	      }
	      if (replacerAttrs) {
	        // 3. replacer attributes
	        replacerLinkFn = compileDirectives(replacerAttrs, options);
	      }
	    } else {
	      // non-component, just compile as a normal element.
	      replacerLinkFn = compileDirectives(el.attributes, options);
	    }
	  } else if (false) {
	    // warn container directives for fragment instances
	    var names = containerAttrs.filter(function (attr) {
	      // allow vue-loader/vueify scoped css attributes
	      return attr.name.indexOf('_v-') < 0 &&
	      // allow event listeners
	      !onRE.test(attr.name) &&
	      // allow slots
	      attr.name !== 'slot';
	    }).map(function (attr) {
	      return '"' + attr.name + '"';
	    });
	    if (names.length) {
	      var plural = names.length > 1;
	      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment_Instance');
	    }
	  }

	  return function rootLinkFn(vm, el, scope) {
	    // link context scope dirs
	    var context = vm._context;
	    var contextDirs;
	    if (context && contextLinkFn) {
	      contextDirs = linkAndCapture(function () {
	        contextLinkFn(context, el, null, scope);
	      }, context);
	    }

	    // link self
	    var selfDirs = linkAndCapture(function () {
	      if (replacerLinkFn) replacerLinkFn(vm, el);
	    }, vm);

	    // return the unlink function that tearsdown context
	    // container directives.
	    return makeUnlinkFn(vm, selfDirs, context, contextDirs);
	  };
	}

	/**
	 * Compile a node and return a nodeLinkFn based on the
	 * node type.
	 *
	 * @param {Node} node
	 * @param {Object} options
	 * @return {Function|null}
	 */

	function compileNode(node, options) {
	  var type = node.nodeType;
	  if (type === 1 && node.tagName !== 'SCRIPT') {
	    return compileElement(node, options);
	  } else if (type === 3 && node.data.trim()) {
	    return compileTextNode(node, options);
	  } else {
	    return null;
	  }
	}

	/**
	 * Compile an element and return a nodeLinkFn.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|null}
	 */

	function compileElement(el, options) {
	  // preprocess textareas.
	  // textarea treats its text content as the initial value.
	  // just bind it as an attr directive for value.
	  if (el.tagName === 'TEXTAREA') {
	    var tokens = parseText(el.value);
	    if (tokens) {
	      el.setAttribute(':value', tokensToExp(tokens));
	      el.value = '';
	    }
	  }
	  var linkFn;
	  var hasAttrs = el.hasAttributes();
	  // check terminal directives (for & if)
	  if (hasAttrs) {
	    linkFn = checkTerminalDirectives(el, options);
	  }
	  // check element directives
	  if (!linkFn) {
	    linkFn = checkElementDirectives(el, options);
	  }
	  // check component
	  if (!linkFn) {
	    linkFn = checkComponent(el, options);
	  }
	  // normal directives
	  if (!linkFn && hasAttrs) {
	    linkFn = compileDirectives(el.attributes, options);
	  }
	  return linkFn;
	}

	/**
	 * Compile a textNode and return a nodeLinkFn.
	 *
	 * @param {TextNode} node
	 * @param {Object} options
	 * @return {Function|null} textNodeLinkFn
	 */

	function compileTextNode(node, options) {
	  // skip marked text nodes
	  if (node._skip) {
	    return removeText;
	  }

	  var tokens = parseText(node.wholeText);
	  if (!tokens) {
	    return null;
	  }

	  // mark adjacent text nodes as skipped,
	  // because we are using node.wholeText to compile
	  // all adjacent text nodes together. This fixes
	  // issues in IE where sometimes it splits up a single
	  // text node into multiple ones.
	  var next = node.nextSibling;
	  while (next && next.nodeType === 3) {
	    next._skip = true;
	    next = next.nextSibling;
	  }

	  var frag = document.createDocumentFragment();
	  var el, token;
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
	    frag.appendChild(el);
	  }
	  return makeTextNodeLinkFn(tokens, frag, options);
	}

	/**
	 * Linker for an skipped text node.
	 *
	 * @param {Vue} vm
	 * @param {Text} node
	 */

	function removeText(vm, node) {
	  remove(node);
	}

	/**
	 * Process a single text token.
	 *
	 * @param {Object} token
	 * @param {Object} options
	 * @return {Node}
	 */

	function processTextToken(token, options) {
	  var el;
	  if (token.oneTime) {
	    el = document.createTextNode(token.value);
	  } else {
	    if (token.html) {
	      el = document.createComment('v-html');
	      setTokenType('html');
	    } else {
	      // IE will clean up empty textNodes during
	      // frag.cloneNode(true), so we have to give it
	      // something here...
	      el = document.createTextNode(' ');
	      setTokenType('text');
	    }
	  }
	  function setTokenType(type) {
	    if (token.descriptor) return;
	    var parsed = parseDirective(token.value);
	    token.descriptor = {
	      name: type,
	      def: publicDirectives[type],
	      expression: parsed.expression,
	      filters: parsed.filters
	    };
	  }
	  return el;
	}

	/**
	 * Build a function that processes a textNode.
	 *
	 * @param {Array<Object>} tokens
	 * @param {DocumentFragment} frag
	 */

	function makeTextNodeLinkFn(tokens, frag) {
	  return function textNodeLinkFn(vm, el, host, scope) {
	    var fragClone = frag.cloneNode(true);
	    var childNodes = toArray(fragClone.childNodes);
	    var token, value, node;
	    for (var i = 0, l = tokens.length; i < l; i++) {
	      token = tokens[i];
	      value = token.value;
	      if (token.tag) {
	        node = childNodes[i];
	        if (token.oneTime) {
	          value = (scope || vm).$eval(value);
	          if (token.html) {
	            replace(node, parseTemplate(value, true));
	          } else {
	            node.data = value;
	          }
	        } else {
	          vm._bindDir(token.descriptor, node, host, scope);
	        }
	      }
	    }
	    replace(el, fragClone);
	  };
	}

	/**
	 * Compile a node list and return a childLinkFn.
	 *
	 * @param {NodeList} nodeList
	 * @param {Object} options
	 * @return {Function|undefined}
	 */

	function compileNodeList(nodeList, options) {
	  var linkFns = [];
	  var nodeLinkFn, childLinkFn, node;
	  for (var i = 0, l = nodeList.length; i < l; i++) {
	    node = nodeList[i];
	    nodeLinkFn = compileNode(node, options);
	    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
	    linkFns.push(nodeLinkFn, childLinkFn);
	  }
	  return linkFns.length ? makeChildLinkFn(linkFns) : null;
	}

	/**
	 * Make a child link function for a node's childNodes.
	 *
	 * @param {Array<Function>} linkFns
	 * @return {Function} childLinkFn
	 */

	function makeChildLinkFn(linkFns) {
	  return function childLinkFn(vm, nodes, host, scope, frag) {
	    var node, nodeLinkFn, childrenLinkFn;
	    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {
	      node = nodes[n];
	      nodeLinkFn = linkFns[i++];
	      childrenLinkFn = linkFns[i++];
	      // cache childNodes before linking parent, fix #657
	      var childNodes = toArray(node.childNodes);
	      if (nodeLinkFn) {
	        nodeLinkFn(vm, node, host, scope, frag);
	      }
	      if (childrenLinkFn) {
	        childrenLinkFn(vm, childNodes, host, scope, frag);
	      }
	    }
	  };
	}

	/**
	 * Check for element directives (custom elements that should
	 * be resovled as terminal directives).
	 *
	 * @param {Element} el
	 * @param {Object} options
	 */

	function checkElementDirectives(el, options) {
	  var tag = el.tagName.toLowerCase();
	  if (commonTagRE.test(tag)) return;
	  var def = resolveAsset(options, 'elementDirectives', tag);
	  if (def) {
	    return makeTerminalNodeLinkFn(el, tag, '', options, def);
	  }
	}

	/**
	 * Check if an element is a component. If yes, return
	 * a component link function.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|undefined}
	 */

	function checkComponent(el, options) {
	  var component = checkComponentAttr(el, options);
	  if (component) {
	    var ref = findRef(el);
	    var descriptor = {
	      name: 'component',
	      ref: ref,
	      expression: component.id,
	      def: internalDirectives.component,
	      modifiers: {
	        literal: !component.dynamic
	      }
	    };
	    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
	      if (ref) {
	        defineReactive((scope || vm).$refs, ref, null);
	      }
	      vm._bindDir(descriptor, el, host, scope, frag);
	    };
	    componentLinkFn.terminal = true;
	    return componentLinkFn;
	  }
	}

	/**
	 * Check an element for terminal directives in fixed order.
	 * If it finds one, return a terminal link function.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function} terminalLinkFn
	 */

	function checkTerminalDirectives(el, options) {
	  // skip v-pre
	  if (getAttr(el, 'v-pre') !== null) {
	    return skip;
	  }
	  // skip v-else block, but only if following v-if
	  if (el.hasAttribute('v-else')) {
	    var prev = el.previousElementSibling;
	    if (prev && prev.hasAttribute('v-if')) {
	      return skip;
	    }
	  }
	  var value, dirName;
	  for (var i = 0, l = terminalDirectives.length; i < l; i++) {
	    dirName = terminalDirectives[i];
	    /* eslint-disable no-cond-assign */
	    if (value = el.getAttribute('v-' + dirName)) {
	      return makeTerminalNodeLinkFn(el, dirName, value, options);
	    }
	    /* eslint-enable no-cond-assign */
	  }
	}

	function skip() {}
	skip.terminal = true;

	/**
	 * Build a node link function for a terminal directive.
	 * A terminal link function terminates the current
	 * compilation recursion and handles compilation of the
	 * subtree in the directive.
	 *
	 * @param {Element} el
	 * @param {String} dirName
	 * @param {String} value
	 * @param {Object} options
	 * @param {Object} [def]
	 * @return {Function} terminalLinkFn
	 */

	function makeTerminalNodeLinkFn(el, dirName, value, options, def) {
	  var parsed = parseDirective(value);
	  var descriptor = {
	    name: dirName,
	    expression: parsed.expression,
	    filters: parsed.filters,
	    raw: value,
	    // either an element directive, or if/for
	    def: def || publicDirectives[dirName]
	  };
	  // check ref for v-for and router-view
	  if (dirName === 'for' || dirName === 'router-view') {
	    descriptor.ref = findRef(el);
	  }
	  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
	    if (descriptor.ref) {
	      defineReactive((scope || vm).$refs, descriptor.ref, null);
	    }
	    vm._bindDir(descriptor, el, host, scope, frag);
	  };
	  fn.terminal = true;
	  return fn;
	}

	/**
	 * Compile the directives on an element and return a linker.
	 *
	 * @param {Array|NamedNodeMap} attrs
	 * @param {Object} options
	 * @return {Function}
	 */

	function compileDirectives(attrs, options) {
	  var i = attrs.length;
	  var dirs = [];
	  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens;
	  while (i--) {
	    attr = attrs[i];
	    name = rawName = attr.name;
	    value = rawValue = attr.value;
	    tokens = parseText(value);
	    // reset arg
	    arg = null;
	    // check modifiers
	    modifiers = parseModifiers(name);
	    name = name.replace(modifierRE, '');

	    // attribute interpolations
	    if (tokens) {
	      value = tokensToExp(tokens);
	      arg = name;
	      pushDir('bind', publicDirectives.bind, true);
	      // warn against mixing mustaches with v-bind
	      if (false) {
	        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {
	          return attr.name === ':class' || attr.name === 'v-bind:class';
	        })) {
	          warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.');
	        }
	      }
	    } else

	      // special attribute: transition
	      if (transitionRE.test(name)) {
	        modifiers.literal = !bindRE.test(name);
	        pushDir('transition', internalDirectives.transition);
	      } else

	        // event handlers
	        if (onRE.test(name)) {
	          arg = name.replace(onRE, '');
	          pushDir('on', publicDirectives.on);
	        } else

	          // attribute bindings
	          if (bindRE.test(name)) {
	            dirName = name.replace(bindRE, '');
	            if (dirName === 'style' || dirName === 'class') {
	              pushDir(dirName, internalDirectives[dirName]);
	            } else {
	              arg = dirName;
	              pushDir('bind', publicDirectives.bind);
	            }
	          } else

	            // normal directives
	            if (name.indexOf('v-') === 0) {
	              // check arg
	              arg = (arg = name.match(argRE)) && arg[1];
	              if (arg) {
	                name = name.replace(argRE, '');
	              }
	              // extract directive name
	              dirName = name.slice(2);

	              // skip v-else (when used with v-show)
	              if (dirName === 'else') {
	                continue;
	              }

	              dirDef = resolveAsset(options, 'directives', dirName);

	              if (false) {
	                assertAsset(dirDef, 'directive', dirName);
	              }

	              if (dirDef) {
	                pushDir(dirName, dirDef);
	              }
	            }
	  }

	  /**
	   * Push a directive.
	   *
	   * @param {String} dirName
	   * @param {Object|Function} def
	   * @param {Boolean} [interp]
	   */

	  function pushDir(dirName, def, interp) {
	    var parsed = parseDirective(value);
	    dirs.push({
	      name: dirName,
	      attr: rawName,
	      raw: rawValue,
	      def: def,
	      arg: arg,
	      modifiers: modifiers,
	      expression: parsed.expression,
	      filters: parsed.filters,
	      interp: interp
	    });
	  }

	  if (dirs.length) {
	    return makeNodeLinkFn(dirs);
	  }
	}

	/**
	 * Parse modifiers from directive attribute name.
	 *
	 * @param {String} name
	 * @return {Object}
	 */

	function parseModifiers(name) {
	  var res = Object.create(null);
	  var match = name.match(modifierRE);
	  if (match) {
	    var i = match.length;
	    while (i--) {
	      res[match[i].slice(1)] = true;
	    }
	  }
	  return res;
	}

	/**
	 * Build a link function for all directives on a single node.
	 *
	 * @param {Array} directives
	 * @return {Function} directivesLinkFn
	 */

	function makeNodeLinkFn(directives) {
	  return function nodeLinkFn(vm, el, host, scope, frag) {
	    // reverse apply because it's sorted low to high
	    var i = directives.length;
	    while (i--) {
	      vm._bindDir(directives[i], el, host, scope, frag);
	    }
	  };
	}

	var specialCharRE = /[^\w\-:\.]/;

	/**
	 * Process an element or a DocumentFragment based on a
	 * instance option object. This allows us to transclude
	 * a template node/fragment before the instance is created,
	 * so the processed fragment can then be cloned and reused
	 * in v-for.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */

	function transclude(el, options) {
	  // extract container attributes to pass them down
	  // to compiler, because they need to be compiled in
	  // parent scope. we are mutating the options object here
	  // assuming the same object will be used for compile
	  // right after this.
	  if (options) {
	    options._containerAttrs = extractAttrs(el);
	  }
	  // for template tags, what we want is its content as
	  // a documentFragment (for fragment instances)
	  if (isTemplate(el)) {
	    el = parseTemplate(el);
	  }
	  if (options) {
	    if (options._asComponent && !options.template) {
	      options.template = '<slot></slot>';
	    }
	    if (options.template) {
	      options._content = extractContent(el);
	      el = transcludeTemplate(el, options);
	    }
	  }
	  if (el instanceof DocumentFragment) {
	    // anchors for fragment instance
	    // passing in `persist: true` to avoid them being
	    // discarded by IE during template cloning
	    prepend(createAnchor('v-start', true), el);
	    el.appendChild(createAnchor('v-end', true));
	  }
	  return el;
	}

	/**
	 * Process the template option.
	 * If the replace option is true this will swap the $el.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */

	function transcludeTemplate(el, options) {
	  var template = options.template;
	  var frag = parseTemplate(template, true);
	  if (frag) {
	    var replacer = frag.firstChild;
	    var tag = replacer.tagName && replacer.tagName.toLowerCase();
	    if (options.replace) {
	      /* istanbul ignore if */
	      if (el === document.body) {
	        ("production") !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
	      }
	      // there are many cases where the instance must
	      // become a fragment instance: basically anything that
	      // can create more than 1 root nodes.
	      if (
	      // multi-children template
	      frag.childNodes.length > 1 ||
	      // non-element template
	      replacer.nodeType !== 1 ||
	      // single nested component
	      tag === 'component' || resolveAsset(options, 'components', tag) || replacer.hasAttribute('is') || replacer.hasAttribute(':is') || replacer.hasAttribute('v-bind:is') ||
	      // element directive
	      resolveAsset(options, 'elementDirectives', tag) ||
	      // for block
	      replacer.hasAttribute('v-for') ||
	      // if block
	      replacer.hasAttribute('v-if')) {
	        return frag;
	      } else {
	        options._replacerAttrs = extractAttrs(replacer);
	        mergeAttrs(el, replacer);
	        return replacer;
	      }
	    } else {
	      el.appendChild(frag);
	      return el;
	    }
	  } else {
	    ("production") !== 'production' && warn('Invalid template option: ' + template);
	  }
	}

	/**
	 * Helper to extract a component container's attributes
	 * into a plain object array.
	 *
	 * @param {Element} el
	 * @return {Array}
	 */

	function extractAttrs(el) {
	  if (el.nodeType === 1 && el.hasAttributes()) {
	    return toArray(el.attributes);
	  }
	}

	/**
	 * Merge the attributes of two elements, and make sure
	 * the class names are merged properly.
	 *
	 * @param {Element} from
	 * @param {Element} to
	 */

	function mergeAttrs(from, to) {
	  var attrs = from.attributes;
	  var i = attrs.length;
	  var name, value;
	  while (i--) {
	    name = attrs[i].name;
	    value = attrs[i].value;
	    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
	      to.setAttribute(name, value);
	    } else if (name === 'class') {
	      value.split(/\s+/).forEach(function (cls) {
	        addClass(to, cls);
	      });
	    }
	  }
	}

	var compiler = Object.freeze({
		compile: compile,
		compileAndLinkProps: compileAndLinkProps,
		compileRoot: compileRoot,
		transclude: transclude
	});

	function stateMixin (Vue) {

	  /**
	   * Accessor for `$data` property, since setting $data
	   * requires observing the new object and updating
	   * proxied properties.
	   */

	  Object.defineProperty(Vue.prototype, '$data', {
	    get: function get() {
	      return this._data;
	    },
	    set: function set(newData) {
	      if (newData !== this._data) {
	        this._setData(newData);
	      }
	    }
	  });

	  /**
	   * Setup the scope of an instance, which contains:
	   * - observed data
	   * - computed properties
	   * - user methods
	   * - meta properties
	   */

	  Vue.prototype._initState = function () {
	    this._initProps();
	    this._initMeta();
	    this._initMethods();
	    this._initData();
	    this._initComputed();
	  };

	  /**
	   * Initialize props.
	   */

	  Vue.prototype._initProps = function () {
	    var options = this.$options;
	    var el = options.el;
	    var props = options.props;
	    if (props && !el) {
	      ("production") !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.');
	    }
	    // make sure to convert string selectors into element now
	    el = options.el = query(el);
	    this._propsUnlinkFn = el && el.nodeType === 1 && props
	    // props must be linked in proper scope if inside v-for
	    ? compileAndLinkProps(this, el, props, this._scope) : null;
	  };

	  /**
	   * Initialize the data.
	   */

	  Vue.prototype._initData = function () {
	    var propsData = this._data;
	    var optionsDataFn = this.$options.data;
	    var optionsData = optionsDataFn && optionsDataFn();
	    if (optionsData) {
	      this._data = optionsData;
	      for (var prop in propsData) {
	        if (false) {
	          warn('Data field "' + prop + '" is already defined ' + 'as a prop. Use prop default value instead.');
	        }
	        if (this._props[prop].raw !== null || !hasOwn(optionsData, prop)) {
	          set(optionsData, prop, propsData[prop]);
	        }
	      }
	    }
	    var data = this._data;
	    // proxy data on instance
	    var keys = Object.keys(data);
	    var i, key;
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      this._proxy(key);
	    }
	    // observe data
	    observe(data, this);
	  };

	  /**
	   * Swap the instance's $data. Called in $data's setter.
	   *
	   * @param {Object} newData
	   */

	  Vue.prototype._setData = function (newData) {
	    newData = newData || {};
	    var oldData = this._data;
	    this._data = newData;
	    var keys, key, i;
	    // unproxy keys not present in new data
	    keys = Object.keys(oldData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!(key in newData)) {
	        this._unproxy(key);
	      }
	    }
	    // proxy keys not already proxied,
	    // and trigger change for changed values
	    keys = Object.keys(newData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!hasOwn(this, key)) {
	        // new property
	        this._proxy(key);
	      }
	    }
	    oldData.__ob__.removeVm(this);
	    observe(newData, this);
	    this._digest();
	  };

	  /**
	   * Proxy a property, so that
	   * vm.prop === vm._data.prop
	   *
	   * @param {String} key
	   */

	  Vue.prototype._proxy = function (key) {
	    if (!isReserved(key)) {
	      // need to store ref to self here
	      // because these getter/setters might
	      // be called by child scopes via
	      // prototype inheritance.
	      var self = this;
	      Object.defineProperty(self, key, {
	        configurable: true,
	        enumerable: true,
	        get: function proxyGetter() {
	          return self._data[key];
	        },
	        set: function proxySetter(val) {
	          self._data[key] = val;
	        }
	      });
	    }
	  };

	  /**
	   * Unproxy a property.
	   *
	   * @param {String} key
	   */

	  Vue.prototype._unproxy = function (key) {
	    if (!isReserved(key)) {
	      delete this[key];
	    }
	  };

	  /**
	   * Force update on every watcher in scope.
	   */

	  Vue.prototype._digest = function () {
	    for (var i = 0, l = this._watchers.length; i < l; i++) {
	      this._watchers[i].update(true); // shallow updates
	    }
	  };

	  /**
	   * Setup computed properties. They are essentially
	   * special getter/setters
	   */

	  function noop() {}
	  Vue.prototype._initComputed = function () {
	    var computed = this.$options.computed;
	    if (computed) {
	      for (var key in computed) {
	        var userDef = computed[key];
	        var def = {
	          enumerable: true,
	          configurable: true
	        };
	        if (typeof userDef === 'function') {
	          def.get = makeComputedGetter(userDef, this);
	          def.set = noop;
	        } else {
	          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind$1(userDef.get, this) : noop;
	          def.set = userDef.set ? bind$1(userDef.set, this) : noop;
	        }
	        Object.defineProperty(this, key, def);
	      }
	    }
	  };

	  function makeComputedGetter(getter, owner) {
	    var watcher = new Watcher(owner, getter, null, {
	      lazy: true
	    });
	    return function computedGetter() {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    };
	  }

	  /**
	   * Setup instance methods. Methods must be bound to the
	   * instance since they might be passed down as a prop to
	   * child components.
	   */

	  Vue.prototype._initMethods = function () {
	    var methods = this.$options.methods;
	    if (methods) {
	      for (var key in methods) {
	        this[key] = bind$1(methods[key], this);
	      }
	    }
	  };

	  /**
	   * Initialize meta information like $index, $key & $value.
	   */

	  Vue.prototype._initMeta = function () {
	    var metas = this.$options._meta;
	    if (metas) {
	      for (var key in metas) {
	        defineReactive(this, key, metas[key]);
	      }
	    }
	  };
	}

	var eventRE = /^v-on:|^@/;

	function eventsMixin (Vue) {

	  /**
	   * Setup the instance's option events & watchers.
	   * If the value is a string, we pull it from the
	   * instance's methods by name.
	   */

	  Vue.prototype._initEvents = function () {
	    var options = this.$options;
	    if (options._asComponent) {
	      registerComponentEvents(this, options.el);
	    }
	    registerCallbacks(this, '$on', options.events);
	    registerCallbacks(this, '$watch', options.watch);
	  };

	  /**
	   * Register v-on events on a child component
	   *
	   * @param {Vue} vm
	   * @param {Element} el
	   */

	  function registerComponentEvents(vm, el) {
	    var attrs = el.attributes;
	    var name, handler;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      name = attrs[i].name;
	      if (eventRE.test(name)) {
	        name = name.replace(eventRE, '');
	        handler = (vm._scope || vm._context).$eval(attrs[i].value, true);
	        vm.$on(name.replace(eventRE), handler);
	      }
	    }
	  }

	  /**
	   * Register callbacks for option events and watchers.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {Object} hash
	   */

	  function registerCallbacks(vm, action, hash) {
	    if (!hash) return;
	    var handlers, key, i, j;
	    for (key in hash) {
	      handlers = hash[key];
	      if (isArray(handlers)) {
	        for (i = 0, j = handlers.length; i < j; i++) {
	          register(vm, action, key, handlers[i]);
	        }
	      } else {
	        register(vm, action, key, handlers);
	      }
	    }
	  }

	  /**
	   * Helper to register an event/watch callback.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {String} key
	   * @param {Function|String|Object} handler
	   * @param {Object} [options]
	   */

	  function register(vm, action, key, handler, options) {
	    var type = typeof handler;
	    if (type === 'function') {
	      vm[action](key, handler, options);
	    } else if (type === 'string') {
	      var methods = vm.$options.methods;
	      var method = methods && methods[handler];
	      if (method) {
	        vm[action](key, method, options);
	      } else {
	        ("production") !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".');
	      }
	    } else if (handler && type === 'object') {
	      register(vm, action, key, handler.handler, handler);
	    }
	  }

	  /**
	   * Setup recursive attached/detached calls
	   */

	  Vue.prototype._initDOMHooks = function () {
	    this.$on('hook:attached', onAttached);
	    this.$on('hook:detached', onDetached);
	  };

	  /**
	   * Callback to recursively call attached hook on children
	   */

	  function onAttached() {
	    if (!this._isAttached) {
	      this._isAttached = true;
	      this.$children.forEach(callAttach);
	    }
	  }

	  /**
	   * Iterator to call attached hook
	   *
	   * @param {Vue} child
	   */

	  function callAttach(child) {
	    if (!child._isAttached && inDoc(child.$el)) {
	      child._callHook('attached');
	    }
	  }

	  /**
	   * Callback to recursively call detached hook on children
	   */

	  function onDetached() {
	    if (this._isAttached) {
	      this._isAttached = false;
	      this.$children.forEach(callDetach);
	    }
	  }

	  /**
	   * Iterator to call detached hook
	   *
	   * @param {Vue} child
	   */

	  function callDetach(child) {
	    if (child._isAttached && !inDoc(child.$el)) {
	      child._callHook('detached');
	    }
	  }

	  /**
	   * Trigger all handlers for a hook
	   *
	   * @param {String} hook
	   */

	  Vue.prototype._callHook = function (hook) {
	    var handlers = this.$options[hook];
	    if (handlers) {
	      for (var i = 0, j = handlers.length; i < j; i++) {
	        handlers[i].call(this);
	      }
	    }
	    this.$emit('hook:' + hook);
	  };
	}

	function noop() {}

	/**
	 * A directive links a DOM element with a piece of data,
	 * which is the result of evaluating an expression.
	 * It registers a watcher with the expression and calls
	 * the DOM update function when a change is triggered.
	 *
	 * @param {String} name
	 * @param {Node} el
	 * @param {Vue} vm
	 * @param {Object} descriptor
	 *                 - {String} name
	 *                 - {Object} def
	 *                 - {String} expression
	 *                 - {Array<Object>} [filters]
	 *                 - {Boolean} literal
	 *                 - {String} attr
	 *                 - {String} raw
	 * @param {Object} def - directive definition object
	 * @param {Vue} [host] - transclusion host component
	 * @param {Object} [scope] - v-for scope
	 * @param {Fragment} [frag] - owner fragment
	 * @constructor
	 */
	function Directive(descriptor, vm, el, host, scope, frag) {
	  this.vm = vm;
	  this.el = el;
	  // copy descriptor properties
	  this.descriptor = descriptor;
	  this.name = descriptor.name;
	  this.expression = descriptor.expression;
	  this.arg = descriptor.arg;
	  this.modifiers = descriptor.modifiers;
	  this.filters = descriptor.filters;
	  this.literal = this.modifiers && this.modifiers.literal;
	  // private
	  this._locked = false;
	  this._bound = false;
	  this._listeners = null;
	  // link context
	  this._host = host;
	  this._scope = scope;
	  this._frag = frag;
	  // store directives on node in dev mode
	  if (false) {
	    this.el._vue_directives = this.el._vue_directives || [];
	    this.el._vue_directives.push(this);
	  }
	}

	/**
	 * Initialize the directive, mixin definition properties,
	 * setup the watcher, call definition bind() and update()
	 * if present.
	 *
	 * @param {Object} def
	 */

	Directive.prototype._bind = function () {
	  var name = this.name;
	  var descriptor = this.descriptor;

	  // remove attribute
	  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
	    var attr = descriptor.attr || 'v-' + name;
	    this.el.removeAttribute(attr);
	  }

	  // copy def properties
	  var def = descriptor.def;
	  if (typeof def === 'function') {
	    this.update = def;
	  } else {
	    extend(this, def);
	  }

	  // setup directive params
	  this._setupParams();

	  // initial bind
	  if (this.bind) {
	    this.bind();
	  }

	  if (this.literal) {
	    this.update && this.update(descriptor.raw);
	  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
	    // wrapped updater for context
	    var dir = this;
	    if (this.update) {
	      this._update = function (val, oldVal) {
	        if (!dir._locked) {
	          dir.update(val, oldVal);
	        }
	      };
	    } else {
	      this._update = noop;
	    }
	    var preProcess = this._preProcess ? bind$1(this._preProcess, this) : null;
	    var postProcess = this._postProcess ? bind$1(this._postProcess, this) : null;
	    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback
	    {
	      filters: this.filters,
	      twoWay: this.twoWay,
	      deep: this.deep,
	      preProcess: preProcess,
	      postProcess: postProcess,
	      scope: this._scope
	    });
	    // v-model with inital inline value need to sync back to
	    // model instead of update to DOM on init. They would
	    // set the afterBind hook to indicate that.
	    if (this.afterBind) {
	      this.afterBind();
	    } else if (this.update) {
	      this.update(watcher.value);
	    }
	  }
	  this._bound = true;
	};

	/**
	 * Setup all param attributes, e.g. track-by,
	 * transition-mode, etc...
	 */

	Directive.prototype._setupParams = function () {
	  if (!this.params) {
	    return;
	  }
	  var params = this.params;
	  // swap the params array with a fresh object.
	  this.params = Object.create(null);
	  var i = params.length;
	  var key, val, mappedKey;
	  while (i--) {
	    key = params[i];
	    mappedKey = camelize(key);
	    val = getBindAttr(this.el, key);
	    if (val != null) {
	      // dynamic
	      this._setupParamWatcher(mappedKey, val);
	    } else {
	      // static
	      val = getAttr(this.el, key);
	      if (val != null) {
	        this.params[mappedKey] = val === '' ? true : val;
	      }
	    }
	  }
	};

	/**
	 * Setup a watcher for a dynamic param.
	 *
	 * @param {String} key
	 * @param {String} expression
	 */

	Directive.prototype._setupParamWatcher = function (key, expression) {
	  var self = this;
	  var called = false;
	  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {
	    self.params[key] = val;
	    // since we are in immediate mode,
	    // only call the param change callbacks if this is not the first update.
	    if (called) {
	      var cb = self.paramWatchers && self.paramWatchers[key];
	      if (cb) {
	        cb.call(self, val, oldVal);
	      }
	    } else {
	      called = true;
	    }
	  }, {
	    immediate: true
	  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
	};

	/**
	 * Check if the directive is a function caller
	 * and if the expression is a callable one. If both true,
	 * we wrap up the expression and use it as the event
	 * handler.
	 *
	 * e.g. on-click="a++"
	 *
	 * @return {Boolean}
	 */

	Directive.prototype._checkStatement = function () {
	  var expression = this.expression;
	  if (expression && this.acceptStatement && !isSimplePath(expression)) {
	    var fn = parseExpression(expression).get;
	    var scope = this._scope || this.vm;
	    var handler = function handler(e) {
	      scope.$event = e;
	      fn.call(scope, scope);
	      scope.$event = null;
	    };
	    if (this.filters) {
	      handler = scope._applyFilters(handler, null, this.filters);
	    }
	    this.update(handler);
	    return true;
	  }
	};

	/**
	 * Set the corresponding value with the setter.
	 * This should only be used in two-way directives
	 * e.g. v-model.
	 *
	 * @param {*} value
	 * @public
	 */

	Directive.prototype.set = function (value) {
	  /* istanbul ignore else */
	  if (this.twoWay) {
	    this._withLock(function () {
	      this._watcher.set(value);
	    });
	  } else if (false) {
	    warn('Directive.set() can only be used inside twoWay' + 'directives.');
	  }
	};

	/**
	 * Execute a function while preventing that function from
	 * triggering updates on this directive instance.
	 *
	 * @param {Function} fn
	 */

	Directive.prototype._withLock = function (fn) {
	  var self = this;
	  self._locked = true;
	  fn.call(self);
	  nextTick(function () {
	    self._locked = false;
	  });
	};

	/**
	 * Convenience method that attaches a DOM event listener
	 * to the directive element and autometically tears it down
	 * during unbind.
	 *
	 * @param {String} event
	 * @param {Function} handler
	 */

	Directive.prototype.on = function (event, handler) {
	  on$1(this.el, event, handler);(this._listeners || (this._listeners = [])).push([event, handler]);
	};

	/**
	 * Teardown the watcher and call unbind.
	 */

	Directive.prototype._teardown = function () {
	  if (this._bound) {
	    this._bound = false;
	    if (this.unbind) {
	      this.unbind();
	    }
	    if (this._watcher) {
	      this._watcher.teardown();
	    }
	    var listeners = this._listeners;
	    var i;
	    if (listeners) {
	      i = listeners.length;
	      while (i--) {
	        off(this.el, listeners[i][0], listeners[i][1]);
	      }
	    }
	    var unwatchFns = this._paramUnwatchFns;
	    if (unwatchFns) {
	      i = unwatchFns.length;
	      while (i--) {
	        unwatchFns[i]();
	      }
	    }
	    if (false) {
	      this.el._vue_directives.$remove(this);
	    }
	    this.vm = this.el = this._watcher = this._listeners = null;
	  }
	};

	function lifecycleMixin (Vue) {

	  /**
	   * Update v-ref for component.
	   *
	   * @param {Boolean} remove
	   */

	  Vue.prototype._updateRef = function (remove) {
	    var ref = this.$options._ref;
	    if (ref) {
	      var refs = (this._scope || this._context).$refs;
	      if (remove) {
	        if (refs[ref] === this) {
	          refs[ref] = null;
	        }
	      } else {
	        refs[ref] = this;
	      }
	    }
	  };

	  /**
	   * Transclude, compile and link element.
	   *
	   * If a pre-compiled linker is available, that means the
	   * passed in element will be pre-transcluded and compiled
	   * as well - all we need to do is to call the linker.
	   *
	   * Otherwise we need to call transclude/compile/link here.
	   *
	   * @param {Element} el
	   * @return {Element}
	   */

	  Vue.prototype._compile = function (el) {
	    var options = this.$options;

	    // transclude and init element
	    // transclude can potentially replace original
	    // so we need to keep reference; this step also injects
	    // the template and caches the original attributes
	    // on the container node and replacer node.
	    var original = el;
	    el = transclude(el, options);
	    this._initElement(el);

	    // root is always compiled per-instance, because
	    // container attrs and props can be different every time.
	    var contextOptions = this._context && this._context.$options;
	    var rootLinker = compileRoot(el, options, contextOptions);

	    // compile and link the rest
	    var contentLinkFn;
	    var ctor = this.constructor;
	    // component compilation can be cached
	    // as long as it's not using inline-template
	    if (options._linkerCachable) {
	      contentLinkFn = ctor.linker;
	      if (!contentLinkFn) {
	        contentLinkFn = ctor.linker = compile(el, options);
	      }
	    }

	    // link phase
	    // make sure to link root with prop scope!
	    var rootUnlinkFn = rootLinker(this, el, this._scope);
	    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);

	    // register composite unlink function
	    // to be called during instance destruction
	    this._unlinkFn = function () {
	      rootUnlinkFn();
	      // passing destroying: true to avoid searching and
	      // splicing the directives
	      contentUnlinkFn(true);
	    };

	    // finally replace original
	    if (options.replace) {
	      replace(original, el);
	    }

	    this._isCompiled = true;
	    this._callHook('compiled');
	    return el;
	  };

	  /**
	   * Initialize instance element. Called in the public
	   * $mount() method.
	   *
	   * @param {Element} el
	   */

	  Vue.prototype._initElement = function (el) {
	    if (el instanceof DocumentFragment) {
	      this._isFragment = true;
	      this.$el = this._fragmentStart = el.firstChild;
	      this._fragmentEnd = el.lastChild;
	      // set persisted text anchors to empty
	      if (this._fragmentStart.nodeType === 3) {
	        this._fragmentStart.data = this._fragmentEnd.data = '';
	      }
	      this._fragment = el;
	    } else {
	      this.$el = el;
	    }
	    this.$el.__vue__ = this;
	    this._callHook('beforeCompile');
	  };

	  /**
	   * Create and bind a directive to an element.
	   *
	   * @param {String} name - directive name
	   * @param {Node} node   - target node
	   * @param {Object} desc - parsed directive descriptor
	   * @param {Object} def  - directive definition object
	   * @param {Vue} [host] - transclusion host component
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - owner fragment
	   */

	  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {
	    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
	  };

	  /**
	   * Teardown an instance, unobserves the data, unbind all the
	   * directives, turn off all the event listeners, etc.
	   *
	   * @param {Boolean} remove - whether to remove the DOM node.
	   * @param {Boolean} deferCleanup - if true, defer cleanup to
	   *                                 be called later
	   */

	  Vue.prototype._destroy = function (remove, deferCleanup) {
	    if (this._isBeingDestroyed) {
	      if (!deferCleanup) {
	        this._cleanup();
	      }
	      return;
	    }
	    this._callHook('beforeDestroy');
	    this._isBeingDestroyed = true;
	    var i;
	    // remove self from parent. only necessary
	    // if parent is not being destroyed as well.
	    var parent = this.$parent;
	    if (parent && !parent._isBeingDestroyed) {
	      parent.$children.$remove(this);
	      // unregister ref (remove: true)
	      this._updateRef(true);
	    }
	    // destroy all children.
	    i = this.$children.length;
	    while (i--) {
	      this.$children[i].$destroy();
	    }
	    // teardown props
	    if (this._propsUnlinkFn) {
	      this._propsUnlinkFn();
	    }
	    // teardown all directives. this also tearsdown all
	    // directive-owned watchers.
	    if (this._unlinkFn) {
	      this._unlinkFn();
	    }
	    i = this._watchers.length;
	    while (i--) {
	      this._watchers[i].teardown();
	    }
	    // remove reference to self on $el
	    if (this.$el) {
	      this.$el.__vue__ = null;
	    }
	    // remove DOM element
	    var self = this;
	    if (remove && this.$el) {
	      this.$remove(function () {
	        self._cleanup();
	      });
	    } else if (!deferCleanup) {
	      this._cleanup();
	    }
	  };

	  /**
	   * Clean up to ensure garbage collection.
	   * This is called after the leave transition if there
	   * is any.
	   */

	  Vue.prototype._cleanup = function () {
	    if (this._isDestroyed) {
	      return;
	    }
	    // remove self from owner fragment
	    // do it in cleanup so that we can call $destroy with
	    // defer right when a fragment is about to be removed.
	    if (this._frag) {
	      this._frag.children.$remove(this);
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (this._data.__ob__) {
	      this._data.__ob__.removeVm(this);
	    }
	    // Clean up references to private properties and other
	    // instances. preserve reference to _data so that proxy
	    // accessors still work. The only potential side effect
	    // here is that mutating the instance after it's destroyed
	    // may affect the state of other components that are still
	    // observing the same object, but that seems to be a
	    // reasonable responsibility for the user rather than
	    // always throwing an error on them.
	    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
	    // call the last hook...
	    this._isDestroyed = true;
	    this._callHook('destroyed');
	    // turn off all instance listeners.
	    this.$off();
	  };
	}

	function miscMixin (Vue) {

	  /**
	   * Apply a list of filter (descriptors) to a value.
	   * Using plain for loops here because this will be called in
	   * the getter of any watcher with filters so it is very
	   * performance sensitive.
	   *
	   * @param {*} value
	   * @param {*} [oldValue]
	   * @param {Array} filters
	   * @param {Boolean} write
	   * @return {*}
	   */

	  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {
	    var filter, fn, args, arg, offset, i, l, j, k;
	    for (i = 0, l = filters.length; i < l; i++) {
	      filter = filters[i];
	      fn = resolveAsset(this.$options, 'filters', filter.name);
	      if (false) {
	        assertAsset(fn, 'filter', filter.name);
	      }
	      if (!fn) continue;
	      fn = write ? fn.write : fn.read || fn;
	      if (typeof fn !== 'function') continue;
	      args = write ? [value, oldValue] : [value];
	      offset = write ? 2 : 1;
	      if (filter.args) {
	        for (j = 0, k = filter.args.length; j < k; j++) {
	          arg = filter.args[j];
	          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
	        }
	      }
	      value = fn.apply(this, args);
	    }
	    return value;
	  };

	  /**
	   * Resolve a component, depending on whether the component
	   * is defined normally or using an async factory function.
	   * Resolves synchronously if already resolved, otherwise
	   * resolves asynchronously and caches the resolved
	   * constructor on the factory.
	   *
	   * @param {String} id
	   * @param {Function} cb
	   */

	  Vue.prototype._resolveComponent = function (id, cb) {
	    var factory = resolveAsset(this.$options, 'components', id);
	    if (false) {
	      assertAsset(factory, 'component', id);
	    }
	    if (!factory) {
	      return;
	    }
	    // async component factory
	    if (!factory.options) {
	      if (factory.resolved) {
	        // cached
	        cb(factory.resolved);
	      } else if (factory.requested) {
	        // pool callbacks
	        factory.pendingCallbacks.push(cb);
	      } else {
	        factory.requested = true;
	        var cbs = factory.pendingCallbacks = [cb];
	        factory(function resolve(res) {
	          if (isPlainObject(res)) {
	            res = Vue.extend(res);
	          }
	          // cache resolved
	          factory.resolved = res;
	          // invoke callbacks
	          for (var i = 0, l = cbs.length; i < l; i++) {
	            cbs[i](res);
	          }
	        }, function reject(reason) {
	          ("production") !== 'production' && warn('Failed to resolve async component: ' + id + '. ' + (reason ? '\nReason: ' + reason : ''));
	        });
	      }
	    } else {
	      // normal component
	      cb(factory);
	    }
	  };
	}

	function globalAPI (Vue) {

	  /**
	   * Expose useful internals
	   */

	  Vue.util = util;
	  Vue.config = config;
	  Vue.set = set;
	  Vue['delete'] = del;
	  Vue.nextTick = nextTick;

	  /**
	   * The following are exposed for advanced usage / plugins
	   */

	  Vue.compiler = compiler;
	  Vue.FragmentFactory = FragmentFactory;
	  Vue.internalDirectives = internalDirectives;
	  Vue.parsers = {
	    path: path,
	    text: text$1,
	    template: template,
	    directive: directive,
	    expression: expression
	  };

	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */

	  Vue.cid = 0;
	  var cid = 1;

	  /**
	   * Class inheritance
	   *
	   * @param {Object} extendOptions
	   */

	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var isFirstExtend = Super.cid === 0;
	    if (isFirstExtend && extendOptions._Ctor) {
	      return extendOptions._Ctor;
	    }
	    var name = extendOptions.name || Super.options.name;
	    var Sub = createClass(name || 'VueComponent');
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	    // allow further extension
	    Sub.extend = Super.extend;
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    config._assetTypes.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	    // cache constructor
	    if (isFirstExtend) {
	      extendOptions._Ctor = Sub;
	    }
	    return Sub;
	  };

	  /**
	   * A function that returns a sub-class constructor with the
	   * given name. This gives us much nicer output when
	   * logging instances in the console.
	   *
	   * @param {String} name
	   * @return {Function}
	   */

	  function createClass(name) {
	    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
	  }

	  /**
	   * Plugin system
	   *
	   * @param {Object} plugin
	   */

	  Vue.use = function (plugin) {
	    /* istanbul ignore if */
	    if (plugin.installed) {
	      return;
	    }
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else {
	      plugin.apply(null, args);
	    }
	    plugin.installed = true;
	    return this;
	  };

	  /**
	   * Apply a global mixin by merging it into the default
	   * options.
	   */

	  Vue.mixin = function (mixin) {
	    Vue.options = mergeOptions(Vue.options, mixin);
	  };

	  /**
	   * Create asset registration methods with the following
	   * signature:
	   *
	   * @param {String} id
	   * @param {*} definition
	   */

	  config._assetTypes.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (false) {
	          if (type === 'component' && commonTagRE.test(id)) {
	            warn('Do not use built-in HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          definition.name = id;
	          definition = Vue.extend(definition);
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });
	}

	var filterRE = /[^|]\|[^|]/;

	function dataAPI (Vue) {

	  /**
	   * Get the value from an expression on this vm.
	   *
	   * @param {String} exp
	   * @param {Boolean} [asStatement]
	   * @return {*}
	   */

	  Vue.prototype.$get = function (exp, asStatement) {
	    var res = parseExpression(exp);
	    if (res) {
	      if (asStatement && !isSimplePath(exp)) {
	        var self = this;
	        return function statementHandler() {
	          res.get.call(self, self);
	        };
	      } else {
	        try {
	          return res.get.call(this, this);
	        } catch (e) {}
	      }
	    }
	  };

	  /**
	   * Set the value from an expression on this vm.
	   * The expression must be a valid left-hand
	   * expression in an assignment.
	   *
	   * @param {String} exp
	   * @param {*} val
	   */

	  Vue.prototype.$set = function (exp, val) {
	    var res = parseExpression(exp, true);
	    if (res && res.set) {
	      res.set.call(this, this, val);
	    }
	  };

	  /**
	   * Delete a property on the VM
	   *
	   * @param {String} key
	   */

	  Vue.prototype.$delete = function (key) {
	    del(this._data, key);
	  };

	  /**
	   * Watch an expression, trigger callback when its
	   * value changes.
	   *
	   * @param {String|Function} expOrFn
	   * @param {Function} cb
	   * @param {Object} [options]
	   *                 - {Boolean} deep
	   *                 - {Boolean} immediate
	   * @return {Function} - unwatchFn
	   */

	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    var parsed;
	    if (typeof expOrFn === 'string') {
	      parsed = parseDirective(expOrFn);
	      expOrFn = parsed.expression;
	    }
	    var watcher = new Watcher(vm, expOrFn, cb, {
	      deep: options && options.deep,
	      filters: parsed && parsed.filters
	    });
	    if (options && options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };

	  /**
	   * Evaluate a text directive, including filters.
	   *
	   * @param {String} text
	   * @param {Boolean} [asStatement]
	   * @return {String}
	   */

	  Vue.prototype.$eval = function (text, asStatement) {
	    // check for filters.
	    if (filterRE.test(text)) {
	      var dir = parseDirective(text);
	      // the filter regex check might give false positive
	      // for pipes inside strings, so it's possible that
	      // we don't get any filters here
	      var val = this.$get(dir.expression, asStatement);
	      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
	    } else {
	      // no filter
	      return this.$get(text, asStatement);
	    }
	  };

	  /**
	   * Interpolate a piece of template text.
	   *
	   * @param {String} text
	   * @return {String}
	   */

	  Vue.prototype.$interpolate = function (text) {
	    var tokens = parseText(text);
	    var vm = this;
	    if (tokens) {
	      if (tokens.length === 1) {
	        return vm.$eval(tokens[0].value) + '';
	      } else {
	        return tokens.map(function (token) {
	          return token.tag ? vm.$eval(token.value) : token.value;
	        }).join('');
	      }
	    } else {
	      return text;
	    }
	  };

	  /**
	   * Log instance data as a plain JS object
	   * so that it is easier to inspect in console.
	   * This method assumes console is available.
	   *
	   * @param {String} [path]
	   */

	  Vue.prototype.$log = function (path) {
	    var data = path ? getPath(this._data, path) : this._data;
	    if (data) {
	      data = clean(data);
	    }
	    // include computed fields
	    if (!path) {
	      for (var key in this.$options.computed) {
	        data[key] = clean(this[key]);
	      }
	    }
	    console.log(data);
	  };

	  /**
	   * "clean" a getter/setter converted object into a plain
	   * object copy.
	   *
	   * @param {Object} - obj
	   * @return {Object}
	   */

	  function clean(obj) {
	    return JSON.parse(JSON.stringify(obj));
	  }
	}

	function domAPI (Vue) {

	  /**
	   * Convenience on-instance nextTick. The callback is
	   * auto-bound to the instance, and this avoids component
	   * modules having to rely on the global Vue.
	   *
	   * @param {Function} fn
	   */

	  Vue.prototype.$nextTick = function (fn) {
	    nextTick(fn, this);
	  };

	  /**
	   * Append instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */

	  Vue.prototype.$appendTo = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, append, appendWithTransition);
	  };

	  /**
	   * Prepend instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */

	  Vue.prototype.$prependTo = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.hasChildNodes()) {
	      this.$before(target.firstChild, cb, withTransition);
	    } else {
	      this.$appendTo(target, cb, withTransition);
	    }
	    return this;
	  };

	  /**
	   * Insert instance before target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */

	  Vue.prototype.$before = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
	  };

	  /**
	   * Insert instance after target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */

	  Vue.prototype.$after = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.nextSibling) {
	      this.$before(target.nextSibling, cb, withTransition);
	    } else {
	      this.$appendTo(target.parentNode, cb, withTransition);
	    }
	    return this;
	  };

	  /**
	   * Remove instance from DOM
	   *
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */

	  Vue.prototype.$remove = function (cb, withTransition) {
	    if (!this.$el.parentNode) {
	      return cb && cb();
	    }
	    var inDocument = this._isAttached && inDoc(this.$el);
	    // if we are not in document, no need to check
	    // for transitions
	    if (!inDocument) withTransition = false;
	    var self = this;
	    var realCb = function realCb() {
	      if (inDocument) self._callHook('detached');
	      if (cb) cb();
	    };
	    if (this._isFragment) {
	      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
	    } else {
	      var op = withTransition === false ? removeWithCb : removeWithTransition;
	      op(this.$el, this, realCb);
	    }
	    return this;
	  };

	  /**
	   * Shared DOM insertion function.
	   *
	   * @param {Vue} vm
	   * @param {Element} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition]
	   * @param {Function} op1 - op for non-transition insert
	   * @param {Function} op2 - op for transition insert
	   * @return vm
	   */

	  function insert(vm, target, cb, withTransition, op1, op2) {
	    target = query(target);
	    var targetIsDetached = !inDoc(target);
	    var op = withTransition === false || targetIsDetached ? op1 : op2;
	    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
	    if (vm._isFragment) {
	      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {
	        op(node, target, vm);
	      });
	      cb && cb();
	    } else {
	      op(vm.$el, target, vm, cb);
	    }
	    if (shouldCallHook) {
	      vm._callHook('attached');
	    }
	    return vm;
	  }

	  /**
	   * Check for selectors
	   *
	   * @param {String|Element} el
	   */

	  function query(el) {
	    return typeof el === 'string' ? document.querySelector(el) : el;
	  }

	  /**
	   * Append operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */

	  function append(el, target, vm, cb) {
	    target.appendChild(el);
	    if (cb) cb();
	  }

	  /**
	   * InsertBefore operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */

	  function beforeWithCb(el, target, vm, cb) {
	    before(el, target);
	    if (cb) cb();
	  }

	  /**
	   * Remove operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */

	  function removeWithCb(el, vm, cb) {
	    remove(el);
	    if (cb) cb();
	  }
	}

	function eventsAPI (Vue) {

	  /**
	   * Listen on the given `event` with `fn`.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */

	  Vue.prototype.$on = function (event, fn) {
	    (this._events[event] || (this._events[event] = [])).push(fn);
	    modifyListenerCount(this, event, 1);
	    return this;
	  };

	  /**
	   * Adds an `event` listener that will be invoked a single
	   * time then automatically removed.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */

	  Vue.prototype.$once = function (event, fn) {
	    var self = this;
	    function on() {
	      self.$off(event, on);
	      fn.apply(this, arguments);
	    }
	    on.fn = fn;
	    this.$on(event, on);
	    return this;
	  };

	  /**
	   * Remove the given callback for `event` or all
	   * registered callbacks.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */

	  Vue.prototype.$off = function (event, fn) {
	    var cbs;
	    // all
	    if (!arguments.length) {
	      if (this.$parent) {
	        for (event in this._events) {
	          cbs = this._events[event];
	          if (cbs) {
	            modifyListenerCount(this, event, -cbs.length);
	          }
	        }
	      }
	      this._events = {};
	      return this;
	    }
	    // specific event
	    cbs = this._events[event];
	    if (!cbs) {
	      return this;
	    }
	    if (arguments.length === 1) {
	      modifyListenerCount(this, event, -cbs.length);
	      this._events[event] = null;
	      return this;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        modifyListenerCount(this, event, -1);
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return this;
	  };

	  /**
	   * Trigger an event on self.
	   *
	   * @param {String} event
	   * @return {Boolean} shouldPropagate
	   */

	  Vue.prototype.$emit = function (event) {
	    var cbs = this._events[event];
	    var shouldPropagate = !cbs;
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        var res = cbs[i].apply(this, args);
	        if (res === true) {
	          shouldPropagate = true;
	        }
	      }
	    }
	    return shouldPropagate;
	  };

	  /**
	   * Recursively broadcast an event to all children instances.
	   *
	   * @param {String} event
	   * @param {...*} additional arguments
	   */

	  Vue.prototype.$broadcast = function (event) {
	    // if no child has registered for this event,
	    // then there's no need to broadcast.
	    if (!this._eventsCount[event]) return;
	    var children = this.$children;
	    for (var i = 0, l = children.length; i < l; i++) {
	      var child = children[i];
	      var shouldPropagate = child.$emit.apply(child, arguments);
	      if (shouldPropagate) {
	        child.$broadcast.apply(child, arguments);
	      }
	    }
	    return this;
	  };

	  /**
	   * Recursively propagate an event up the parent chain.
	   *
	   * @param {String} event
	   * @param {...*} additional arguments
	   */

	  Vue.prototype.$dispatch = function () {
	    this.$emit.apply(this, arguments);
	    var parent = this.$parent;
	    while (parent) {
	      var shouldPropagate = parent.$emit.apply(parent, arguments);
	      parent = shouldPropagate ? parent.$parent : null;
	    }
	    return this;
	  };

	  /**
	   * Modify the listener counts on all parents.
	   * This bookkeeping allows $broadcast to return early when
	   * no child has listened to a certain event.
	   *
	   * @param {Vue} vm
	   * @param {String} event
	   * @param {Number} count
	   */

	  var hookRE = /^hook:/;
	  function modifyListenerCount(vm, event, count) {
	    var parent = vm.$parent;
	    // hooks do not get broadcasted so no need
	    // to do bookkeeping for them
	    if (!parent || !count || hookRE.test(event)) return;
	    while (parent) {
	      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
	      parent = parent.$parent;
	    }
	  }
	}

	function lifecycleAPI (Vue) {

	  /**
	   * Set instance target element and kick off the compilation
	   * process. The passed in `el` can be a selector string, an
	   * existing Element, or a DocumentFragment (for block
	   * instances).
	   *
	   * @param {Element|DocumentFragment|string} el
	   * @public
	   */

	  Vue.prototype.$mount = function (el) {
	    if (this._isCompiled) {
	      ("production") !== 'production' && warn('$mount() should be called only once.');
	      return;
	    }
	    el = query(el);
	    if (!el) {
	      el = document.createElement('div');
	    }
	    this._compile(el);
	    this._initDOMHooks();
	    if (inDoc(this.$el)) {
	      this._callHook('attached');
	      ready.call(this);
	    } else {
	      this.$once('hook:attached', ready);
	    }
	    return this;
	  };

	  /**
	   * Mark an instance as ready.
	   */

	  function ready() {
	    this._isAttached = true;
	    this._isReady = true;
	    this._callHook('ready');
	  }

	  /**
	   * Teardown the instance, simply delegate to the internal
	   * _destroy.
	   */

	  Vue.prototype.$destroy = function (remove, deferCleanup) {
	    this._destroy(remove, deferCleanup);
	  };

	  /**
	   * Partially compile a piece of DOM and return a
	   * decompile function.
	   *
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host]
	   * @return {Function}
	   */

	  Vue.prototype.$compile = function (el, host, scope, frag) {
	    return compile(el, this.$options, true)(this, el, host, scope, frag);
	  };
	}

	/**
	 * The exposed Vue constructor.
	 *
	 * API conventions:
	 * - public API methods/properties are prefixed with `$`
	 * - internal methods/properties are prefixed with `_`
	 * - non-prefixed properties are assumed to be proxied user
	 *   data.
	 *
	 * @constructor
	 * @param {Object} [options]
	 * @public
	 */

	function Vue(options) {
	  this._init(options);
	}

	// install internals
	initMixin(Vue);
	stateMixin(Vue);
	eventsMixin(Vue);
	lifecycleMixin(Vue);
	miscMixin(Vue);

	// install APIs
	globalAPI(Vue);
	dataAPI(Vue);
	domAPI(Vue);
	eventsAPI(Vue);
	lifecycleAPI(Vue);

	var convertArray = vFor._postProcess;

	/**
	 * Limit filter for arrays
	 *
	 * @param {Number} n
	 * @param {Number} offset (Decimal expected)
	 */

	function limitBy(arr, n, offset) {
	  offset = offset ? parseInt(offset, 10) : 0;
	  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
	}

	/**
	 * Filter filter for arrays
	 *
	 * @param {String} search
	 * @param {String} [delimiter]
	 * @param {String} ...dataKeys
	 */

	function filterBy(arr, search, delimiter) {
	  arr = convertArray(arr);
	  if (search == null) {
	    return arr;
	  }
	  if (typeof search === 'function') {
	    return arr.filter(search);
	  }
	  // cast to lowercase string
	  search = ('' + search).toLowerCase();
	  // allow optional `in` delimiter
	  // because why not
	  var n = delimiter === 'in' ? 3 : 2;
	  // extract and flatten keys
	  var keys = toArray(arguments, n).reduce(function (prev, cur) {
	    return prev.concat(cur);
	  }, []);
	  var res = [];
	  var item, key, val, j;
	  for (var i = 0, l = arr.length; i < l; i++) {
	    item = arr[i];
	    val = item && item.$value || item;
	    j = keys.length;
	    if (j) {
	      while (j--) {
	        key = keys[j];
	        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {
	          res.push(item);
	          break;
	        }
	      }
	    } else if (contains(item, search)) {
	      res.push(item);
	    }
	  }
	  return res;
	}

	/**
	 * Filter filter for arrays
	 *
	 * @param {String} sortKey
	 * @param {String} reverse
	 */

	function orderBy(arr, sortKey, reverse) {
	  arr = convertArray(arr);
	  if (!sortKey) {
	    return arr;
	  }
	  var order = reverse && reverse < 0 ? -1 : 1;
	  // sort on a copy to avoid mutating original array
	  return arr.slice().sort(function (a, b) {
	    if (sortKey !== '$key') {
	      if (isObject(a) && '$value' in a) a = a.$value;
	      if (isObject(b) && '$value' in b) b = b.$value;
	    }
	    a = isObject(a) ? getPath(a, sortKey) : a;
	    b = isObject(b) ? getPath(b, sortKey) : b;
	    return a === b ? 0 : a > b ? order : -order;
	  });
	}

	/**
	 * String contain helper
	 *
	 * @param {*} val
	 * @param {String} search
	 */

	function contains(val, search) {
	  var i;
	  if (isPlainObject(val)) {
	    var keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      if (contains(val[keys[i]], search)) {
	        return true;
	      }
	    }
	  } else if (isArray(val)) {
	    i = val.length;
	    while (i--) {
	      if (contains(val[i], search)) {
	        return true;
	      }
	    }
	  } else if (val != null) {
	    return val.toString().toLowerCase().indexOf(search) > -1;
	  }
	}

	var digitsRE = /(\d{3})(?=\d)/g;

	// asset collections must be a plain object.
	var filters = {

	  orderBy: orderBy,
	  filterBy: filterBy,
	  limitBy: limitBy,

	  /**
	   * Stringify value.
	   *
	   * @param {Number} indent
	   */

	  json: {
	    read: function read(value, indent) {
	      return typeof value === 'string' ? value : JSON.stringify(value, null, Number(indent) || 2);
	    },
	    write: function write(value) {
	      try {
	        return JSON.parse(value);
	      } catch (e) {
	        return value;
	      }
	    }
	  },

	  /**
	   * 'abc' => 'Abc'
	   */

	  capitalize: function capitalize(value) {
	    if (!value && value !== 0) return '';
	    value = value.toString();
	    return value.charAt(0).toUpperCase() + value.slice(1);
	  },

	  /**
	   * 'abc' => 'ABC'
	   */

	  uppercase: function uppercase(value) {
	    return value || value === 0 ? value.toString().toUpperCase() : '';
	  },

	  /**
	   * 'AbC' => 'abc'
	   */

	  lowercase: function lowercase(value) {
	    return value || value === 0 ? value.toString().toLowerCase() : '';
	  },

	  /**
	   * 12345 => $12,345.00
	   *
	   * @param {String} sign
	   */

	  currency: function currency(value, _currency) {
	    value = parseFloat(value);
	    if (!isFinite(value) || !value && value !== 0) return '';
	    _currency = _currency != null ? _currency : '$';
	    var stringified = Math.abs(value).toFixed(2);
	    var _int = stringified.slice(0, -3);
	    var i = _int.length % 3;
	    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
	    var _float = stringified.slice(-3);
	    var sign = value < 0 ? '-' : '';
	    return _currency + sign + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
	  },

	  /**
	   * 'item' => 'items'
	   *
	   * @params
	   *  an array of strings corresponding to
	   *  the single, double, triple ... forms of the word to
	   *  be pluralized. When the number to be pluralized
	   *  exceeds the length of the args, it will use the last
	   *  entry in the array.
	   *
	   *  e.g. ['single', 'double', 'triple', 'multiple']
	   */

	  pluralize: function pluralize(value) {
	    var args = toArray(arguments, 1);
	    return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');
	  },

	  /**
	   * Debounce a handler function.
	   *
	   * @param {Function} handler
	   * @param {Number} delay = 300
	   * @return {Function}
	   */

	  debounce: function debounce(handler, delay) {
	    if (!handler) return;
	    if (!delay) {
	      delay = 300;
	    }
	    return _debounce(handler, delay);
	  }
	};

	var partial = {

	  priority: 1750,

	  params: ['name'],

	  // watch changes to name for dynamic partials
	  paramWatchers: {
	    name: function name(value) {
	      vIf.remove.call(this);
	      if (value) {
	        this.insert(value);
	      }
	    }
	  },

	  bind: function bind() {
	    this.anchor = createAnchor('v-partial');
	    replace(this.el, this.anchor);
	    this.insert(this.params.name);
	  },

	  insert: function insert(id) {
	    var partial = resolveAsset(this.vm.$options, 'partials', id);
	    if (false) {
	      assertAsset(partial, 'partial', id);
	    }
	    if (partial) {
	      this.factory = new FragmentFactory(this.vm, partial);
	      vIf.insert.call(this);
	    }
	  },

	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	  }
	};

	// This is the elementDirective that handles <content>
	// transclusions. It relies on the raw content of an
	// instance being stored as `$options._content` during
	// the transclude phase.

	var slot = {

	  priority: 1750,

	  params: ['name'],

	  bind: function bind() {
	    var host = this.vm;
	    var raw = host.$options._content;
	    var content;
	    if (!raw) {
	      this.fallback();
	      return;
	    }
	    var context = host._context;
	    var slotName = this.params.name;
	    if (!slotName) {
	      // Default content
	      var self = this;
	      var compileDefaultContent = function compileDefaultContent() {
	        self.compile(extractFragment(raw.childNodes, raw, true), context, host);
	      };
	      if (!host._isCompiled) {
	        // defer until the end of instance compilation,
	        // because the default outlet must wait until all
	        // other possible outlets with selectors have picked
	        // out their contents.
	        host.$once('hook:compiled', compileDefaultContent);
	      } else {
	        compileDefaultContent();
	      }
	    } else {
	      var selector = '[slot="' + slotName + '"]';
	      var nodes = raw.querySelectorAll(selector);
	      if (nodes.length) {
	        content = extractFragment(nodes, raw);
	        if (content.hasChildNodes()) {
	          this.compile(content, context, host);
	        } else {
	          this.fallback();
	        }
	      } else {
	        this.fallback();
	      }
	    }
	  },

	  fallback: function fallback() {
	    this.compile(extractContent(this.el, true), this.vm);
	  },

	  compile: function compile(content, context, host) {
	    if (content && context) {
	      var scope = host ? host._scope : this._scope;
	      this.unlink = context.$compile(content, host, scope, this._frag);
	    }
	    if (content) {
	      replace(this.el, content);
	    } else {
	      remove(this.el);
	    }
	  },

	  unbind: function unbind() {
	    if (this.unlink) {
	      this.unlink();
	    }
	  }
	};

	/**
	 * Extract qualified content nodes from a node list.
	 *
	 * @param {NodeList} nodes
	 * @param {Element} parent
	 * @param {Boolean} main
	 * @return {DocumentFragment}
	 */

	function extractFragment(nodes, parent, main) {
	  var frag = document.createDocumentFragment();
	  for (var i = 0, l = nodes.length; i < l; i++) {
	    var node = nodes[i];
	    // if this is the main outlet, we want to skip all
	    // previously selected nodes;
	    // otherwise, we want to mark the node as selected.
	    // clone the node so the original raw content remains
	    // intact. this ensures proper re-compilation in cases
	    // where the outlet is inside a conditional block
	    if (main && !node.__v_selected) {
	      append(node);
	    } else if (!main && node.parentNode === parent) {
	      node.__v_selected = true;
	      append(node);
	    }
	  }
	  return frag;

	  function append(node) {
	    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
	      node = parseTemplate(node);
	    }
	    node = cloneNode(node);
	    frag.appendChild(node);
	  }
	}

	var elementDirectives = {
	  slot: slot,
	  partial: partial
	};

	Vue.version = '1.0.10';

	/**
	 * Vue and every constructor that extends Vue has an
	 * associated options object, which can be accessed during
	 * compilation steps as `this.constructor.options`.
	 *
	 * These can be seen as the default options of every
	 * Vue instance.
	 */

	Vue.options = {
	  directives: publicDirectives,
	  elementDirectives: elementDirectives,
	  filters: filters,
	  transitions: {},
	  components: {},
	  partials: {},
	  replace: true
	};

	// devtools global hook
	/* istanbul ignore if */
	if (false) {
	  if (inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {
	    window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('init', Vue);
	  }
	}

	module.exports = Vue;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _keys = __webpack_require__(14);

	var _keys2 = _interopRequireDefault(_keys);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Vue = __webpack_require__(12);
	var THREE = __webpack_require__(26);
	var chassis = __webpack_require__(27);
	var wheels = __webpack_require__(28);
	var position = __webpack_require__(29);

	function toHSLObject(colorString) {
	  var color = new THREE.Color(colorString);
	  var hsl = color.getHSL();
	  return {
	    h: hsl.h,
	    s: hsl.s * 100 + '%',
	    l: hsl.l * 100 + '%'
	  };
	}

	window.store = module.exports = new Vue({
	  data: {
	    music: false,
	    rotation: true,
	    hoverEnabled: true,
	    hoverPartName: null,
	    currentPartName: null,
	    situation: 'garage',
	    chassis: {
	      name: '',
	      offsetY: 30,
	      parts: null
	    },
	    wheels: {
	      name: '',
	      offsetX: 0,
	      offsetZ: 0,
	      parts: null
	    }
	  },
	  computed: {
	    currentPart: function currentPart() {
	      return this.chassis.parts[this.currentPartName] || this.wheels.parts[this.currentPartName] || null;
	    }
	  },
	  watch: {
	    'chassis.name': function chassisName(name) {
	      var chassisParts = {};
	      var partsData = chassis[name];

	      (0, _keys2.default)(partsData).sort().forEach(function (partName) {
	        var partData = partsData[partName];
	        chassisParts[partName] = {
	          name: partName,
	          area: partData.area,
	          choice: partData.choices[0],
	          color: toHSLObject(partData.color),
	          material: partData.material,
	          all: partData.all,
	          set: partData.set
	        };
	      });

	      this.chassis.parts = chassisParts;
	      this.chassis.offsetY = 30;
	      this.wheels.offsetX = Math.abs(position[name].wheels[0]);
	      this.wheels.offsetZ = Math.abs(position[name].wheels[1]);
	    },
	    'wheels.name': function wheelsName(name) {
	      var wheelsParts = {};
	      var partsData = wheels[name];

	      (0, _keys2.default)(partsData).sort().forEach(function (partName) {
	        var partData = partsData[partName];
	        wheelsParts[partName] = {
	          name: partName,
	          area: partData.area,
	          choice: partData.choices[0],
	          color: toHSLObject(partData.color),
	          material: partData.material,
	          all: partData.all,
	          set: partData.set
	        };
	      });
	      this.wheels.parts = wheelsParts;
	    }
	  },
	  created: function created() {
	    this.chassis.name = 'a3';
	    this.wheels.name = '19';
	  }
	});
	/**
	 * part 格式
	 * {
	 *   name: 'spoiler',
	 *   choice: 'spoiler2',
	 *   set: true,
	 *   color: '',
	 *   reflectivity: 0
	 * }
	 */

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(15), __esModule: true };

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(16);
	module.exports = __webpack_require__(22).Object.keys;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(17);

	__webpack_require__(19)('keys', function($keys){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(18);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 18 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(20)
	  , core    = __webpack_require__(22)
	  , fails   = __webpack_require__(25);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(21)
	  , core      = __webpack_require__(22)
	  , ctx       = __webpack_require__(23)
	  , PROTOTYPE = 'prototype';

	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && key in target;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(param){
	        return this instanceof C ? new C(param) : C(param);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
	  }
	};
	// type bitmap
	$export.F = 1;  // forced
	$export.G = 2;  // global
	$export.S = 4;  // static
	$export.P = 8;  // proto
	$export.B = 16; // bind
	$export.W = 32; // wrap
	module.exports = $export;

/***/ },
/* 21 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 22 */
/***/ function(module, exports) {

	var core = module.exports = {version: '1.2.6'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(24);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 25 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// File:src/Three.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var THREE = { REVISION: '72' };

	//

	if ( true ) {

			!(__WEBPACK_AMD_DEFINE_FACTORY__ = (THREE), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

			module.exports = THREE;

	}


	// polyfills

	if ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {

		// Missing in Android stock browser.

		( function () {

			var lastTime = 0;
			var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

			for ( var x = 0; x < vendors.length && ! self.requestAnimationFrame; ++ x ) {

				self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
				self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

			}

			if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {

				self.requestAnimationFrame = function ( callback ) {

					var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
					var id = self.setTimeout( function () {

						callback( currTime + timeToCall );

					}, timeToCall );
					lastTime = currTime + timeToCall;
					return id;

				};

			}

			if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {

				self.cancelAnimationFrame = function ( id ) {

					self.clearTimeout( id );

				};

			}

		}() );

	}

	if ( Math.sign === undefined ) {

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function ( x ) {

			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

		};

	}

	if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

		// Missing in IE9-11.
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

		Object.defineProperty( Function.prototype, 'name', {

			get: function () {

				return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

			}

		} );

	}

	// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

	THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

	// GL STATE CONSTANTS

	THREE.CullFaceNone = 0;
	THREE.CullFaceBack = 1;
	THREE.CullFaceFront = 2;
	THREE.CullFaceFrontBack = 3;

	THREE.FrontFaceDirectionCW = 0;
	THREE.FrontFaceDirectionCCW = 1;

	// SHADOWING TYPES

	THREE.BasicShadowMap = 0;
	THREE.PCFShadowMap = 1;
	THREE.PCFSoftShadowMap = 2;

	// MATERIAL CONSTANTS

	// side

	THREE.FrontSide = 0;
	THREE.BackSide = 1;
	THREE.DoubleSide = 2;

	// shading

	THREE.FlatShading = 1;
	THREE.SmoothShading = 2;

	// colors

	THREE.NoColors = 0;
	THREE.FaceColors = 1;
	THREE.VertexColors = 2;

	// blending modes

	THREE.NoBlending = 0;
	THREE.NormalBlending = 1;
	THREE.AdditiveBlending = 2;
	THREE.SubtractiveBlending = 3;
	THREE.MultiplyBlending = 4;
	THREE.CustomBlending = 5;

	// custom blending equations
	// (numbers start from 100 not to clash with other
	// mappings to OpenGL constants defined in Texture.js)

	THREE.AddEquation = 100;
	THREE.SubtractEquation = 101;
	THREE.ReverseSubtractEquation = 102;
	THREE.MinEquation = 103;
	THREE.MaxEquation = 104;

	// custom blending destination factors

	THREE.ZeroFactor = 200;
	THREE.OneFactor = 201;
	THREE.SrcColorFactor = 202;
	THREE.OneMinusSrcColorFactor = 203;
	THREE.SrcAlphaFactor = 204;
	THREE.OneMinusSrcAlphaFactor = 205;
	THREE.DstAlphaFactor = 206;
	THREE.OneMinusDstAlphaFactor = 207;

	// custom blending source factors

	//THREE.ZeroFactor = 200;
	//THREE.OneFactor = 201;
	//THREE.SrcAlphaFactor = 204;
	//THREE.OneMinusSrcAlphaFactor = 205;
	//THREE.DstAlphaFactor = 206;
	//THREE.OneMinusDstAlphaFactor = 207;
	THREE.DstColorFactor = 208;
	THREE.OneMinusDstColorFactor = 209;
	THREE.SrcAlphaSaturateFactor = 210;

	// depth modes

	THREE.NeverDepth = 0;
	THREE.AlwaysDepth = 1;
	THREE.LessDepth = 2;
	THREE.LessEqualDepth = 3;
	THREE.EqualDepth = 4;
	THREE.GreaterEqualDepth = 5;
	THREE.GreaterDepth = 6;
	THREE.NotEqualDepth = 7;


	// TEXTURE CONSTANTS

	THREE.MultiplyOperation = 0;
	THREE.MixOperation = 1;
	THREE.AddOperation = 2;

	// Mapping modes

	THREE.UVMapping = 300;

	THREE.CubeReflectionMapping = 301;
	THREE.CubeRefractionMapping = 302;

	THREE.EquirectangularReflectionMapping = 303;
	THREE.EquirectangularRefractionMapping = 304;

	THREE.SphericalReflectionMapping = 305;

	// Wrapping modes

	THREE.RepeatWrapping = 1000;
	THREE.ClampToEdgeWrapping = 1001;
	THREE.MirroredRepeatWrapping = 1002;

	// Filters

	THREE.NearestFilter = 1003;
	THREE.NearestMipMapNearestFilter = 1004;
	THREE.NearestMipMapLinearFilter = 1005;
	THREE.LinearFilter = 1006;
	THREE.LinearMipMapNearestFilter = 1007;
	THREE.LinearMipMapLinearFilter = 1008;

	// Data types

	THREE.UnsignedByteType = 1009;
	THREE.ByteType = 1010;
	THREE.ShortType = 1011;
	THREE.UnsignedShortType = 1012;
	THREE.IntType = 1013;
	THREE.UnsignedIntType = 1014;
	THREE.FloatType = 1015;
	THREE.HalfFloatType = 1025;

	// Pixel types

	//THREE.UnsignedByteType = 1009;
	THREE.UnsignedShort4444Type = 1016;
	THREE.UnsignedShort5551Type = 1017;
	THREE.UnsignedShort565Type = 1018;

	// Pixel formats

	THREE.AlphaFormat = 1019;
	THREE.RGBFormat = 1020;
	THREE.RGBAFormat = 1021;
	THREE.LuminanceFormat = 1022;
	THREE.LuminanceAlphaFormat = 1023;
	// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
	THREE.RGBEFormat = THREE.RGBAFormat; //1024;

	// DDS / ST3C Compressed texture formats

	THREE.RGB_S3TC_DXT1_Format = 2001;
	THREE.RGBA_S3TC_DXT1_Format = 2002;
	THREE.RGBA_S3TC_DXT3_Format = 2003;
	THREE.RGBA_S3TC_DXT5_Format = 2004;


	// PVRTC compressed texture formats

	THREE.RGB_PVRTC_4BPPV1_Format = 2100;
	THREE.RGB_PVRTC_2BPPV1_Format = 2101;
	THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
	THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


	// DEPRECATED

	THREE.Projector = function () {

		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

		this.projectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );

		};

		this.unprojectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );

		};

		this.pickingRay = function ( vector, camera ) {

			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

		};

	};

	THREE.CanvasRenderer = function () {

		console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

		this.domElement = document.createElement( 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};

	};

	// File:src/math/Color.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Color = function ( color ) {

		if ( arguments.length === 3 ) {

			return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

		}

		return this.set( color );

	};

	THREE.Color.prototype = {

		constructor: THREE.Color,

		r: 1, g: 1, b: 1,

		set: function ( value ) {

			if ( value instanceof THREE.Color ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		},

		setHex: function ( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		},

		setRGB: function ( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		},

		setHSL: function () {

			function hue2rgb ( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			}

			return function ( h, s, l ) {

				// h,s,l ranges are in 0.0 - 1.0
				h = THREE.Math.euclideanModulo( h, 1 );
				s = THREE.Math.clamp( s, 0, 1 );
				l = THREE.Math.clamp( l, 0, 1 );

				if ( s === 0 ) {

					this.r = this.g = this.b = l;

				} else {

					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;

					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );

				}

				return this;

			};

		}(),

		setStyle: function ( style ) {

			var parseAlpha = function ( strAlpha ) {

				var alpha = parseFloat( strAlpha );

				if ( alpha < 1 ) {

					console.warn( 'THREE.Color: Alpha component of color ' + style + ' will be ignored.' );

				}

				return alpha;

			}


			var m;

			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];

				switch ( name ) {

					case 'rgb':

						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*$/.exec( components ) ) {

							// rgb(255,0,0)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

							return this;

						}

						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*$/.exec( components ) ) {

							// rgb(100%,0%,0%)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

							return this;

						}

						break;

					case 'rgba':

						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

							// rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
							parseAlpha( color[ 4 ] );

							return this;

						}

						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

							// rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
							parseAlpha( color[ 4 ] );

							return this;

						}

						break;

					case 'hsl':

						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*$/.exec( components ) ) {

							// hsl(120,50%,50%)
							var h = parseFloat( color[ 1 ] );
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;

							return this.setHSL( h, s, l );

						}

						break;

					case 'hsla':

						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*([0-9]*\.?[0-9]+)\s*$/.exec( components ) ) {

							// hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] );
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;
							parseAlpha( color[ 4 ] );

							return this.setHSL( h, s, l );

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

				// hex color

				var hex = m[ 1 ];
				var size = hex.length;

				if ( size === 3 ) {

					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

					return this;

				} else if ( size === 6 ) {

					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

					return this;

				}

			}

			if ( style && style.length > 0 ) {

				// color keywords
				var hex = THREE.ColorKeywords[ style ];

				if ( hex !== undefined ) {

					// red
					this.setHex( hex );

				} else {

					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );

				}

			}

			return this;

		},

		clone: function () {

			return new this.constructor( this.r, this.g, this.b );

		},

		copy: function ( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		},

		copyGammaToLinear: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );

			return this;

		},

		copyLinearToGamma: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );

			return this;

		},

		convertGammaToLinear: function () {

			var r = this.r, g = this.g, b = this.b;

			this.r = r * r;
			this.g = g * g;
			this.b = b * b;

			return this;

		},

		convertLinearToGamma: function () {

			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );

			return this;

		},

		getHex: function () {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		},

		getHexString: function () {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		},

		getHSL: function ( optionalTarget ) {

			// h,s,l ranges are in 0.0 - 1.0

			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;

			return hsl;

		},

		getStyle: function () {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		},

		offsetHSL: function ( h, s, l ) {

			var hsl = this.getHSL();

			hsl.h += h; hsl.s += s; hsl.l += l;

			this.setHSL( hsl.h, hsl.s, hsl.l );

			return this;

		},

		add: function ( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		},

		addColors: function ( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		},

		addScalar: function ( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		},

		multiply: function ( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		},

		lerp: function ( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		},

		equals: function ( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		},

		fromArray: function ( array ) {

			this.r = array[ 0 ];
			this.g = array[ 1 ];
			this.b = array[ 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		}

	};

	THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	// File:src/math/Quaternion.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Quaternion = function ( x, y, z, w ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;

	};

	THREE.Quaternion.prototype = {

		constructor: THREE.Quaternion,

		get x () {

			return this._x;

		},

		set x ( value ) {

			this._x = value;
			this.onChangeCallback();

		},

		get y () {

			return this._y;

		},

		set y ( value ) {

			this._y = value;
			this.onChangeCallback();

		},

		get z () {

			return this._z;

		},

		set z ( value ) {

			this._z = value;
			this.onChangeCallback();

		},

		get w () {

			return this._w;

		},

		set w ( value ) {

			this._w = value;
			this.onChangeCallback();

		},

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._w );

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this.onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( euler instanceof THREE.Euler === false ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var c1 = Math.cos( euler._x / 2 );
			var c2 = Math.cos( euler._y / 2 );
			var c3 = Math.cos( euler._z / 2 );
			var s1 = Math.sin( euler._x / 2 );
			var s2 = Math.sin( euler._y / 2 );
			var s3 = Math.sin( euler._z / 2 );

			var order = euler.order;

			if ( order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this.onChangeCallback();

			return this;

		},

		setFromUnitVectors: function () {

			// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

			// assumes direction vectors vFrom and vTo are normalized

			var v1, r;

			var EPS = 0.000001;

			return function ( vFrom, vTo ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				r = vFrom.dot( vTo ) + 1;

				if ( r < EPS ) {

					r = 0;

					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

						v1.set( - vFrom.y, vFrom.x, 0 );

					} else {

						v1.set( 0, - vFrom.z, vFrom.y );

					}

				} else {

					v1.crossVectors( vFrom, vTo );

				}

				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;

				this.normalize();

				return this;

			}

		}(),

		inverse: function () {

			this.conjugate().normalize();

			return this;

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this.onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this.onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this.onChangeCallback();

			return this;

		},

		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var halfTheta = Math.acos( cosHalfTheta );
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

			if ( Math.abs( sinHalfTheta ) < 0.001 ) {

				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );

				return this;

			}

			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this.onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	};

	THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	};

	// File:src/math/Vector2.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.Vector2 = function ( x, y ) {

		this.x = x || 0;
		this.y = y || 0;

	};

	THREE.Vector2.prototype = {

		constructor: THREE.Vector2,

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.x *= s;
			this.y *= s;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;

			}

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector2();
					max = new THREE.Vector2();

				}

				min.set( minVal, minVal );
				max.set( maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		lengthManhattan: function() {

			return Math.abs( this.x ) + Math.abs( this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength ) {

				this.multiplyScalar( l / oldLength );

			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];

			return this;

		}

	};

	// File:src/math/Vector3.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Vector3 = function ( x, y, z ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	};

	THREE.Vector3.prototype = {

		constructor: THREE.Vector3,

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function () {

			var quaternion;

			return function applyEuler( euler ) {

				if ( euler instanceof THREE.Euler === false ) {

					console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

				}

				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

				this.applyQuaternion( quaternion.setFromEuler( euler ) );

				return this;

			};

		}(),

		applyAxisAngle: function () {

			var quaternion;

			return function applyAxisAngle( axis, angle ) {

				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

				this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

				return this;

			};

		}(),

		applyMatrix3: function ( m ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyMatrix4: function ( m ) {

			// input: THREE.Matrix4 affine matrix

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

			return this;

		},

		applyProjection: function ( m ) {

			// input: THREE.Matrix4 projection matrix

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;
			var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;

			var qx = q.x;
			var qy = q.y;
			var qz = q.z;
			var qw = q.w;

			// calculate quat * vector

			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function () {

			var matrix;

			return function project( camera ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyProjection( matrix );

			};

		}(),

		unproject: function () {

			var matrix;

			return function unproject( camera ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyProjection( matrix );

			};

		}(),

		transformDirection: function ( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			this.normalize();

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;
				this.z = 0;

			}

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			if ( this.z > v.z ) {

				this.z = v.z;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			if ( this.z < v.z ) {

				this.z = v.z;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			if ( this.z < min.z ) {

				this.z = min.z;

			} else if ( this.z > max.z ) {

				this.z = max.z;

			}

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector3();
					max = new THREE.Vector3();

				}

				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		lengthManhattan: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength  ) {

				this.multiplyScalar( l / oldLength );

			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			var x = this.x, y = this.y, z = this.z;

			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;

			return this;

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function () {

			var v1, dot;

			return function projectOnVector( vector ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				v1.copy( vector ).normalize();

				dot = this.dot( v1 );

				return this.copy( v1 ).multiplyScalar( dot );

			};

		}(),

		projectOnPlane: function () {

			var v1;

			return function projectOnPlane( planeNormal ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				v1.copy( this ).projectOnVector( planeNormal );

				return this.sub( v1 );

			}

		}(),

		reflect: function () {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			var v1;

			return function reflect( normal ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

			}

		}(),

		angleTo: function ( v ) {

			var theta = this.dot( v ) / ( this.length() * v.length() );

			// clamp, to handle numerical problems

			return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x;
			var dy = this.y - v.y;
			var dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		setEulerFromRotationMatrix: function ( m, order ) {

			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

		},

		setEulerFromQuaternion: function ( q, order ) {

			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

		},

		getPositionFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

			return this.setFromMatrixPosition( m );

		},

		getScaleFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

			return this.setFromMatrixScale( m );

		},

		getColumnFromMatrix: function ( index, matrix ) {

			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

			return this.setFromMatrixColumn( index, matrix );

		},

		setFromMatrixPosition: function ( m ) {

			this.x = m.elements[ 12 ];
			this.y = m.elements[ 13 ];
			this.z = m.elements[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
			var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
			var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function ( index, matrix ) {

			var offset = index * 4;

			var me = matrix.elements;

			this.x = me[ offset ];
			this.y = me[ offset + 1 ];
			this.z = me[ offset + 2 ];

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];

			return this;

		}

	};

	// File:src/math/Vector4.js

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Vector4 = function ( x, y, z, w ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;

	};

	THREE.Vector4.prototype = {

		constructor: THREE.Vector4,

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z, this.w );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;
			var w = this.w;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;
				this.w *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 1;

			}

			return this;

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				 this.x = 1;
				 this.y = 0;
				 this.z = 0;

			} else {

				 this.x = q.x / s;
				 this.y = q.y / s;
				 this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon )
			   && ( Math.abs( m13 - m31 ) < epsilon )
			   && ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 )
				   && ( Math.abs( m13 + m31 ) < epsilon2 )
				   && ( Math.abs( m23 + m32 ) < epsilon2 )
				   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
							  + ( m13 - m31 ) * ( m13 - m31 )
							  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			if ( this.z > v.z ) {

				this.z = v.z;

			}

			if ( this.w > v.w ) {

				this.w = v.w;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			if ( this.z < v.z ) {

				this.z = v.z;

			}

			if ( this.w < v.w ) {

				this.w = v.w;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			if ( this.z < min.z ) {

				this.z = min.z;

			} else if ( this.z > max.z ) {

				this.z = max.z;

			}

			if ( this.w < min.w ) {

				this.w = min.w;

			} else if ( this.w > max.w ) {

				this.w = max.w;

			}

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector4();
					max = new THREE.Vector4();

				}

				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		lengthManhattan: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength ) {

				this.multiplyScalar( l / oldLength );

			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
			this.w = attribute.array[ index + 3 ];

			return this;

		}

	};

	// File:src/math/Euler.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Euler = function ( x, y, z, order ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || THREE.Euler.DefaultOrder;

	};

	THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	THREE.Euler.DefaultOrder = 'XYZ';

	THREE.Euler.prototype = {

		constructor: THREE.Euler,

		get x () {

			return this._x;

		},

		set x ( value ) {

			this._x = value;
			this.onChangeCallback();

		},

		get y () {

			return this._y;

		},

		set y ( value ) {

			this._y = value;
			this.onChangeCallback();

		},

		get z () {

			return this._z;

		},

		set z ( value ) {

			this._z = value;
			this.onChangeCallback();

		},

		get order () {

			return this._order;

		},

		set order ( value ) {

			this._order = value;
			this.onChangeCallback();

		},

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._order);

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = THREE.Math.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.99999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.99999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

			}

			this._order = order;

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromQuaternion: function () {

			var matrix;

			return function ( q, order, update ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();
				matrix.makeRotationFromQuaternion( q );
				this.setFromRotationMatrix( matrix, order, update );

				return this;

			};

		}(),

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function () {

			// WARNING: this discards revolution information -bhouston

			var q = new THREE.Quaternion();

			return function ( newOrder ) {

				q.setFromEuler( this );
				this.setFromQuaternion( q, newOrder );

			};

		}(),

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new THREE.Vector3( this._x, this._y, this._z );

			}

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	};

	// File:src/math/Line3.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Line3 = function ( start, end ) {

		this.start = ( start !== undefined ) ? start : new THREE.Vector3();
		this.end = ( end !== undefined ) ? end : new THREE.Vector3();

	};

	THREE.Line3.prototype = {

		constructor: THREE.Line3,

		set: function ( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		},

		delta: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.end, this.start );

		},

		distanceSq: function () {

			return this.start.distanceToSquared( this.end );

		},

		distance: function () {

			return this.start.distanceTo( this.end );

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		closestPointToPointParameter: function () {

			var startP = new THREE.Vector3();
			var startEnd = new THREE.Vector3();

			return function ( point, clampToLine ) {

				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );

				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );

				var t = startEnd_startP / startEnd2;

				if ( clampToLine ) {

					t = THREE.Math.clamp( t, 0, 1 );

				}

				return t;

			};

		}(),

		closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

			var t = this.closestPointToPointParameter( point, clampToLine );

			var result = optionalTarget || new THREE.Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		applyMatrix4: function ( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		},

		equals: function ( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		}

	};

	// File:src/math/Box2.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Box2 = function ( min, max ) {

		this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

	};

	THREE.Box2.prototype = {

		constructor: THREE.Box2,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] )

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new THREE.Vector2();

			return function ( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),
		
		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		},

		empty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		size: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ) {

				return false;

			}

			return true;

		},

		containsBox: function ( box ) {

			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

				return true;

			}

			return false;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new THREE.Vector2();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		},

		isIntersectionBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.

			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ) {

				return false;

			}

			return true;

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector2();

			return function ( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	};

	// File:src/math/Box3.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Box3 = function ( min, max ) {

		this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

	};

	THREE.Box3.prototype = {

		constructor: THREE.Box3,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new THREE.Vector3();

			return function ( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		setFromObject: function () {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			var v1 = new THREE.Vector3();

			return function ( object ) {

				var scope = this;

				object.updateMatrixWorld( true );

				this.makeEmpty();

				object.traverse( function ( node ) {

					var geometry = node.geometry;

					if ( geometry !== undefined ) {

						if ( geometry instanceof THREE.Geometry ) {

							var vertices = geometry.vertices;

							for ( var i = 0, il = vertices.length; i < il; i ++ ) {

								v1.copy( vertices[ i ] );

								v1.applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

							var positions = geometry.attributes[ 'position' ].array;

							for ( var i = 0, il = positions.length; i < il; i += 3 ) {

								v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

								v1.applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				} );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = this.min.z = Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		},

		empty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		size: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ||
			     point.z < this.min.z || point.z > this.max.z ) {

				return false;

			}

			return true;

		},

		containsBox: function ( box ) {

			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
				 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

				return true;

			}

			return false;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new THREE.Vector3();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		},

		isIntersectionBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.

			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ||
			     box.max.z < this.min.z || box.min.z > this.max.z ) {

				return false;

			}

			return true;

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector3();

			return function ( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		getBoundingSphere: function () {

			var v1 = new THREE.Vector3();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Sphere();

				result.center = this.center();
				result.radius = this.size( v1 ).length() * 0.5;

				return result;

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		applyMatrix4: function () {

			var points = [
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3()
			];

			return function ( matrix ) {

				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

				this.makeEmpty();
				this.setFromPoints( points );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	};

	// File:src/math/Matrix3.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Matrix3 = function () {

		this.elements = new Float32Array( [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		] );

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	THREE.Matrix3.prototype = {

		constructor: THREE.Matrix3,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
			te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
			te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new this.constructor().fromArray( this.elements );

		},

		copy: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 3 ], me[ 6 ],
				me[ 1 ], me[ 4 ], me[ 7 ],
				me[ 2 ], me[ 5 ], me[ 8 ]

			);

			return this;

		},

		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );

		},

		multiplyVector3Array: function ( a ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );

		},

		applyToVector3Array: function () {

			var v1;

			return function ( array, offset, length ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;

				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

					v1.fromArray( array, j );
					v1.applyMatrix3( this );
					v1.toArray( array, j );

				}

				return array;

			};

		}(),

		applyToBuffer: function () {

			var v1;

			return function applyToBuffer( buffer, offset, length ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = buffer.length / buffer.itemSize;

				for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

					v1.x = buffer.getX( j );
					v1.y = buffer.getY( j );
					v1.z = buffer.getZ( j );

					v1.applyMatrix3( this );

					buffer.setXYZ( v1.x, v1.y, v1.z );

				}

				return buffer;

			};

		}(),

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnInvertible ) {

			// input: THREE.Matrix4
			// ( based on http://code.google.com/p/webgl-mjs/ )

			var me = matrix.elements;
			var te = this.elements;

			te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
			te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
			te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
			te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
			te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
			te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
			te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
			te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
			te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

			var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

			// no inverse

			if ( det === 0 ) {

				var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

				if ( throwOnInvertible || false ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				this.identity();

				return this;

			}

			this.multiplyScalar( 1.0 / det );

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		flattenToArrayOffset: function ( array, offset ) {

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ]  = te[ 8 ];

			return array;

		},

		getNormalMatrix: function ( m ) {

			// input: THREE.Matrix4

			this.getInverse( m ).transpose();

			return this;

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		fromArray: function ( array ) {

			this.elements.set( array );

			return this;

		},

		toArray: function () {

			var te = this.elements;

			return [
				te[ 0 ], te[ 1 ], te[ 2 ],
				te[ 3 ], te[ 4 ], te[ 5 ],
				te[ 6 ], te[ 7 ], te[ 8 ]
			];

		}

	};

	// File:src/math/Matrix4.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://exocortex.com
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Matrix4 = function () {

		this.elements = new Float32Array( [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		] );

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	THREE.Matrix4.prototype = {

		constructor: THREE.Matrix4,

		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new THREE.Matrix4().fromArray( this.elements );

		},

		copy: function ( m ) {

			this.elements.set( m.elements );

			return this;

		},

		extractPosition: function ( m ) {

			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );

		},

		copyPosition: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			var te = this.elements;

			xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
			yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
			zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

			return this;

		},

		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0,       0,       0,       1
			);

			return this;

		},

		extractRotation: function () {

			var v1;

			return function ( m ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				var te = this.elements;
				var me = m.elements;

				var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
				var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
				var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;

				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;

				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;

				return this;

			};

		}(),

		makeRotationFromEuler: function ( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		setRotationFromQuaternion: function ( q ) {

			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

			return this.makeRotationFromQuaternion( q );

		},

		makeRotationFromQuaternion: function ( q ) {

			var te = this.elements;

			var x = q.x, y = q.y, z = q.z, w = q.w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			te[ 0 ] = 1 - ( yy + zz );
			te[ 4 ] = xy - wz;
			te[ 8 ] = xz + wy;

			te[ 1 ] = xy + wz;
			te[ 5 ] = 1 - ( xx + zz );
			te[ 9 ] = yz - wx;

			te[ 2 ] = xz - wy;
			te[ 6 ] = yz + wx;
			te[ 10 ] = 1 - ( xx + yy );

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		lookAt: function () {

			var x, y, z;

			return function ( eye, target, up ) {

				if ( x === undefined ) x = new THREE.Vector3();
				if ( y === undefined ) y = new THREE.Vector3();
				if ( z === undefined ) z = new THREE.Vector3();

				var te = this.elements;

				z.subVectors( eye, target ).normalize();

				if ( z.length() === 0 ) {

					z.z = 1;

				}

				x.crossVectors( up, z ).normalize();

				if ( x.length() === 0 ) {

					z.x += 0.0001;
					x.crossVectors( up, z ).normalize();

				}

				y.crossVectors( z, x );


				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

				return this;

			};

		}(),

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyToArray: function ( a, b, r ) {

			var te = this.elements;

			this.multiplyMatrices( a, b );

			r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
			r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
			r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
			r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
			return vector.applyProjection( this );

		},

		multiplyVector4: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},

		multiplyVector3Array: function ( a ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );

		},

		applyToVector3Array: function () {

			var v1;

			return function ( array, offset, length ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;

				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

					v1.fromArray( array, j );
					v1.applyMatrix4( this );
					v1.toArray( array, j );

				}

				return array;

			};

		}(),

		applyToBuffer: function () {

			var v1;

			return function applyToBuffer( buffer, offset, length ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = buffer.length / buffer.itemSize;

				for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

					v1.x = buffer.getX( j );
					v1.y = buffer.getY( j );
					v1.z = buffer.getZ( j );

					v1.applyMatrix4( this );

					buffer.setXYZ( v1.x, v1.y, v1.z );

				}

				return buffer;

			};

		}(),

		rotateAxis: function ( v ) {

			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

			v.transformDirection( this );

		},

		crossVector: function ( vector ) {

			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		flattenToArrayOffset: function ( array, offset ) {

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ]  = te[ 8 ];
			array[ offset + 9 ]  = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		},

		getPosition: function () {

			var v1;

			return function () {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

				var te = this.elements;
				return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

			};

		}(),

		setPosition: function ( v ) {

			var te = this.elements;

			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;

			return this;

		},

		getInverse: function ( m, throwOnInvertible ) {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements;
			var me = m.elements;

			var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
			var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
			var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
			var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

			te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
			te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
			te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
			te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
			te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
			te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
			te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
			te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
			te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
			te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
			te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
			te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
			te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
			te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
			te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

			var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

			if ( det === 0 ) {

				var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

				if ( throwOnInvertible || false ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				this.identity();

				return this;

			}

			this.multiplyScalar( 1 / det );

			return this;

		},

		translate: function ( v ) {

			console.error( 'THREE.Matrix4: .translate() has been removed.' );

		},

		rotateX: function ( angle ) {

			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

		},

		rotateY: function ( angle ) {

			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

		},

		rotateZ: function ( angle ) {

			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

		},

		rotateByAxis: function ( axis, angle ) {

			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0,  0, 0,
				0, c, - s, 0,
				0, s,  c, 0,
				0, 0,  0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s,  c, 0, 0,
				0,  0, 1, 0,
				0,  0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );

			return this;

		},

		decompose: function () {

			var vector, matrix;

			return function ( position, quaternion, scale ) {

				if ( vector === undefined ) vector = new THREE.Vector3();
				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				var te = this.elements;

				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) {

					sx = - sx;

				}

				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];

				// scale the rotation part

				matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;

				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;

				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;

				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;

				quaternion.setFromRotationMatrix( matrix );

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;

			};

		}(),

		makeFrustum: function ( left, right, bottom, top, near, far ) {

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makePerspective: function ( fov, aspect, near, far ) {

			var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
			var ymin = - ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;

			return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = right - left;
			var h = top - bottom;
			var p = far - near;

			var x = ( right + left ) / w;
			var y = ( top + bottom ) / h;
			var z = ( far + near ) / p;

			te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array ) {

			this.elements.set( array );

			return this;

		},

		toArray: function () {

			var te = this.elements;

			return [
				te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
				te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
				te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
				te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
			];

		}

	};

	// File:src/math/Ray.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Ray = function ( origin, direction ) {

		this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
		this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

	};

	THREE.Ray.prototype = {

		constructor: THREE.Ray,

		set: function ( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		},

		recast: function () {

			var v1 = new THREE.Vector3();

			return function ( t ) {

				this.origin.copy( this.at( t, v1 ) );

				return this;

			};

		}(),

		closestPointToPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );

			if ( directionDistance < 0 ) {

				return result.copy( this.origin );

			}

			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		},

		distanceToPoint: function ( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		},

		distanceSqToPoint: function () {

			var v1 = new THREE.Vector3();

			return function ( point ) {

				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

				// point behind the ray

				if ( directionDistance < 0 ) {

					return this.origin.distanceToSquared( point );

				}

				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

				return v1.distanceToSquared( point );

			};

		}(),

		distanceSqToSegment: function () {

			var segCenter = new THREE.Vector3();
			var segDir = new THREE.Vector3();
			var diff = new THREE.Vector3();

			return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

				// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment

				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );

				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;

				if ( det > 0 ) {

					// The ray and segment are not parallel.

					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;

					if ( s0 >= 0 ) {

						if ( s1 >= - extDet ) {

							if ( s1 <= extDet ) {

								// region 0
								// Minimum at interior points of ray and segment.

								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

							} else {

								// region 1

								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							// region 5

							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						if ( s1 <= - extDet ) {

							// region 4

							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						} else if ( s1 <= extDet ) {

							// region 3

							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;

						} else {

							// region 2

							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					}

				} else {

					// Ray and segment are parallel.

					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

				if ( optionalPointOnRay ) {

					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

				}

				if ( optionalPointOnSegment ) {

					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

				}

				return sqrDist;

			};

		}(),


		isIntersectionSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) <= sphere.radius;

		},

		intersectSphere: function () {

			// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

			var v1 = new THREE.Vector3();

			return function ( sphere, optionalTarget ) {

				v1.subVectors( sphere.center, this.origin );

				var tca = v1.dot( this.direction );

				var d2 = v1.dot( v1 ) - tca * tca;

				var radius2 = sphere.radius * sphere.radius;

				if ( d2 > radius2 ) return null;

				var thc = Math.sqrt( radius2 - d2 );

				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, optionalTarget );

				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, optionalTarget );

			}

		}(),

		isIntersectionPlane: function ( plane ) {

			// check if the ray lies on the plane first

			var distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			var denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		},

		distanceToPlane: function ( plane ) {

			var denominator = plane.normal.dot( this.direction );
			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t :  null;

		},

		intersectPlane: function ( plane, optionalTarget ) {

			var t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, optionalTarget );

		},

		isIntersectionBox: function () {

			var v = new THREE.Vector3();

			return function ( box ) {

				return this.intersectBox( box, v ) !== null;

			};

		}(),

		intersectBox: function ( box, optionalTarget ) {

			// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

			var tmin, tmax, tymin, tymax, tzmin, tzmax;

			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			var origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

		},

		intersectTriangle: function () {

			// Compute the offset origin, edges, and normal.
			var diff = new THREE.Vector3();
			var edge1 = new THREE.Vector3();
			var edge2 = new THREE.Vector3();
			var normal = new THREE.Vector3();

			return function ( a, b, c, backfaceCulling, optionalTarget ) {

				// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;

				if ( DdN > 0 ) {

					if ( backfaceCulling ) return null;
					sign = 1;

				} else if ( DdN < 0 ) {

					sign = - 1;
					DdN = - DdN;

				} else {

					return null;

				}

				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {

					return null;

				}

				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {

					return null;

				}

				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {

					return null;

				}

				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );

				// t < 0, no intersection
				if ( QdN < 0 ) {

					return null;

				}

				// Ray intersects triangle.
				return this.at( QdN / DdN, optionalTarget );

			};

		}(),

		applyMatrix4: function ( matrix4 ) {

			this.direction.add( this.origin ).applyMatrix4( matrix4 );
			this.origin.applyMatrix4( matrix4 );
			this.direction.sub( this.origin );
			this.direction.normalize();

			return this;

		},

		equals: function ( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

	};

	// File:src/math/Sphere.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Sphere = function ( center, radius ) {

		this.center = ( center !== undefined ) ? center : new THREE.Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;

	};

	THREE.Sphere.prototype = {

		constructor: THREE.Sphere,

		set: function ( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		},

		setFromPoints: function () {

			var box = new THREE.Box3();

			return function ( points, optionalCenter ) {

				var center = this.center;

				if ( optionalCenter !== undefined ) {

					center.copy( optionalCenter );

				} else {

					box.setFromPoints( points ).center( center );

				}

				var maxRadiusSq = 0;

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

				}

				this.radius = Math.sqrt( maxRadiusSq );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		},

		empty: function () {

			return ( this.radius <= 0 );

		},

		containsPoint: function ( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		},

		distanceToPoint: function ( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		},

		intersectsSphere: function ( sphere ) {

			var radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		},

		clampPoint: function ( point, optionalTarget ) {

			var deltaLengthSq = this.center.distanceToSquared( point );

			var result = optionalTarget || new THREE.Vector3();
			result.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );

			}

			return result;

		},

		getBoundingBox: function ( optionalTarget ) {

			var box = optionalTarget || new THREE.Box3();

			box.set( this.center, this.center );
			box.expandByScalar( this.radius );

			return box;

		},

		applyMatrix4: function ( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		},

		translate: function ( offset ) {

			this.center.add( offset );

			return this;

		},

		equals: function ( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

	};

	// File:src/math/Frustum.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

		this.planes = [

			( p0 !== undefined ) ? p0 : new THREE.Plane(),
			( p1 !== undefined ) ? p1 : new THREE.Plane(),
			( p2 !== undefined ) ? p2 : new THREE.Plane(),
			( p3 !== undefined ) ? p3 : new THREE.Plane(),
			( p4 !== undefined ) ? p4 : new THREE.Plane(),
			( p5 !== undefined ) ? p5 : new THREE.Plane()

		];

	};

	THREE.Frustum.prototype = {

		constructor: THREE.Frustum,

		set: function ( p0, p1, p2, p3, p4, p5 ) {

			var planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( frustum ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		},

		setFromMatrix: function ( m ) {

			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		},

		intersectsObject: function () {

			var sphere = new THREE.Sphere();

			return function ( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( object.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;

			for ( var i = 0; i < 6; i ++ ) {

				var distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		},

		intersectsBox: function () {

			var p1 = new THREE.Vector3(),
				p2 = new THREE.Vector3();

			return function ( box ) {

				var planes = this.planes;

				for ( var i = 0; i < 6 ; i ++ ) {

					var plane = planes[ i ];

					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );

					// if both outside plane, no intersection

					if ( d1 < 0 && d2 < 0 ) {

						return false;

					}

				}

				return true;

			};

		}(),


		containsPoint: function ( point ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

	};

	// File:src/math/Plane.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Plane = function ( normal, constant ) {

		this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;

	};

	THREE.Plane.prototype = {

		constructor: THREE.Plane,

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

			return this;

		},

		setFromCoplanarPoints: function () {

			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();

			return function ( a, b, c ) {

				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint( normal, a );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, optionalTarget ) {

			return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

		},

		orthoPoint: function ( point, optionalTarget ) {

			var perpendicularMagnitude = this.distanceToPoint( point );

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

		},

		isIntersectionLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectLine: function () {

			var v1 = new THREE.Vector3();

			return function ( line, optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				var direction = line.delta( v1 );

				var denominator = this.normal.dot( direction );

				if ( denominator === 0 ) {

					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {

						return result.copy( line.start );

					}

					// Unsure if this is the correct method to handle this case.
					return undefined;

				}

				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

				if ( t < 0 || t > 1 ) {

					return undefined;

				}

				return result.copy( direction ).multiplyScalar( t ).add( line.start );

			};

		}(),


		coplanarPoint: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function () {

			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
			var m1 = new THREE.Matrix3();

			return function ( matrix, optionalNormalMatrix ) {

				// compute new normal based on theory here:
				// http://www.songho.ca/opengl/gl_normaltransform.html
				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
				var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

				var newCoplanarPoint = this.coplanarPoint( v2 );
				newCoplanarPoint.applyMatrix4( matrix );

				this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.constant = this.constant - offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

	};

	// File:src/math/Math.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Math = {

		generateUUID: function () {

			// http://www.broofa.com/Tools/Math.uuid.htm

			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
			var uuid = new Array( 36 );
			var rnd = 0, r;

			return function () {

				for ( var i = 0; i < 36; i ++ ) {

					if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

						uuid[ i ] = '-';

					} else if ( i === 14 ) {

						uuid[ i ] = '4';

					} else {

						if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

					}

				}

				return uuid.join( '' );

			};

		}(),

		// Clamp value to range <a, b>

		clamp: function ( x, a, b ) {

			return ( x < a ) ? a : ( ( x > b ) ? b : x );

		},

		// Clamp value to range <a, inf)

		clampBottom: function ( x, a ) {

			return x < a ? a : x;

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random float from <0, 1> with 16 bits of randomness
		// (standard Math.random() creates repetitive patterns when applied over larger space)

		random16: function () {

			return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function () {

			var degreeToRadiansFactor = Math.PI / 180;

			return function ( degrees ) {

				return degrees * degreeToRadiansFactor;

			};

		}(),

		radToDeg: function () {

			var radianToDegreesFactor = 180 / Math.PI;

			return function ( radians ) {

				return radians * radianToDegreesFactor;

			};

		}(),

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		nextPowerOfTwo: function ( value ) {

			value --;
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			value ++;

			return value;

		}

	};

	// File:src/math/Spline.js

	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Spline = function ( points ) {

		this.points = points;

		var c = [], v3 = { x: 0, y: 0, z: 0 },
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;

		this.initFromArray = function ( a ) {

			this.points = [];

			for ( var i = 0; i < a.length; i ++ ) {

				this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

			}

		};

		this.getPoint = function ( k ) {

			point = ( this.points.length - 1 ) * k;
			intPoint = Math.floor( point );
			weight = point - intPoint;

			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

			pa = this.points[ c[ 0 ] ];
			pb = this.points[ c[ 1 ] ];
			pc = this.points[ c[ 2 ] ];
			pd = this.points[ c[ 3 ] ];

			w2 = weight * weight;
			w3 = weight * w2;

			v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
			v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
			v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

			return v3;

		};

		this.getControlPointsArray = function () {

			var i, p, l = this.points.length,
				coords = [];

			for ( i = 0; i < l; i ++ ) {

				p = this.points[ i ];
				coords[ i ] = [ p.x, p.y, p.z ];

			}

			return coords;

		};

		// approximate length by summing linear segments

		this.getLength = function ( nSubDivisions ) {

			var i, index, nSamples, position,
				point = 0, intPoint = 0, oldIntPoint = 0,
				oldPosition = new THREE.Vector3(),
				tmpVec = new THREE.Vector3(),
				chunkLengths = [],
				totalLength = 0;

			// first point has 0 length

			chunkLengths[ 0 ] = 0;

			if ( ! nSubDivisions ) nSubDivisions = 100;

			nSamples = this.points.length * nSubDivisions;

			oldPosition.copy( this.points[ 0 ] );

			for ( i = 1; i < nSamples; i ++ ) {

				index = i / nSamples;

				position = this.getPoint( index );
				tmpVec.copy( position );

				totalLength += tmpVec.distanceTo( oldPosition );

				oldPosition.copy( position );

				point = ( this.points.length - 1 ) * index;
				intPoint = Math.floor( point );

				if ( intPoint !== oldIntPoint ) {

					chunkLengths[ intPoint ] = totalLength;
					oldIntPoint = intPoint;

				}

			}

			// last point ends with total length

			chunkLengths[ chunkLengths.length ] = totalLength;

			return { chunks: chunkLengths, total: totalLength };

		};

		this.reparametrizeByArcLength = function ( samplingCoef ) {

			var i, j,
				index, indexCurrent, indexNext,
				realDistance,
				sampling, position,
				newpoints = [],
				tmpVec = new THREE.Vector3(),
				sl = this.getLength();

			newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

			for ( i = 1; i < this.points.length; i ++ ) {

				//tmpVec.copy( this.points[ i - 1 ] );
				//linearDistance = tmpVec.distanceTo( this.points[ i ] );

				realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

				sampling = Math.ceil( samplingCoef * realDistance / sl.total );

				indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
				indexNext = i / ( this.points.length - 1 );

				for ( j = 1; j < sampling - 1; j ++ ) {

					index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

					position = this.getPoint( index );
					newpoints.push( tmpVec.copy( position ).clone() );

				}

				newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

			}

			this.points = newpoints;

		};

		// Catmull-Rom

		function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

			var v0 = ( p2 - p0 ) * 0.5,
				v1 = ( p3 - p1 ) * 0.5;

			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	};

	// File:src/math/Triangle.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Triangle = function ( a, b, c ) {

		this.a = ( a !== undefined ) ? a : new THREE.Vector3();
		this.b = ( b !== undefined ) ? b : new THREE.Vector3();
		this.c = ( c !== undefined ) ? c : new THREE.Vector3();

	};

	THREE.Triangle.normal = function () {

		var v0 = new THREE.Vector3();

		return function ( a, b, c, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );

			var resultLengthSq = result.lengthSq();
			if ( resultLengthSq > 0 ) {

				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

			}

			return result.set( 0, 0, 0 );

		};

	}();

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	THREE.Triangle.barycoordFromPoint = function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( point, a, b, c, optionalTarget ) {

			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );

			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );

			var denom = ( dot00 * dot11 - dot01 * dot01 );

			var result = optionalTarget || new THREE.Vector3();

			// collinear or singular triangle
			if ( denom === 0 ) {

				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set( - 2, - 1, - 1 );

			}

			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycentric coordinates must always sum to 1
			return result.set( 1 - u - v, v, u );

		};

	}();

	THREE.Triangle.containsPoint = function () {

		var v1 = new THREE.Vector3();

		return function ( point, a, b, c ) {

			var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

		};

	}();

	THREE.Triangle.prototype = {

		constructor: THREE.Triangle,

		set: function ( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		},

		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		},

		area: function () {

			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();

			return function () {

				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );

				return v0.cross( v1 ).length() * 0.5;

			};

		}(),

		midpoint: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		},

		normal: function ( optionalTarget ) {

			return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

		},

		plane: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Plane();

			return result.setFromCoplanarPoints( this.a, this.b, this.c );

		},

		barycoordFromPoint: function ( point, optionalTarget ) {

			return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

		},

		containsPoint: function ( point ) {

			return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

		},

		equals: function ( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	};

	// File:src/core/Clock.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Clock = function ( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	};

	THREE.Clock.prototype = {

		constructor: THREE.Clock,

		start: function () {

			this.startTime = self.performance !== undefined && self.performance.now !== undefined
						 ? self.performance.now()
						 : Date.now();

			this.oldTime = this.startTime;
			this.running = true;

		},

		stop: function () {

			this.getElapsedTime();
			this.running = false;

		},

		getElapsedTime: function () {

			this.getDelta();
			return this.elapsedTime;

		},

		getDelta: function () {

			var diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();

			}

			if ( this.running ) {

				var newTime = self.performance !== undefined && self.performance.now !== undefined
						 ? self.performance.now()
						 : Date.now();

				diff = 0.001 * ( newTime - this.oldTime );
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	};

	// File:src/core/EventDispatcher.js

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	THREE.EventDispatcher = function () {};

	THREE.EventDispatcher.prototype = {

		constructor: THREE.EventDispatcher,

		apply: function ( object ) {

			object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
			object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
			object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
			object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

		},

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			var listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			var listeners = this._listeners;

			if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

				return true;

			}

			return false;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				var index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var array = [];
				var length = listenerArray.length;

				for ( var i = 0; i < length; i ++ ) {

					array[ i ] = listenerArray[ i ];

				}

				for ( var i = 0; i < length; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	};

	// File:src/core/Raycaster.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://exocortex.com/
	 * @author stephomi / http://stephaneginier.com/
	 */

	( function ( THREE ) {

		THREE.Raycaster = function ( origin, direction, near, far ) {

			this.ray = new THREE.Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near || 0;
			this.far = far || Infinity;

			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};

			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {
						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			} );

		};

		function descSort( a, b ) {

			return a.distance - b.distance;

		}

		var intersectObject = function ( object, raycaster, intersects, recursive ) {

			if ( object.visible === false ) return;

			object.raycast( raycaster, intersects );

			if ( recursive === true ) {

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					intersectObject( children[ i ], raycaster, intersects, true );

				}

			}

		};

		//

		THREE.Raycaster.prototype = {

			constructor: THREE.Raycaster,

			linePrecision: 1,

			set: function ( origin, direction ) {

				// direction is assumed to be normalized (for accurate distance calculations)

				this.ray.set( origin, direction );

			},

			setFromCamera: function ( coords, camera ) {

				if ( camera instanceof THREE.PerspectiveCamera ) {

					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

				} else if ( camera instanceof THREE.OrthographicCamera ) {

					this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

				} else {

					console.error( 'THREE.Raycaster: Unsupported camera type.' );

				}

			},

			intersectObject: function ( object, recursive ) {

				var intersects = [];

				intersectObject( object, this, intersects, recursive );

				intersects.sort( descSort );

				return intersects;

			},

			intersectObjects: function ( objects, recursive ) {

				var intersects = [];

				if ( Array.isArray( objects ) === false ) {

					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;

				}

				for ( var i = 0, l = objects.length; i < l; i ++ ) {

					intersectObject( objects[ i ], this, intersects, recursive );

				}

				intersects.sort( descSort );

				return intersects;

			}

		};

	}( THREE ) );

	// File:src/core/Object3D.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */

	THREE.Object3D = function () {

		Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = THREE.Object3D.DefaultUp.clone();

		var position = new THREE.Vector3();
		var rotation = new THREE.Euler();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3( 1, 1, 1 );

		var onRotationChange = function () {

			quaternion.setFromEuler( rotation, false );

		};

		var onQuaternionChange = function () {

			rotation.setFromQuaternion( quaternion, undefined, false );

		};

		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new THREE.Matrix4()
			},
			normalMatrix: {
				value: new THREE.Matrix3()
			}
		} );

		this.rotationAutoUpdate = true;

		this.matrix = new THREE.Matrix4();
		this.matrixWorld = new THREE.Matrix4();

		this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.userData = {};

	};

	THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
	THREE.Object3D.DefaultMatrixAutoUpdate = true;

	THREE.Object3D.prototype = {

		constructor: THREE.Object3D,

		get eulerOrder () {

			console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

			return this.rotation.order;

		},

		set eulerOrder ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

			this.rotation.order = value;

		},

		get useQuaternion () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},

		set useQuaternion ( value ) {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},

		set renderDepth ( value ) {

			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

		},

		applyMatrix: function ( matrix ) {

			this.matrix.multiplyMatrices( matrix, this.matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function () {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			var q1 = new THREE.Quaternion();

			return function ( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.multiply( q1 );

				return this;

			};

		}(),

		rotateX: function () {

			var v1 = new THREE.Vector3( 1, 0, 0 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateY: function () {

			var v1 = new THREE.Vector3( 0, 1, 0 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateZ: function () {

			var v1 = new THREE.Vector3( 0, 0, 1 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		translateOnAxis: function () {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			var v1 = new THREE.Vector3();

			return function ( axis, distance ) {

				v1.copy( axis ).applyQuaternion( this.quaternion );

				this.position.add( v1.multiplyScalar( distance ) );

				return this;

			};

		}(),

		translate: function ( distance, axis ) {

			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );

		},

		translateX: function () {

			var v1 = new THREE.Vector3( 1, 0, 0 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateY: function () {

			var v1 = new THREE.Vector3( 0, 1, 0 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateZ: function () {

			var v1 = new THREE.Vector3( 0, 0, 1 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function () {

			var m1 = new THREE.Matrix4();

			return function ( vector ) {

				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

			};

		}(),

		lookAt: function () {

			// This routine does not support objects with rotated and/or translated parent(s)

			var m1 = new THREE.Matrix4();

			return function ( vector ) {

				m1.lookAt( vector, this.position, this.up );

				this.quaternion.setFromRotationMatrix( m1 );

			};

		}(),

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;

			}

			if ( object instanceof THREE.Object3D ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				object.dispatchEvent( { type: 'added' } );

				this.children.push( object );

			} else {

				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

			}

			var index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;

				object.dispatchEvent( { type: 'removed' } );

				this.children.splice( index, 1 );

			}

		},

		getChildByName: function ( name ) {

			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld( true );

			return result.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function () {

			var position = new THREE.Vector3();
			var scale = new THREE.Vector3();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Quaternion();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, result, scale );

				return result;

			};

		}(),

		getWorldRotation: function () {

			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Euler();

				this.getWorldQuaternion( quaternion );

				return result.setFromQuaternion( quaternion, this.rotation.order, false );

			};

		}(),

		getWorldScale: function () {

			var position = new THREE.Vector3();
			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, quaternion, result );

				return result;

			};

		}(),

		getWorldDirection: function () {

			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				this.getWorldQuaternion( quaternion );

				return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

			};

		}(),

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			var parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate === true ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate === true || force === true ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].updateMatrixWorld( force );

			}

		},

		toJSON: function ( meta ) {

			var isRootObject = ( meta === undefined );

			var data = {};
			var output = { object: data };

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {}
				};

				output.metadata = {
					version: 4.4,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;
			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;
			if ( this.visible !== true ) data.visible = this.visible;

			data.matrix = this.matrix.toArray();

			if ( this.children.length > 0 ) {

				data.children = [];

				for ( var i = 0; i < this.children.length; i ++ ) {

					data.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			if ( isRootObject ) {

				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;

			}

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache ( cache ) {

				var values = [];
				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}
				return values;

			}

		},

		clone: function ( recursive ) {

			return new this.constructor().copy( this, recursive );

		},

		copy: function ( source, recursive ) {

			if ( recursive === undefined ) recursive = true;

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.rotationAutoUpdate = source.rotationAutoUpdate;

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( var i = 0; i < source.children.length; i ++ ) {

					var child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

	THREE.Object3DIdCount = 0;

	// File:src/core/Face3.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];

		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = Array.isArray( color ) ? color : [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	};

	THREE.Face3.prototype = {

		constructor: THREE.Face3,

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.a = source.a;
			this.b = source.b;
			this.c = source.c;

			this.normal.copy( source.normal );
			this.color.copy( source.color );

			this.materialIndex = source.materialIndex;

			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

			}

			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

				this.vertexColors[ i ] = source.vertexColors[ i ].clone();

			}

			return this;

		}

	};

	// File:src/core/Face4.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new THREE.Face3( a, b, c, normal, color, materialIndex );

	};

	// File:src/core/BufferAttribute.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferAttribute = function ( array, itemSize ) {

		this.uuid = THREE.Math.generateUUID();

		this.array = array;
		this.itemSize = itemSize;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	};

	THREE.BufferAttribute.prototype = {

		constructor: THREE.BufferAttribute,

		get length() {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
			return this.array.length;

		},

		get count() {

			return this.array.length / this.itemSize;

		},

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;

			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		copyArray: function ( array ) {

			this.array.set( array );

			return this;

		},

		copyColorsArray: function ( colors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = colors.length; i < l; i ++ ) {

				var color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new THREE.Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		},

		copyIndicesArray: function ( indices ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = indices.length; i < l; i ++ ) {

				var index = indices[ i ];

				array[ offset ++ ] = index.a;
				array[ offset ++ ] = index.b;
				array[ offset ++ ] = index.c;

			}

			return this;

		},

		copyVector2sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new THREE.Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		},

		copyVector3sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new THREE.Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		},

		copyVector4sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new THREE.Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		getX: function ( index ) {

			return this.array[ index * this.itemSize ];

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		getY: function ( index ) {

			return this.array[ index * this.itemSize + 1 ];

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		getZ: function ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		getW: function ( index ) {

			return this.array[ index * this.itemSize + 3 ];

		},

		setW: function ( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	};

	//

	THREE.Int8Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

	};

	THREE.Uint8Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

	};

	THREE.Uint8ClampedAttribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

	};

	THREE.Int16Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

	};

	THREE.Uint16Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

	};

	THREE.Int32Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

	};

	THREE.Uint32Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

	};

	THREE.Float32Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

	};

	THREE.Float64Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

	};


	// Deprecated

	THREE.DynamicBufferAttribute = function ( array, itemSize ) {

		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );

	};

	// File:src/core/InstancedBufferAttribute.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {

		THREE.BufferAttribute.call( this, array, itemSize );

		this.meshPerAttribute = meshPerAttribute || 1;

	};

	THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
	THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

	THREE.InstancedBufferAttribute.prototype.copy = function ( source ) {

		THREE.BufferAttribute.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	};

	// File:src/core/InterleavedBuffer.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InterleavedBuffer = function ( array, stride ) {

		this.uuid = THREE.Math.generateUUID();

		this.array = array;
		this.stride = stride;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	};

	THREE.InterleavedBuffer.prototype = {

		constructor: THREE.InterleavedBuffer,

		get length () {

			return this.array.length;

		},

		get count () {

			return this.array.length / this.stride;

		},

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.stride = source.stride;
			this.dynamic = source.dynamic;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( var i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	};

	// File:src/core/InstancedInterleavedBuffer.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {

		THREE.InterleavedBuffer.call( this, array, stride );

		this.meshPerAttribute = meshPerAttribute || 1;

	};

	THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
	THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

	THREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {

		THREE.InterleavedBuffer.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	};

	// File:src/core/InterleavedBufferAttribute.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {

		this.uuid = THREE.Math.generateUUID();

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

	};


	THREE.InterleavedBufferAttribute.prototype = {

		constructor: THREE.InterleavedBufferAttribute,

		get length() {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
			return this.array.length;

		},

		get count() {

			return this.data.array.length / this.data.stride;

		},

		setX: function ( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		},

		setW: function ( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		},

		getX: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		},

		getY: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		},

		getZ: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		},

		getW: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		},

		setXY: function ( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		}

	};

	// File:src/core/Geometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Geometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [ [] ];

		this.morphTargets = [];
		this.morphColors = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.elementsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;

	};

	THREE.Geometry.prototype = {

		constructor: THREE.Geometry,

		applyMatrix: function ( matrix ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );

			}

			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

				}

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1;

			return function rotateX( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1;

			return function rotateY( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1;

			return function rotateZ( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1;

			return function translate( x, y, z ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1;

			return function scale( x, y, z ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj;

			return function lookAt( vector ) {

				if ( obj === undefined ) obj = new THREE.Object3D();

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		fromBufferGeometry: function ( geometry ) {

			var scope = this;

			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;

			var vertices = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

			var tempNormals = [];
			var tempUVs = [];
			var tempUVs2 = [];

			for ( var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4 ) {

				scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

				if ( normals !== undefined ) {

					tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

				}

				if ( colors !== undefined ) {

					scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

				}

				if ( uvs !== undefined ) {

					tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

				}

				if ( uvs2 !== undefined ) {

					tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

				}

			}

			var addFace = function ( a, b, c ) {

				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

				var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );

				scope.faces.push( face );

				if ( uvs !== undefined ) {

					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

				}

				if ( uvs2 !== undefined ) {

					scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

				}

			};

			if ( indices !== undefined ) {

				var groups = geometry.groups;

				if ( groups.length > 0 ) {

					for ( var i = 0; i < groups.length; i ++ ) {

						var group = groups[ i ];

						var start = group.start;
						var count = group.count;

						for ( var j = start, jl = start + count; j < jl; j += 3 ) {

							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );

						}

					}

				} else {

					for ( var i = 0; i < indices.length; i += 3 ) {

						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

					}

				}

			} else {

				for ( var i = 0; i < vertices.length / 3; i += 3 ) {

					addFace( i, i + 1, i + 2 );

				}

			}

			this.computeFaceNormals();

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			return this;

		},

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.center().negate();

			this.translate( offset.x, offset.y, offset.z );

			return offset;

		},

		normalize: function () {

			this.computeBoundingSphere();

			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;

			var s = radius === 0 ? 1 : 1.0 / radius;

			var matrix = new THREE.Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);

			this.applyMatrix( matrix );

			return this;

		},

		computeFaceNormals: function () {

			var cb = new THREE.Vector3(), ab = new THREE.Vector3();

			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

				var face = this.faces[ f ];

				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				cb.normalize();

				face.normal.copy( cb );

			}

		},

		computeVertexNormals: function ( areaWeighted ) {

			var v, vl, f, fl, face, vertices;

			vertices = new Array( this.vertices.length );

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new THREE.Vector3();

			}

			if ( areaWeighted ) {

				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				var vA, vB, vC;
				var cb = new THREE.Vector3(), ab = new THREE.Vector3();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );

				}

			} else {

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );

				}

			}

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].normalize();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );

				} else {

					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();

				}

			}

		},

		computeMorphNormals: function () {

			var i, il, f, fl, face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( ! face.__originalFaceNormal ) {

					face.__originalFaceNormal = face.normal.clone();

				} else {

					face.__originalFaceNormal.copy( face.normal );

				}

				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

					if ( ! face.__originalVertexNormals[ i ] ) {

						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

					} else {

						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

					}

				}

			}

			// use temp geometry to compute face and vertex normals for each morph

			var tmpGeo = new THREE.Geometry();
			tmpGeo.faces = this.faces;

			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

				// create on first access

				if ( ! this.morphNormals[ i ] ) {

					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];

					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						faceNormal = new THREE.Vector3();
						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );

					}

				}

				var morphNormals = this.morphNormals[ i ];

				// set vertices to morph target

				tmpGeo.vertices = this.morphTargets[ i ].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];

					faceNormal.copy( face.normal );

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

				}

			}

			// restore original normals

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;

			}

		},

		computeTangents: function () {

			console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

		},

		computeLineDistances: function () {

			var d = 0;
			var vertices = this.vertices;

			for ( var i = 0, il = vertices.length; i < il; i ++ ) {

				if ( i > 0 ) {

					d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

				}

				this.lineDistances[ i ] = d;

			}

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new THREE.Box3();

			}

			this.boundingBox.setFromPoints( this.vertices );

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			this.boundingSphere.setFromPoints( this.vertices );

		},

		merge: function ( geometry, matrix, materialIndexOffset ) {

			if ( geometry instanceof THREE.Geometry === false ) {

				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;

			}

			var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			uvs1 = this.faceVertexUvs[ 0 ],
			uvs2 = geometry.faceVertexUvs[ 0 ];

			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

			if ( matrix !== undefined ) {

				normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			}

			// vertices

			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

				var vertex = vertices2[ i ];

				var vertexCopy = vertex.clone();

				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

				vertices1.push( vertexCopy );

			}

			// faces

			for ( i = 0, il = faces2.length; i < il; i ++ ) {

				var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;

				faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );

				if ( normalMatrix !== undefined ) {

					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

				}

				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

					normal = faceVertexNormals[ j ].clone();

					if ( normalMatrix !== undefined ) {

						normal.applyMatrix3( normalMatrix ).normalize();

					}

					faceCopy.vertexNormals.push( normal );

				}

				faceCopy.color.copy( face.color );

				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );

				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push( faceCopy );

			}

			// uvs

			for ( i = 0, il = uvs2.length; i < il; i ++ ) {

				var uv = uvs2[ i ], uvCopy = [];

				if ( uv === undefined ) {

					continue;

				}

				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

					uvCopy.push( uv[ j ].clone() );

				}

				uvs1.push( uvCopy );

			}

		},

		mergeMesh: function ( mesh ) {

			if ( mesh instanceof THREE.Mesh === false ) {

				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;

			}

			mesh.matrixAutoUpdate && mesh.updateMatrix();

			this.merge( mesh.geometry, mesh.matrix );

		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices: function () {

			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];

			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;

			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

				if ( verticesMap[ key ] === undefined ) {

					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;

				} else {

					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];

				}

			}


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];

			for ( i = 0, il = this.faces.length; i < il; i ++ ) {

				face = this.faces[ i ];

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

				indices = [ face.a, face.b, face.c ];

				var dupIndex = - 1;

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {

					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

						dupIndex = n;
						faceIndicesToRemove.push( i );
						break;

					}

				}

			}

			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

				var idx = faceIndicesToRemove[ i ];

				this.faces.splice( idx, 1 );

				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

					this.faceVertexUvs[ j ].splice( idx, 1 );

				}

			}

			// Use unique set of vertices

			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.4,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};

			// standard Geometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			var vertices = [];

			for ( var i = 0; i < this.vertices.length; i ++ ) {

				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};

			for ( var i = 0; i < this.faces.length; i ++ ) {

				var face = this.faces[ i ];

				var hasMaterial = false; // face.materialIndex !== undefined;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;

				var faceType = 0;

				faceType = setBit( faceType, 0, 0 );
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );

				faces.push( faceType );
				faces.push( face.a, face.b, face.c );

				if ( hasFaceVertexUv ) {

					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);

				}

				if ( hasFaceNormal ) {

					faces.push( getNormalIndex( face.normal ) );

				}

				if ( hasFaceVertexNormal ) {

					var vertexNormals = face.vertexNormals;

					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);

				}

				if ( hasFaceColor ) {

					faces.push( getColorIndex( face.color ) );

				}

				if ( hasFaceVertexColor ) {

					var vertexColors = face.vertexColors;

					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);

				}

			}

			function setBit( value, position, enabled ) {

				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

			}

			function getNormalIndex( normal ) {

				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if ( normalsHash[ hash ] !== undefined ) {

					return normalsHash[ hash ];

				}

				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );

				return normalsHash[ hash ];

			}

			function getColorIndex( color ) {

				var hash = color.r.toString() + color.g.toString() + color.b.toString();

				if ( colorsHash[ hash ] !== undefined ) {

					return colorsHash[ hash ];

				}

				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );

				return colorsHash[ hash ];

			}

			function getUvIndex( uv ) {

				var hash = uv.x.toString() + uv.y.toString();

				if ( uvsHash[ hash ] !== undefined ) {

					return uvsHash[ hash ];

				}

				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );

				return uvsHash[ hash ];

			}

			data.data = {};

			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.vertices = [];
			this.faces = [];
			this.faceVertexUvs = [ [] ];

			var vertices = source.vertices;

			for ( var i = 0, il = vertices.length; i < il; i ++ ) {

				this.vertices.push( vertices[ i ].clone() );

			}

			var faces = source.faces;

			for ( var i = 0, il = faces.length; i < il; i ++ ) {

				this.faces.push( faces[ i ].clone() );

			}

			for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

				var faceVertexUvs = source.faceVertexUvs[ i ];

				if ( this.faceVertexUvs[ i ] === undefined ) {

					this.faceVertexUvs[ i ] = [];

				}

				for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

					var uvs = faceVertexUvs[ j ], uvsCopy = [];

					for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

						var uv = uvs[ k ];

						uvsCopy.push( uv.clone() );

					}

					this.faceVertexUvs[ i ].push( uvsCopy );

				}

			}

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

	THREE.GeometryIdCount = 0;

	// File:src/core/DirectGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.DirectGeometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'DirectGeometry';

		this.indices = [];
		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];

		this.groups = [];

		this.morphTargets = {};

		this.skinWeights = [];
		this.skinIndices = [];

		// this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;

	};

	THREE.DirectGeometry.prototype = {

		constructor: THREE.DirectGeometry,

		computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
		computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

		computeFaceNormals: function () {

			console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

		},

		computeVertexNormals: function () {

			console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

		},

		computeGroups: function ( geometry ) {

			var group;
			var groups = [];
			var materialIndex;

			var faces = geometry.faces;

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				// materials

				if ( face.materialIndex !== materialIndex ) {

					materialIndex = face.materialIndex;

					if ( group !== undefined ) {

						group.count = ( i * 3 ) - group.start;
						groups.push( group );

					}

					group = {
						start: i * 3,
						materialIndex: materialIndex
					};

				}

			}

			if ( group !== undefined ) {

				group.count = ( i * 3 ) - group.start;
				groups.push( group );

			}

			this.groups = groups;

		},

		fromGeometry: function ( geometry ) {

			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;

			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

			// morphs

			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;

			if ( morphTargetsLength > 0 ) {

				var morphTargetsPosition = [];

				for ( var i = 0; i < morphTargetsLength; i ++ ) {

					morphTargetsPosition[ i ] = [];

				}

				this.morphTargets.position = morphTargetsPosition;

			}

			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;

			if ( morphNormalsLength > 0 ) {

				var morphTargetsNormal = [];

				for ( var i = 0; i < morphNormalsLength; i ++ ) {

					morphTargetsNormal[ i ] = [];

				}

				this.morphTargets.normal = morphTargetsNormal;

			}

			// skins

			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;

			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;

			//

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

				} else {

					var normal = face.normal;

					this.normals.push( normal, normal, normal );

				}

				var vertexColors = face.vertexColors;

				if ( vertexColors.length === 3 ) {

					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

				} else {

					var color = face.color;

					this.colors.push( color, color, color );

				}

				if ( hasFaceVertexUv === true ) {

					var vertexUvs = faceVertexUvs[ 0 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

						this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

					}

				}

				if ( hasFaceVertexUv2 === true ) {

					var vertexUvs = faceVertexUvs[ 1 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

						this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

					}

				}

				// morphs

				for ( var j = 0; j < morphTargetsLength; j ++ ) {

					var morphTarget = morphTargets[ j ].vertices;

					morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

				}

				for ( var j = 0; j < morphNormalsLength; j ++ ) {

					var morphNormal = morphNormals[ j ].vertexNormals[ i ];

					morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

				}

				// skins

				if ( hasSkinIndices ) {

					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

				}

				if ( hasSkinWeights ) {

					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

				}

			}

			this.computeGroups( geometry );

			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

	// File:src/core/BufferGeometry.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferGeometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

	};

	THREE.BufferGeometry.prototype = {

		constructor: THREE.BufferGeometry,

		addIndex: function ( index ) {

			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );

		},

		getIndex: function () {

			return this.index;

		},

		setIndex: function ( index ) {

			this.index = index;

		},

		addAttribute: function ( name, attribute ) {

			if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

				this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

				return;

			}

			if ( name === 'index' ) {

				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );

				return;

			}

			this.attributes[ name ] = attribute;

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		removeAttribute: function ( name ) {

			delete this.attributes[ name ];

		},

		get drawcalls() {

			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;

		},

		get offsets() {

			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;

		},

		addDrawCall: function ( start, count, indexOffset ) {

			if ( indexOffset !== undefined ) {

				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

			}

			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );

		},

		clearDrawCalls: function () {

			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();

		},

		addGroup: function ( start, count, materialIndex ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0

			} );

		},

		clearGroups: function () {

			this.groups = [];

		},

		setDrawRange: function ( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		},

		applyMatrix: function ( matrix ) {

			var position = this.attributes.position;

			if ( position !== undefined ) {

				matrix.applyToVector3Array( position.array );
				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if ( normal !== undefined ) {

				var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

				normalMatrix.applyToVector3Array( normal.array );
				normal.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1;

			return function rotateX( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1;

			return function rotateY( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1;

			return function rotateZ( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1;

			return function translate( x, y, z ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1;

			return function scale( x, y, z ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj;

			return function lookAt( vector ) {

				if ( obj === undefined ) obj = new THREE.Object3D();

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.center().negate();

			this.translate( offset.x, offset.y, offset.z );

			return offset;

		},

		setFromObject: function ( object ) {

			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

			var geometry = object.geometry;

			if ( object instanceof THREE.Points || object instanceof THREE.Line ) {

				var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
				var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

					var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );

					this.addAttribute( 'lineDistance',  lineDistances.copyArray( geometry.lineDistances ) );

				}

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

			} else if ( object instanceof THREE.Mesh ) {

				if ( geometry instanceof THREE.Geometry ) {

					this.fromGeometry( geometry );

				}

			}

			return this;

		},

		updateFromObject: function ( object ) {

			var geometry = object.geometry;

			if ( object instanceof THREE.Mesh ) {

				var direct = geometry.__directGeometry;

				if ( direct === undefined ) {

					return this.fromGeometry( geometry );

				}

				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;

				geometry = direct;

			}

			if ( geometry.verticesNeedUpdate === true ) {

				var attribute = this.attributes.position;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;

				}

				geometry.verticesNeedUpdate = false;

			}

			if ( geometry.normalsNeedUpdate === true ) {

				var attribute = this.attributes.normal;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;

				}

				geometry.normalsNeedUpdate = false;

			}

			if ( geometry.colorsNeedUpdate === true ) {

				var attribute = this.attributes.color;

				if ( attribute !== undefined ) {

					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;

				}

				geometry.colorsNeedUpdate = false;

			}

			if ( geometry.lineDistancesNeedUpdate ) {

				var attribute = this.attributes.lineDistance;

				if ( attribute !== undefined ) {

					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;

				}

				geometry.lineDistancesNeedUpdate = false;

			}

			if ( geometry.groupsNeedUpdate ) {

				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;

				geometry.groupsNeedUpdate = false;

			}

			return this;

		},

		fromGeometry: function ( geometry ) {

			geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );

			return this.fromDirectGeometry( geometry.__directGeometry );

		},

		fromDirectGeometry: function ( geometry ) {

			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

			if ( geometry.normals.length > 0 ) {

				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

			}

			if ( geometry.colors.length > 0 ) {

				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

			}

			if ( geometry.uvs.length > 0 ) {

				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

			}

			if ( geometry.uvs2.length > 0 ) {

				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

			}

			if ( geometry.indices.length > 0 ) {

				var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
				var indices = new TypeArray( geometry.indices.length * 3 );
				this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

			}

			// groups

			this.groups = geometry.groups;

			// morphs

			for ( var name in geometry.morphTargets ) {

				var array = [];
				var morphTargets = geometry.morphTargets[ name ];

				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

					var morphTarget = morphTargets[ i ];

					var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

					array.push( attribute.copyVector3sArray( morphTarget ) );

				}

				this.morphAttributes[ name ] = array;

			}

			// skinning

			if ( geometry.skinIndices.length > 0 ) {

				var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

			}

			if ( geometry.skinWeights.length > 0 ) {

				var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

			}

			//

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			return this;

		},

		computeBoundingBox: function () {

			var vector = new THREE.Vector3();

			return function () {

				if ( this.boundingBox === null ) {

					this.boundingBox = new THREE.Box3();

				}

				var positions = this.attributes.position.array;

				if ( positions ) {

					var bb = this.boundingBox;
					bb.makeEmpty();

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.fromArray( positions, i );
						bb.expandByPoint( vector );

					}

				}

				if ( positions === undefined || positions.length === 0 ) {

					this.boundingBox.min.set( 0, 0, 0 );
					this.boundingBox.max.set( 0, 0, 0 );

				}

				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

				}

			};

		}(),

		computeBoundingSphere: function () {

			var box = new THREE.Box3();
			var vector = new THREE.Vector3();

			return function () {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new THREE.Sphere();

				}

				var positions = this.attributes.position.array;

				if ( positions ) {

					box.makeEmpty();

					var center = this.boundingSphere.center;

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.fromArray( positions, i );
						box.expandByPoint( vector );

					}

					box.center( center );

					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

					var maxRadiusSq = 0;

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.fromArray( positions, i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

					}

					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

					if ( isNaN( this.boundingSphere.radius ) ) {

						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

					}

				}

			};

		}(),

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			var index = this.index;
			var attributes = this.attributes;
			var groups = this.groups;

			if ( attributes.position ) {

				var positions = attributes.position.array;

				if ( attributes.normal === undefined ) {

					this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

				} else {

					// reset existing normals to zero

					var normals = attributes.normal.array;

					for ( var i = 0, il = normals.length; i < il; i ++ ) {

						normals[ i ] = 0;

					}

				}

				var normals = attributes.normal.array;

				var vA, vB, vC,

				pA = new THREE.Vector3(),
				pB = new THREE.Vector3(),
				pC = new THREE.Vector3(),

				cb = new THREE.Vector3(),
				ab = new THREE.Vector3();

				// indexed elements

				if ( index ) {

					var indices = index.array;

					if ( groups.length === 0 ) {

						this.addGroup( 0, indices.length );

					}

					for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

						var group = groups[ j ];

						var start = group.start;
						var count = group.count;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							vA = indices[ i + 0 ] * 3;
							vB = indices[ i + 1 ] * 3;
							vC = indices[ i + 2 ] * 3;

							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ vA ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;

							normals[ vB ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;

							normals[ vC ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;

						}

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( var i = 0, il = positions.length; i < il; i += 9 ) {

						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;

						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;

						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;

					}

				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;

			}

		},

		computeTangents: function () {

			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

		},

		computeOffsets: function ( size ) {

			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.')

		},

		merge: function ( geometry, offset ) {

			if ( geometry instanceof THREE.BufferGeometry === false ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) offset = 0;

			var attributes = this.attributes;

			for ( var key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;

				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;

				var attributeSize = attribute2.itemSize;

				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			var normals = this.attributes.normal.array;

			var x, y, z, n;

			for ( var i = 0, il = normals.length; i < il; i += 3 ) {

				x = normals[ i ];
				y = normals[ i + 1 ];
				z = normals[ i + 2 ];

				n = 1.0 / Math.sqrt( x * x + y * y + z * z );

				normals[ i ] *= n;
				normals[ i + 1 ] *= n;
				normals[ i + 2 ] *= n;

			}

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.4,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			data.data = { attributes: {} };

			var index = this.index;

			if ( index !== null ) {

				var array = Array.prototype.slice.call( index.array );

				data.data.index = {
					type: index.array.constructor.name,
					array: array
				};

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];

				var array = Array.prototype.slice.call( attribute.array );

				data.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array
				};

			}

			var groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			var boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			var index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone() );

			}

			var attributes = source.attributes;

			for ( var name in attributes ) {

				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );

			}

			var groups = source.groups;

			for ( var i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				this.addGroup( group.start, group.count );

			}

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

	THREE.BufferGeometry.MaxIndex = 65535;

	// File:src/core/InstancedBufferGeometry.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InstancedBufferGeometry = function () {

		THREE.BufferGeometry.call( this );

		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;

	};

	THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

	THREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

		this.groups.push( {

			start: start,
			count: count,
			instances: instances

		} );

	};

	THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		var attributes = source.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );

		}

		var groups = source.groups;

		for ( var i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.instances );

		}

		return this;

	};

	THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

	// File:src/cameras/Camera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.Camera = function () {

		THREE.Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new THREE.Matrix4();
		this.projectionMatrix = new THREE.Matrix4();

	};

	THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Camera.prototype.constructor = THREE.Camera;

	THREE.Camera.prototype.getWorldDirection = function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

		};

	}();

	THREE.Camera.prototype.lookAt = function () {

		// This routine does not support cameras with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( this.position, vector, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}();

	THREE.Camera.prototype.clone = function () {

		return new this.constructor().copy( this );

	};

	THREE.Camera.prototype.copy = function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );
		this.projectionMatrix.copy( source.projectionMatrix );

		return this;

	};

	// File:src/cameras/CubeCamera.js

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.CubeCamera = function ( near, far, cubeResolution ) {

		THREE.Object3D.call( this );

		this.type = 'CubeCamera';

		var fov = 90, aspect = 1;

		var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

		this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

		this.updateCubeMap = function ( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.generateMipmaps;

			renderTarget.generateMipmaps = false;

			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );

			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );

			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );

			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );

			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );

			renderTarget.generateMipmaps = generateMipmaps;

			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );

			renderer.setRenderTarget( null );

		};

	};

	THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

	// File:src/cameras/OrthographicCamera.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

		THREE.Camera.call( this );

		this.type = 'OrthographicCamera';

		this.zoom = 1;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;

		this.updateProjectionMatrix();

	};

	THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

	THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;

		this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

	};

	THREE.OrthographicCamera.prototype.copy = function ( source ) {
		
		THREE.Camera.prototype.copy.call( this, source );
		
		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;
		
		this.zoom = source.zoom;
		
		return this;
			
	};

	THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		return data;

	};

	// File:src/cameras/PerspectiveCamera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

		THREE.Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.zoom = 1;

		this.fov = fov !== undefined ? fov : 50;
		this.aspect = aspect !== undefined ? aspect : 1;
		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;

		this.updateProjectionMatrix();

	};

	THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


	/**
	 * Uses Focal Length (in mm) to estimate and set FOV
	 * 35mm (full-frame) camera is used if frame size is not specified;
	 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	 */

	THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

		if ( frameHeight === undefined ) frameHeight = 24;

		this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
		this.updateProjectionMatrix();

	};


	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */

	THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

		this.fullWidth = fullWidth;
		this.fullHeight = fullHeight;
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;

		this.updateProjectionMatrix();

	};


	THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

		var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

		if ( this.fullWidth ) {

			var aspect = this.fullWidth / this.fullHeight;
			var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
			var bottom = - top;
			var left = aspect * bottom;
			var right = aspect * top;
			var width = Math.abs( right - left );
			var height = Math.abs( top - bottom );

			this.projectionMatrix.makeFrustum(
				left + this.x * width / this.fullWidth,
				left + ( this.x + this.width ) * width / this.fullWidth,
				top - ( this.y + this.height ) * height / this.fullHeight,
				top - this.y * height / this.fullHeight,
				this.near,
				this.far
			);

		} else {

			this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

		}

	};

	THREE.PerspectiveCamera.prototype.copy = function ( source ) {
		
		THREE.Camera.prototype.copy.call( this, source );
		
		this.fov = source.fov;
		this.aspect = source.aspect;
		this.near = source.near;
		this.far = source.far;
		
		this.zoom = source.zoom;
		
		return this;
			
	};

	THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.fov = this.fov;
		data.object.aspect = this.aspect;
		data.object.near = this.near;
		data.object.far = this.far;

		return data;

	};

	// File:src/lights/Light.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Light = function ( color ) {

		THREE.Object3D.call( this );

		this.type = 'Light';

		this.color = new THREE.Color( color );

	};

	THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Light.prototype.constructor = THREE.Light;

	THREE.Light.prototype.copy = function ( source ) {
		
		THREE.Object3D.prototype.copy.call( this, source );
		
		this.color.copy( source.color );
		
		return this;

	};
	// File:src/lights/AmbientLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AmbientLight = function ( color ) {

		THREE.Light.call( this, color );

		this.type = 'AmbientLight';

	};

	THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
	THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

	THREE.AmbientLight.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();

		return data;

	};

	// File:src/lights/DirectionalLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DirectionalLight = function ( color, intensity ) {

		THREE.Light.call( this, color );

		this.type = 'DirectionalLight';

		this.position.set( 0, 1, 0 );
		this.updateMatrix();

		this.target = new THREE.Object3D();

		this.intensity = ( intensity !== undefined ) ? intensity : 1;

		this.castShadow = false;
		this.onlyShadow = false;

		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;

		this.shadowCameraLeft = - 500;
		this.shadowCameraRight = 500;
		this.shadowCameraTop = 500;
		this.shadowCameraBottom = - 500;

		this.shadowCameraVisible = false;

		this.shadowBias = 0;
		this.shadowDarkness = 0.5;

		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;

		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;

	};

	THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
	THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

	THREE.DirectionalLight.prototype.copy = function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.intensity = source.intensity;
		this.target = source.target.clone();

		this.castShadow = source.castShadow;
		this.onlyShadow = source.onlyShadow;

		this.shadowCameraNear = source.shadowCameraNear;
		this.shadowCameraFar = source.shadowCameraFar;

		this.shadowCameraLeft = source.shadowCameraLeft;
		this.shadowCameraRight = source.shadowCameraRight;
		this.shadowCameraTop = source.shadowCameraTop;
		this.shadowCameraBottom = source.shadowCameraBottom;

		this.shadowCameraVisible = source.shadowCameraVisible;

		this.shadowBias = source.shadowBias;
		this.shadowDarkness = source.shadowDarkness;

		this.shadowMapWidth = source.shadowMapWidth;
		this.shadowMapHeight = source.shadowMapHeight;

		return this;

	};

	THREE.DirectionalLight.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		return data;

	};

	// File:src/lights/HemisphereLight.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

		THREE.Light.call( this, skyColor );

		this.type = 'HemisphereLight';

		this.position.set( 0, 1, 0 );
		this.updateMatrix();

		this.groundColor = new THREE.Color( groundColor );
		this.intensity = ( intensity !== undefined ) ? intensity : 1;

	};

	THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
	THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

	THREE.HemisphereLight.prototype.copy = function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );
		this.intensity = source.intensity;

		return this;

	};

	THREE.HemisphereLight.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.groundColor = this.groundColor.getHex();
		data.object.intensity = this.intensity;

		return data;

	};

	// File:src/lights/PointLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.PointLight = function ( color, intensity, distance, decay ) {

		THREE.Light.call( this, color );

		this.type = 'PointLight';

		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	};

	THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
	THREE.PointLight.prototype.constructor = THREE.PointLight;

	THREE.PointLight.prototype.copy = function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.intensity = source.intensity;
		this.distance = source.distance;
		this.decay = source.decay;

		return this;

	};

	THREE.PointLight.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;
		data.object.distance = this.distance;
		data.object.decay = this.decay;

		return data;

	};

	// File:src/lights/SpotLight.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {

		THREE.Light.call( this, color );

		this.type = 'SpotLight';

		this.position.set( 0, 1, 0 );
		this.updateMatrix();

		this.target = new THREE.Object3D();

		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.exponent = ( exponent !== undefined ) ? exponent : 10;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.castShadow = false;
		this.onlyShadow = false;

		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;
		this.shadowCameraFov = 50;

		this.shadowCameraVisible = false;

		this.shadowBias = 0;
		this.shadowDarkness = 0.5;

		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;

		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;

	};

	THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
	THREE.SpotLight.prototype.constructor = THREE.SpotLight;

	THREE.SpotLight.prototype.copy = function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.intensity = source.intensity;
		this.distance = source.distance;
		this.angle = source.angle;
		this.exponent = source.exponent;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.castShadow = source.castShadow;
		this.onlyShadow = source.onlyShadow;

		this.shadowCameraNear = source.shadowCameraNear;
		this.shadowCameraFar = source.shadowCameraFar;
		this.shadowCameraFov = source.shadowCameraFov;

		this.shadowCameraVisible = source.shadowCameraVisible;

		this.shadowBias = source.shadowBias;
		this.shadowDarkness = source.shadowDarkness;

		this.shadowMapWidth = source.shadowMapWidth;
		this.shadowMapHeight = source.shadowMapHeight;

		return this;
	}

	THREE.SpotLight.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;
		data.object.distance = this.distance;
		data.object.angle = this.angle;
		data.object.exponent = this.exponent;
		data.object.decay = this.decay;

		return data;

	};

	// File:src/loaders/Cache.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	// File:src/loaders/Loader.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Loader = function () {

		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};

	};

	THREE.Loader.prototype = {

		constructor: THREE.Loader,

		crossOrigin: undefined,

		extractUrlBase: function ( url ) {

			var parts = url.split( '/' );

			if ( parts.length === 1 ) return './';

			parts.pop();

			return parts.join( '/' ) + '/';

		},

		initMaterials: function ( materials, texturePath, crossOrigin ) {

			var array = [];

			for ( var i = 0; i < materials.length; ++ i ) {

				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

			}

			return array;

		},

		createMaterial: ( function () {

			var imageLoader;

			return function createMaterial( m, texturePath, crossOrigin ) {

				var scope = this;

				if ( crossOrigin === undefined && scope.crossOrigin !== undefined ) crossOrigin = scope.crossOrigin;

				if ( imageLoader === undefined ) imageLoader = new THREE.ImageLoader();

				function nearest_pow2( n ) {

					var l = Math.log( n ) / Math.LN2;
					return Math.pow( 2, Math.round(  l ) );

				}

				function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

					var fullPath = texturePath + sourceFile;

					var texture;

					var loader = THREE.Loader.Handlers.get( fullPath );

					if ( loader !== null ) {

						texture = loader.load( fullPath );

					} else {

						texture = new THREE.Texture();

						loader = imageLoader;
						loader.setCrossOrigin( crossOrigin );
						loader.load( fullPath, function ( image ) {

							if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
								THREE.Math.isPowerOfTwo( image.height ) === false ) {

								var width = nearest_pow2( image.width );
								var height = nearest_pow2( image.height );

								var canvas = document.createElement( 'canvas' );
								canvas.width = width;
								canvas.height = height;

								var context = canvas.getContext( '2d' );
								context.drawImage( image, 0, 0, width, height );

								texture.image = canvas;

							} else {

								texture.image = image;

							}

							texture.needsUpdate = true;

						} );

					}

					texture.sourceFile = sourceFile;

					if ( repeat ) {

						texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

						if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

					}

					if ( offset ) {

						texture.offset.set( offset[ 0 ], offset[ 1 ] );

					}

					if ( wrap ) {

						var wrapMap = {
							'repeat': THREE.RepeatWrapping,
							'mirror': THREE.MirroredRepeatWrapping
						};

						if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
						if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

					}

					if ( anisotropy ) {

						texture.anisotropy = anisotropy;

					}

					where[ name ] = texture;

				}

				function rgb2hex( rgb ) {

					return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

				}

				// defaults

				var mtype = 'MeshLambertMaterial';
				var mpars = {};

				// parameters from model file

				if ( m.shading ) {

					var shading = m.shading.toLowerCase();

					if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
					else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

				}

				if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

					mpars.blending = THREE[ m.blending ];

				}

				if ( m.transparent !== undefined ) {

					mpars.transparent = m.transparent;

				}

				if ( m.opacity !== undefined && m.opacity < 1.0 ) {

					mpars.transparent = true;

				}

				if ( m.depthTest !== undefined ) {

					mpars.depthTest = m.depthTest;

				}

				if ( m.depthWrite !== undefined ) {

					mpars.depthWrite = m.depthWrite;

				}

				if ( m.visible !== undefined ) {

					mpars.visible = m.visible;

				}

				if ( m.flipSided !== undefined ) {

					mpars.side = THREE.BackSide;

				}

				if ( m.doubleSided !== undefined ) {

					mpars.side = THREE.DoubleSide;

				}

				if ( m.wireframe !== undefined ) {

					mpars.wireframe = m.wireframe;

				}

				if ( m.vertexColors !== undefined ) {

					if ( m.vertexColors === 'face' ) {

						mpars.vertexColors = THREE.FaceColors;

					} else if ( m.vertexColors ) {

						mpars.vertexColors = THREE.VertexColors;

					}

				}

				// colors

				if ( m.colorDiffuse ) {

					mpars.color = rgb2hex( m.colorDiffuse );

				} else if ( m.DbgColor ) {

					mpars.color = m.DbgColor;

				}

				if ( m.colorEmissive ) {

					mpars.emissive = rgb2hex( m.colorEmissive );

				}

				if ( mtype === 'MeshPhongMaterial' ) {

					if ( m.colorSpecular ) {

						mpars.specular = rgb2hex( m.colorSpecular );

					}

					if ( m.specularCoef ) {

						mpars.shininess = m.specularCoef;

					}

				}

				// modifiers

				if ( m.transparency !== undefined ) {

					console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
					m.opacity = m.transparency;

				}

				if ( m.opacity !== undefined ) {

					mpars.opacity = m.opacity;

				}

				// textures

				if ( texturePath ) {

					if ( m.mapDiffuse ) {

						create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

					}

					if ( m.mapLight ) {

						create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

					}

					if ( m.mapAO ) {

						create_texture( mpars, 'aoMap', m.mapAO, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );

					}

					if ( m.mapBump ) {

						create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

					}

					if ( m.mapNormal ) {

						create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

					}

					if ( m.mapSpecular ) {

						create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

					}

					if ( m.mapAlpha ) {

						create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

					}

				}

				//

				if ( m.mapBumpScale ) {

					mpars.bumpScale = m.mapBumpScale;

				}

				if ( m.mapNormalFactor ) {

					mpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );

				}

				var material = new THREE[ mtype ]( mpars );

				if ( m.DbgName !== undefined ) material.name = m.DbgName;

				return material;

			};

		} )()

	};

	THREE.Loader.Handlers = {

		handlers: [],

		add: function ( regex, loader ) {

			this.handlers.push( regex, loader );

		},

		get: function ( file ) {

			for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

				var regex = this.handlers[ i ];
				var loader  = this.handlers[ i + 1 ];

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		}

	};

	// File:src/loaders/XHRLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.XHRLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.XHRLoader.prototype = {

		constructor: THREE.XHRLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var cached = THREE.Cache.get( url );

			if ( cached !== undefined ) {

				if ( onLoad ) {

					setTimeout( function () {

						onLoad( cached );

					}, 0 );

				}

				return cached;

			}

			var request = new XMLHttpRequest();
			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				THREE.Cache.add( url, this.response );

				if ( onLoad ) onLoad( this.response );

				scope.manager.itemEnd( url );

			}, false );

			if ( onProgress !== undefined ) {

				request.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			request.addEventListener( 'error', function ( event ) {

				if ( onError ) onError( event );

				scope.manager.itemError( url );

			}, false );

			if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

			request.send( null );

			scope.manager.itemStart( url );

			return request;

		},

		setResponseType: function ( value ) {

			this.responseType = value;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		setWithCredentials: function ( value ) {

			this.withCredentials = value;

		}

	};

	// File:src/loaders/ImageLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ImageLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.ImageLoader.prototype = {

		constructor: THREE.ImageLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var cached = THREE.Cache.get( url );

			if ( cached !== undefined ) {

				if ( onLoad ) {

					setTimeout( function () {

						onLoad( cached );

					}, 0 );

				}

				return cached;

			}

			var image = document.createElement( 'img' );

			image.addEventListener( 'load', function ( event ) {

				THREE.Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}, false );

			if ( onProgress !== undefined ) {

				image.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			image.addEventListener( 'error', function ( event ) {

				if ( onError ) onError( event );

				scope.manager.itemError( url );

			}, false );

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/JSONLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.JSONLoader = function ( manager ) {

		if ( typeof manager === 'boolean' ) {

			console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
			manager = undefined;

		}

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

		this.withCredentials = false;

	};

	THREE.JSONLoader.prototype = {

		constructor: THREE.JSONLoader,

		// Deprecated
		
		get statusDomElement () {

			if ( this._statusDomElement === undefined ) {

				this._statusDomElement = document.createElement( 'div' );

			}

			console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
			return this._statusDomElement;

		},

		load: function( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );

			var loader = new THREE.XHRLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {

				var json = JSON.parse( text );
				var metadata = json.metadata;

				if ( metadata !== undefined ) {

					if ( metadata.type === 'object' ) {

						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
						return;

					}

					if ( metadata.type === 'scene' ) {

						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
						return;

					}

				}

				var object = scope.parse( json, texturePath );
				onLoad( object.geometry, object.materials );

			} );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;

		},

		parse: function ( json, texturePath ) {

			var geometry = new THREE.Geometry(),
			scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

			parseModel( scale );

			parseSkin();
			parseMorphing( scale );

			geometry.computeFaceNormals();
			geometry.computeBoundingSphere();

			function parseModel( scale ) {

				function isBitSet( value, position ) {

					return value & ( 1 << position );

				}

				var i, j, fi,

				offset, zLength,

			colorIndex, normalIndex, uvIndex, materialIndex,

				type,
				isQuad,
				hasMaterial,
				hasFaceVertexUv,
				hasFaceNormal, hasFaceVertexNormal,
				hasFaceColor, hasFaceVertexColor,

			vertex, face, faceA, faceB, hex, normal,

				uvLayer, uv, u, v,

				faces = json.faces,
				vertices = json.vertices,
				normals = json.normals,
				colors = json.colors,

				nUvLayers = 0;

				if ( json.uvs !== undefined ) {

					// disregard empty arrays

					for ( i = 0; i < json.uvs.length; i ++ ) {

						if ( json.uvs[ i ].length ) nUvLayers ++;

					}

					for ( i = 0; i < nUvLayers; i ++ ) {

						geometry.faceVertexUvs[ i ] = [];

					}

				}

				offset = 0;
				zLength = vertices.length;

				while ( offset < zLength ) {

					vertex = new THREE.Vector3();

					vertex.x = vertices[ offset ++ ] * scale;
					vertex.y = vertices[ offset ++ ] * scale;
					vertex.z = vertices[ offset ++ ] * scale;

					geometry.vertices.push( vertex );

				}

				offset = 0;
				zLength = faces.length;

				while ( offset < zLength ) {

					type = faces[ offset ++ ];


					isQuad              = isBitSet( type, 0 );
					hasMaterial         = isBitSet( type, 1 );
					hasFaceVertexUv     = isBitSet( type, 3 );
					hasFaceNormal       = isBitSet( type, 4 );
					hasFaceVertexNormal = isBitSet( type, 5 );
					hasFaceColor	     = isBitSet( type, 6 );
					hasFaceVertexColor  = isBitSet( type, 7 );

					// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

					if ( isQuad ) {

						faceA = new THREE.Face3();
						faceA.a = faces[ offset ];
						faceA.b = faces[ offset + 1 ];
						faceA.c = faces[ offset + 3 ];

						faceB = new THREE.Face3();
						faceB.a = faces[ offset + 1 ];
						faceB.b = faces[ offset + 2 ];
						faceB.c = faces[ offset + 3 ];

						offset += 4;

						if ( hasMaterial ) {

							materialIndex = faces[ offset ++ ];
							faceA.materialIndex = materialIndex;
							faceB.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if ( hasFaceVertexUv ) {

							for ( i = 0; i < nUvLayers; i ++ ) {

								uvLayer = json.uvs[ i ];

								geometry.faceVertexUvs[ i ][ fi ] = [];
								geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

								for ( j = 0; j < 4; j ++ ) {

									uvIndex = faces[ offset ++ ];

									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];

									uv = new THREE.Vector2( u, v );

									if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
									if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

								}

							}

						}

						if ( hasFaceNormal ) {

							normalIndex = faces[ offset ++ ] * 3;

							faceA.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							faceB.normal.copy( faceA.normal );

						}

						if ( hasFaceVertexNormal ) {

							for ( i = 0; i < 4; i ++ ) {

								normalIndex = faces[ offset ++ ] * 3;

								normal = new THREE.Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);


								if ( i !== 2 ) faceA.vertexNormals.push( normal );
								if ( i !== 0 ) faceB.vertexNormals.push( normal );

							}

						}


						if ( hasFaceColor ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							faceA.color.setHex( hex );
							faceB.color.setHex( hex );

						}


						if ( hasFaceVertexColor ) {

							for ( i = 0; i < 4; i ++ ) {

								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];

								if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
								if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

							}

						}

						geometry.faces.push( faceA );
						geometry.faces.push( faceB );

					} else {

						face = new THREE.Face3();
						face.a = faces[ offset ++ ];
						face.b = faces[ offset ++ ];
						face.c = faces[ offset ++ ];

						if ( hasMaterial ) {

							materialIndex = faces[ offset ++ ];
							face.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if ( hasFaceVertexUv ) {

							for ( i = 0; i < nUvLayers; i ++ ) {

								uvLayer = json.uvs[ i ];

								geometry.faceVertexUvs[ i ][ fi ] = [];

								for ( j = 0; j < 3; j ++ ) {

									uvIndex = faces[ offset ++ ];

									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];

									uv = new THREE.Vector2( u, v );

									geometry.faceVertexUvs[ i ][ fi ].push( uv );

								}

							}

						}

						if ( hasFaceNormal ) {

							normalIndex = faces[ offset ++ ] * 3;

							face.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

						}

						if ( hasFaceVertexNormal ) {

							for ( i = 0; i < 3; i ++ ) {

								normalIndex = faces[ offset ++ ] * 3;

								normal = new THREE.Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);

								face.vertexNormals.push( normal );

							}

						}


						if ( hasFaceColor ) {

							colorIndex = faces[ offset ++ ];
							face.color.setHex( colors[ colorIndex ] );

						}


						if ( hasFaceVertexColor ) {

							for ( i = 0; i < 3; i ++ ) {

								colorIndex = faces[ offset ++ ];
								face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

							}

						}

						geometry.faces.push( face );

					}

				}

			};

			function parseSkin() {

				var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

				if ( json.skinWeights ) {

					for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

						var x =                               json.skinWeights[ i ];
						var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
						var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
						var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

						geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

					}

				}

				if ( json.skinIndices ) {

					for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

						var a =                               json.skinIndices[ i ];
						var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
						var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
						var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

						geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

					}

				}

				geometry.bones = json.bones;

				if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

					console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

				}


				// could change this to json.animations[0] or remove completely

				geometry.animation = json.animation;
				geometry.animations = json.animations;

			};

			function parseMorphing( scale ) {

				if ( json.morphTargets !== undefined ) {

					var i, l, v, vl, dstVertices, srcVertices;

					for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

						geometry.morphTargets[ i ] = {};
						geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
						geometry.morphTargets[ i ].vertices = [];

						dstVertices = geometry.morphTargets[ i ].vertices;
						srcVertices = json.morphTargets[ i ].vertices;

						for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

							var vertex = new THREE.Vector3();
							vertex.x = srcVertices[ v ] * scale;
							vertex.y = srcVertices[ v + 1 ] * scale;
							vertex.z = srcVertices[ v + 2 ] * scale;

							dstVertices.push( vertex );

						}

					}

				}

				if ( json.morphColors !== undefined ) {

					var i, l, c, cl, dstColors, srcColors, color;

					for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {

						geometry.morphColors[ i ] = {};
						geometry.morphColors[ i ].name = json.morphColors[ i ].name;
						geometry.morphColors[ i ].colors = [];

						dstColors = geometry.morphColors[ i ].colors;
						srcColors = json.morphColors[ i ].colors;

						for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

							color = new THREE.Color( 0xffaa00 );
							color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
							dstColors.push( color );

						}

					}

				}

			};

			if ( json.materials === undefined || json.materials.length === 0 ) {

				return { geometry: geometry };

			} else {

				var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

				return { geometry: geometry, materials: materials };

			}

		}

	};

	// File:src/loaders/LoadingManager.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

		var scope = this;

		var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

	};

	THREE.DefaultLoadingManager = new THREE.LoadingManager();

	// File:src/loaders/BufferGeometryLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferGeometryLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.BufferGeometryLoader.prototype = {

		constructor: THREE.BufferGeometryLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json ) {

			var geometry = new THREE.BufferGeometry();

			var index = json.data.index;

			if ( index !== undefined ) {

				var typedArray = new self[ index.type ]( index.array );
				geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );

			}

			var attributes = json.data.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];
				var typedArray = new self[ attribute.type ]( attribute.array );

				geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

			}

			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if ( groups !== undefined ) {

				for ( var i = 0, n = groups.length; i !== n; ++ i ) {

					var group = groups[ i ];

					geometry.addGroup( group.start, group.count );

				}

			}

			var boundingSphere = json.data.boundingSphere;

			if ( boundingSphere !== undefined ) {

				var center = new THREE.Vector3();

				if ( boundingSphere.center !== undefined ) {

					center.fromArray( boundingSphere.center );

				}

				geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

			}

			return geometry;

		}

	};

	// File:src/loaders/MaterialLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.MaterialLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.textures = {};

	};

	THREE.MaterialLoader.prototype = {

		constructor: THREE.MaterialLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		setTextures: function ( value ) {

			this.textures = value;

		},

		getTexture: function ( name ) {

			var textures = this.textures;

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		},

		parse: function ( json ) {

			var material = new THREE[ json.type ];
			material.uuid = json.uuid;

			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.shading !== undefined ) material.shading = json.shading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

			// for PointsMaterial
			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

			// maps

			if ( json.map !== undefined ) material.map = this.getTexture( json.map );

			if ( json.alphaMap !== undefined ) {

				material.alphaMap = this.getTexture( json.alphaMap );
				material.transparent = true;

			}

			if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

			if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
			if ( json.normalScale )	material.normalScale = new THREE.Vector2( json.normalScale, json.normalScale );

			if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

			if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );

			if ( json.envMap !== undefined ) {

				material.envMap = this.getTexture( json.envMap );
				material.combine = THREE.MultiplyOperation;

			}

			if ( json.reflectivity ) material.reflectivity = json.reflectivity;

			if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

			if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

			// MeshFaceMaterial

			if ( json.materials !== undefined ) {

				for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

					material.materials.push( this.parse( json.materials[ i ] ) );

				}

			}

			return material;

		}

	};

	// File:src/loaders/ObjectLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ObjectLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.texturePath = '';

	};

	THREE.ObjectLoader.prototype = {

		constructor: THREE.ObjectLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			if ( this.texturePath === '' ) {

				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

			}

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				scope.parse( JSON.parse( text ), onLoad );

			}, onProgress, onError );

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json, onLoad ) {

			var geometries = this.parseGeometries( json.geometries );

			var images = this.parseImages( json.images, function () {

				if ( onLoad !== undefined ) onLoad( object );

			} );

			var textures  = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );
			var object = this.parseObject( json.object, geometries, materials );

			if ( json.images === undefined || json.images.length === 0 ) {

				if ( onLoad !== undefined ) onLoad( object );

			}

			return object;

		},

		parseGeometries: function ( json ) {

			var geometries = {};

			if ( json !== undefined ) {

				var geometryLoader = new THREE.JSONLoader();
				var bufferGeometryLoader = new THREE.BufferGeometryLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var geometry;
					var data = json[ i ];

					switch ( data.type ) {

						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':

							geometry = new THREE[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);

							break;

						case 'BoxGeometry':
						case 'CubeGeometry': // backwards compatible

							geometry = new THREE.BoxGeometry(
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);

							break;

						case 'CircleBufferGeometry':

							geometry = new THREE.CircleBufferGeometry(
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'CircleGeometry':

							geometry = new THREE.CircleGeometry(
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'CylinderGeometry':

							geometry = new THREE.CylinderGeometry(
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'SphereGeometry':

							geometry = new THREE.SphereGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'SphereBufferGeometry':

							geometry = new THREE.SphereBufferGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'DodecahedronGeometry':

							geometry = new THREE.DodecahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'IcosahedronGeometry':

							geometry = new THREE.IcosahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'OctahedronGeometry':

							geometry = new THREE.OctahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'TetrahedronGeometry':

							geometry = new THREE.TetrahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'RingGeometry':

							geometry = new THREE.RingGeometry(
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'TorusGeometry':

							geometry = new THREE.TorusGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);

							break;

						case 'TorusKnotGeometry':

							geometry = new THREE.TorusKnotGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.p,
								data.q,
								data.heightScale
							);

							break;

						case 'TextGeometry':

							geometry = new THREE.TextGeometry(
								data.text,
								data.data
							);

							break;

						case 'BufferGeometry':

							geometry = bufferGeometryLoader.parse( data );

							break;

						case 'Geometry':

							geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

							break;

						default:

							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

							continue;

					}

					geometry.uuid = data.uuid;

					if ( data.name !== undefined ) geometry.name = data.name;

					geometries[ data.uuid ] = geometry;

				}

			}

			return geometries;

		},

		parseMaterials: function ( json, textures ) {

			var materials = {};

			if ( json !== undefined ) {

				var loader = new THREE.MaterialLoader();
				loader.setTextures( textures );

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var material = loader.parse( json[ i ] );
					materials[ material.uuid ] = material;

				}

			}

			return materials;

		},

		parseImages: function ( json, onLoad ) {

			var scope = this;
			var images = {};

			function loadImage( url ) {

				scope.manager.itemStart( url );

				return loader.load( url, function () {

					scope.manager.itemEnd( url );

				} );

			}

			if ( json !== undefined && json.length > 0 ) {

				var manager = new THREE.LoadingManager( onLoad );

				var loader = new THREE.ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var image = json[ i ];
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

					images[ image.uuid ] = loadImage( path );

				}

			}

			return images;

		},

		parseTextures: function ( json, images ) {

			function parseConstant( value ) {

				if ( typeof( value ) === 'number' ) return value;

				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

				return THREE[ value ];

			}

			var textures = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.image === undefined ) {

						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

					}

					if ( images[ data.image ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

					}

					var texture = new THREE.Texture( images[ data.image ] );
					texture.needsUpdate = true;

					texture.uuid = data.uuid;

					if ( data.name !== undefined ) texture.name = data.name;
					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
					if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
					if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
					if ( Array.isArray( data.wrap ) ) {

						texture.wrapS = parseConstant( data.wrap[ 0 ] );
						texture.wrapT = parseConstant( data.wrap[ 1 ] );

					}

					textures[ data.uuid ] = texture;

				}

			}

			return textures;

		},

		parseObject: function () {

			var matrix = new THREE.Matrix4();

			return function ( data, geometries, materials ) {

				var object;

				var getGeometry = function ( name ) {

					if ( geometries[ name ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

					}

					return geometries[ name ];

				};

				var getMaterial = function ( name ) {

					if ( materials[ name ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', name );

					}

					return materials[ name ];

				};

				switch ( data.type ) {

					case 'Scene':

						object = new THREE.Scene();

						break;

					case 'PerspectiveCamera':

						object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

						break;

					case 'OrthographicCamera':

						object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

						break;

					case 'AmbientLight':

						object = new THREE.AmbientLight( data.color );

						break;

					case 'DirectionalLight':

						object = new THREE.DirectionalLight( data.color, data.intensity );

						break;

					case 'PointLight':

						object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

						break;

					case 'SpotLight':

						object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

						break;

					case 'HemisphereLight':

						object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

						break;

					case 'Mesh':

						object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'LOD':

						object = new THREE.LOD();

						break;

					case 'Line':

						object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

						break;

					case 'PointCloud':
					case 'Points':

						object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'Sprite':

						object = new THREE.Sprite( getMaterial( data.material ) );

						break;

					case 'Group':

						object = new THREE.Group();

						break;

					default:

						object = new THREE.Object3D();

				}

				object.uuid = data.uuid;

				if ( data.name !== undefined ) object.name = data.name;
				if ( data.matrix !== undefined ) {

					matrix.fromArray( data.matrix );
					matrix.decompose( object.position, object.quaternion, object.scale );

				} else {

					if ( data.position !== undefined ) object.position.fromArray( data.position );
					if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
					if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

				}

				if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
				if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

				if ( data.visible !== undefined ) object.visible = data.visible;
				if ( data.userData !== undefined ) object.userData = data.userData;

				if ( data.children !== undefined ) {

					for ( var child in data.children ) {

						object.add( this.parseObject( data.children[ child ], geometries, materials ) );

					}

				}

				if ( data.type === 'LOD' ) {

					var levels = data.levels;

					for ( var l = 0; l < levels.length; l ++ ) {

						var level = levels[ l ];
						var child = object.getObjectByProperty( 'uuid', level.object );

						if ( child !== undefined ) {

							object.addLevel( child, level.distance );

						}

					}

				}

				return object;

			}

		}()

	};

	// File:src/loaders/TextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.TextureLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.TextureLoader.prototype = {

		constructor: THREE.TextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.ImageLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( image ) {

				var texture = new THREE.Texture( image );
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/BinaryTextureLoader.js

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */

	THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	};

	THREE.BinaryTextureLoader.prototype = {

		constructor: THREE.BinaryTextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texture = new THREE.DataTexture();

			var loader = new THREE.XHRLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setResponseType( 'arraybuffer' );

			loader.load( url, function ( buffer ) {

				var texData = scope._parser( buffer );

				if ( ! texData ) return;

				if ( undefined !== texData.image ) {

					texture.image = texData.image;

				} else if ( undefined !== texData.data ) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

				if ( undefined !== texData.format ) {

					texture.format = texData.format;

				}
				if ( undefined !== texData.type ) {

					texture.type = texData.type;

				}

				if ( undefined !== texData.mipmaps ) {

					texture.mipmaps = texData.mipmaps;

				}

				if ( 1 === texData.mipmapCount ) {

					texture.minFilter = THREE.LinearFilter;

				}

				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture, texData );

			}, onProgress, onError );


			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/CompressedTextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */

	THREE.CompressedTextureLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	};


	THREE.CompressedTextureLoader.prototype = {

		constructor: THREE.CompressedTextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var images = [];

			var texture = new THREE.CompressedTexture();
			texture.image = images;

			var loader = new THREE.XHRLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setResponseType( 'arraybuffer' );

			if ( Array.isArray( url ) ) {

				var loaded = 0;

				var loadTexture = function ( i ) {

					loader.load( url[ i ], function ( buffer ) {

						var texDatas = scope._parser( buffer, true );

						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};

						loaded += 1;

						if ( loaded === 6 ) {

							if ( texDatas.mipmapCount === 1 )
	 							texture.minFilter = THREE.LinearFilter;

							texture.format = texDatas.format;
							texture.needsUpdate = true;

							if ( onLoad ) onLoad( texture );

						}

					}, onProgress, onError );

				};

				for ( var i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					if ( texDatas.isCubemap ) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( var f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps : [] };

							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = THREE.LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}, onProgress, onError );

			}

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/materials/Material.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Material = function () {

		Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.side = THREE.FrontSide;

		this.opacity = 1;
		this.transparent = false;

		this.blending = THREE.NormalBlending;

		this.blendSrc = THREE.SrcAlphaFactor;
		this.blendDst = THREE.OneMinusSrcAlphaFactor;
		this.blendEquation = THREE.AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = THREE.LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.alphaTest = 0;

		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

		this.visible = true;

		this._needsUpdate = true;

	};

	THREE.Material.prototype = {

		constructor: THREE.Material,

		get needsUpdate () {

			return this._needsUpdate;

		},

		set needsUpdate ( value ) {

			if ( value === true ) this.update();

			this._needsUpdate = value;

		},

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( var key in values ) {

				var newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;

				}

				var currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;

				}

				if ( currentValue instanceof THREE.Color ) {

					currentValue.set( newValue );

				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

					currentValue.copy( newValue );

				} else if ( key === 'overdraw' ) {

					// ensure overdraw is backwards-compatible with legacy boolean type
					this[ key ] = Number( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		},

		toJSON: function ( meta ) {

			var data = {
				metadata: {
					version: 4.4,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
			if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
			if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;

			if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
			if ( this.bumpMap instanceof THREE.Texture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}
			if ( this.normalMap instanceof THREE.Texture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js

			}
			if ( this.displacementMap instanceof THREE.Texture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}
			if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
			if ( this.envMap instanceof THREE.Texture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap

			}

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
			if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
			if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
			if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;
			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.side = source.side;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blending = source.blending;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.alphaTest = source.alphaTest;

			this.overdraw = source.overdraw;

			this.visible = source.visible;

			return this;

		},

		update: function () {

			this.dispatchEvent( { type: 'update' } );

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		},

		// Deprecated

		get wrapAround () {

			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

		},

		set wrapAround ( boolean ) {

			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

		},

		get wrapRGB () {

			console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
			return new THREE.Color();

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

	THREE.MaterialIdCount = 0;

	// File:src/materials/LineBasicMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round",
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.LineBasicMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'LineBasicMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

	THREE.LineBasicMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.vertexColors = source.vertexColors;

		this.fog = source.fog;

		return this;

	};

	// File:src/materials/LineDashedMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>,
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.LineDashedMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'LineDashedMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.linewidth = 1;

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.vertexColors = false;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

	THREE.LineDashedMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		
		this.linewidth = source.linewidth;

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		this.vertexColors = source.vertexColors;

		this.fog = source.fog;

		return this;

	};

	// File:src/materials/MeshBasicMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.MeshBasicMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshBasicMaterial';

		this.color = new THREE.Color( 0xffffff ); // emissive

		this.map = null;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;

		this.setValues( parameters );

	};

	THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

	THREE.MeshBasicMaterial.prototype.copy = function ( source ) {
		
		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.fog = source.fog;

		this.shading = source.shading;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.vertexColors = source.vertexColors;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		
		return this;

	};

	// File:src/materials/MeshLambertMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  emissive: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.MeshLambertMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshLambertMaterial';

		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.emissive = new THREE.Color( 0x000000 );

		this.map = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	};

	THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

	THREE.MeshLambertMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.emissive.copy( source.emissive );

		this.map = source.map;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.fog = source.fog;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.vertexColors = source.vertexColors;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	// File:src/materials/MeshPhongMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  emissive: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.MeshPhongMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshPhongMaterial';

		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.emissive = new THREE.Color( 0x000000 );
		this.specular = new THREE.Color( 0x111111 );
		this.shininess = 30;

		this.metal = false;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	};

	THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

	THREE.MeshPhongMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.emissive.copy( source.emissive );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.metal = source.metal;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissiveMap = source.emissiveMap;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.fog = source.fog;

		this.shading = source.shading;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.vertexColors = source.vertexColors;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	// File:src/materials/MeshDepthMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	THREE.MeshDepthMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshDepthMaterial';

		this.morphTargets = false;
		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.setValues( parameters );

	};

	THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

	THREE.MeshDepthMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	// File:src/materials/MeshNormalMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  shading: THREE.FlatShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	THREE.MeshNormalMaterial = function ( parameters ) {

		THREE.Material.call( this, parameters );

		this.type = 'MeshNormalMaterial';

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.morphTargets = false;

		this.setValues( parameters );

	};

	THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

	THREE.MeshNormalMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	// File:src/materials/MultiMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.MultiMaterial = function ( materials ) {

		this.uuid = THREE.Math.generateUUID();

		this.type = 'MultiMaterial';

		this.materials = materials instanceof Array ? materials : [];

		this.visible = true;

	};

	THREE.MultiMaterial.prototype = {

		constructor: THREE.MultiMaterial,

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type,
				materials: []
			};

			for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

				output.materials.push( this.materials[ i ].toJSON() );

			}

			output.visible = this.visible;

			return output;

		},

		clone: function () {

			var material = new this.constructor();

			for ( var i = 0; i < this.materials.length; i ++ ) {

				material.materials.push( this.materials[ i ].clone() );

			}

			material.visible = this.visible;

			return material;

		}

	};

	// backwards compatibility

	THREE.MeshFaceMaterial = THREE.MultiMaterial;

	// File:src/materials/PointsMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  vertexColors: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.PointsMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'PointsMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.map = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.vertexColors = THREE.NoColors;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;

	THREE.PointsMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.vertexColors = source.vertexColors;

		this.fog = source.fog;

		return this;

	};

	// backwards compatibility

	THREE.PointCloudMaterial = function ( parameters ) {

		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );

	};

	THREE.ParticleBasicMaterial = function ( parameters ) {

		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );

	};

	THREE.ParticleSystemMaterial = function ( parameters ) {

		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );

	};

	// File:src/materials/ShaderMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.ShaderMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

		this.shading = THREE.SmoothShading;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog

		this.lights = false; // set to use scene lights

		this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

		this.skinning = false; // set to use skinning attribute streams

		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.derivatives = false; // set to use derivatives

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	};

	THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

	THREE.ShaderMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = THREE.UniformsUtils.clone( source.uniforms );

		this.attributes = source.attributes;
		this.defines = source.defines;

		this.shading = source.shading;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.fog = source.fog;

		this.lights = source.lights;

		this.vertexColors = source.vertexColors;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.derivatives = source.derivatives;

		return this;

	};

	THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {

		var data = THREE.Material.prototype.toJSON.call( this, meta );

		data.uniforms = this.uniforms;
		data.attributes = this.attributes;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		return data;

	};

	// File:src/materials/RawShaderMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.RawShaderMaterial = function ( parameters ) {

		THREE.ShaderMaterial.call( this, parameters );

		this.type = 'RawShaderMaterial';

	};

	THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
	THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
	// File:src/materials/SpriteMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2(),
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.SpriteMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'SpriteMaterial';

		this.color = new THREE.Color( 0xffffff );
		this.map = null;

		this.rotation = 0;

		this.fog = false;

		// set parameters

		this.setValues( parameters );

	};

	THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

	THREE.SpriteMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.map = source.map;

		this.rotation = source.rotation;

		this.fog = source.fog;

		return this;

	};

	// File:src/textures/Texture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.sourceFile = '';

		this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : THREE.RGBAFormat;
		this.type = type !== undefined ? type : THREE.UnsignedByteType;

		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		this.version = 0;
		this.onUpdate = null;

	};

	THREE.Texture.DEFAULT_IMAGE = undefined;
	THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

	THREE.Texture.prototype = {

		constructor: THREE.Texture,

		set needsUpdate ( value ) {

			if ( value === true ) this.version ++;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;

			return this;

		},

		toJSON: function ( meta ) {

			if ( meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			function getDataURL( image ) {

				var canvas;

				if ( image.toDataURL !== undefined ) {

					canvas = image;

				} else {

					canvas = document.createElement( 'canvas' );
					canvas.width = image.width;
					canvas.height = image.height;

					canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

				}

				if ( canvas.width > 2048 || canvas.height > 2048 ) {

					return canvas.toDataURL( 'image/jpeg', 0.6 );

				} else {

					return canvas.toDataURL( 'image/png' );

				}

			}

			var output = {
				metadata: {
					version: 4.4,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				wrap: [ this.wrapS, this.wrapT ],

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy
			};

			if ( this.image !== undefined ) {

				// TODO: Move to THREE.Image

				var image = this.image;

				if ( image.uuid === undefined ) {

					image.uuid = THREE.Math.generateUUID(); // UGH

				}

				if ( meta.images[ image.uuid ] === undefined ) {

					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: getDataURL( image )
					};

				}

				output.image = image.uuid;

			}

			meta.textures[ this.uuid ] = output;

			return output;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		},

		transformUv: function ( uv ) {

			if ( this.mapping !== THREE.UVMapping )  return;

			uv.multiply( this.repeat );
			uv.add( this.offset );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case THREE.RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case THREE.ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case THREE.MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}
						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case THREE.RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case THREE.ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case THREE.MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}
						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

	THREE.TextureIdCount = 0;

	// File:src/textures/CanvasTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	};

	THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

	// File:src/textures/CubeTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

		THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.images = images;
		this.flipY = false;

	};

	THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

	THREE.CubeTexture.prototype.copy = function ( source ) {

		THREE.Texture.prototype.copy.call( this, source );
		
		this.images = source.images;
		
		return this;

	};
	// File:src/textures/CompressedTexture.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	};

	THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

	// File:src/textures/DataTexture.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { data: data, width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
		
		this.flipY = false;
		this.generateMipmaps  = false;

	};

	THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.DataTexture.prototype.constructor = THREE.DataTexture;

	// File:src/textures/VideoTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.generateMipmaps = false;

		var scope = this;

		var update = function () {

			requestAnimationFrame( update );

			if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

				scope.needsUpdate = true;

			}

		};

		update();

	};

	THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

	// File:src/objects/Group.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Group = function () {

		THREE.Object3D.call( this );

		this.type = 'Group';

	};

	THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Group.prototype.constructor = THREE.Group;
	// File:src/objects/Points.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Points = function ( geometry, material ) {

		THREE.Object3D.call( this );

		this.type = 'Points';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );

	};

	THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Points.prototype.constructor = THREE.Points;

	THREE.Points.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();

		return function raycast( raycaster, intersects ) {

			var object = this;
			var geometry = object.geometry;
			var threshold = raycaster.params.Points.threshold;

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

					return;

				}

			}

			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localThresholdSq = localThreshold * localThreshold;
			var position = new THREE.Vector3();

			function testPoint( point, index ) {

				var rayPointDistanceSq = ray.distanceSqToPoint( point );

				if ( rayPointDistanceSq < localThresholdSq ) {

					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( object.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

					if ( distance < raycaster.near || distance > raycaster.far ) return;

					intersects.push( {

						distance: distance,
						distanceToRay: Math.sqrt( rayPointDistanceSq ),
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object

					} );

				}

			}

			if ( geometry instanceof THREE.BufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, il = indices.length; i < il; i ++ ) {

						var a = indices[ i ];

						position.fromArray( positions, a * 3 );

						testPoint( position, a );

					}

				} else {

					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

						position.fromArray( positions, i * 3 );

						testPoint( position, i );

					}

				}

			} else {

				var vertices = geometry.vertices;

				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

					testPoint( vertices[ i ], i );

				}

			}

		};

	}() );

	THREE.Points.prototype.clone = function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	};

	THREE.Points.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		// only serialize if not in meta geometries cache
		if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

			meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();

		}

		// only serialize if not in meta materials cache
		if ( meta.materials[ this.material.uuid ] === undefined ) {

			meta.materials[ this.material.uuid ] = this.material.toJSON();

		}

		data.object.geometry = this.geometry.uuid;
		data.object.material = this.material.uuid;

		return data;

	};

	// Backwards compatibility

	THREE.PointCloud = function ( geometry, material ) {

		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
		return new THREE.Points( geometry, material );

	};

	THREE.ParticleSystem = function ( geometry, material ) {

		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
		return new THREE.Points( geometry, material );

	};

	// File:src/objects/Line.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Line = function ( geometry, material, mode ) {

		if ( mode === 1 ) {

			console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
			return new THREE.LineSegments( geometry, material );

		}

		THREE.Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

	};

	THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Line.prototype.constructor = THREE.Line;

	THREE.Line.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		return function raycast( raycaster, intersects ) {

			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;

			var geometry = this.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			// Checking boundingSphere distance to ray

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( this.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return;

			}

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var vStart = new THREE.Vector3();
			var vEnd = new THREE.Vector3();
			var interSegment = new THREE.Vector3();
			var interRay = new THREE.Vector3();
			var step = this instanceof THREE.LineSegments ? 2 : 1;

			if ( geometry instanceof THREE.BufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;

				if ( index !== null ) {

					var indices = index.array;
					var positions = attributes.position.array;

					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

						var a = indices[ i ];
						var b = indices[ i + 1 ];

						vStart.fromArray( positions, a * 3 );
						vEnd.fromArray( positions, b * 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				} else {

					var positions = attributes.position.array;

					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;

				for ( var i = 0; i < nbVertices - 1; i += step ) {

					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		};

	}() );

	THREE.Line.prototype.clone = function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	};

	THREE.Line.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		// only serialize if not in meta geometries cache
		if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

			meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();

		}

		// only serialize if not in meta materials cache
		if ( meta.materials[ this.material.uuid ] === undefined ) {

			meta.materials[ this.material.uuid ] = this.material.toJSON();

		}

		data.object.geometry = this.geometry.uuid;
		data.object.material = this.material.uuid;

		return data;

	};

	// DEPRECATED

	THREE.LineStrip = 0;
	THREE.LinePieces = 1;

	// File:src/objects/LineSegments.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LineSegments = function ( geometry, material ) {

		THREE.Line.call( this, geometry, material );

		this.type = 'LineSegments';

	};

	THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
	THREE.LineSegments.prototype.constructor = THREE.LineSegments;

	// File:src/objects/Mesh.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	THREE.Mesh = function ( geometry, material ) {

		THREE.Object3D.call( this );

		this.type = 'Mesh';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

		this.updateMorphTargets();

	};

	THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Mesh.prototype.constructor = THREE.Mesh;

	THREE.Mesh.prototype.updateMorphTargets = function () {

		if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

			this.morphTargetBase = - 1;
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};

			for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

			}

		}

	};

	THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

		if ( this.morphTargetDictionary[ name ] !== undefined ) {

			return this.morphTargetDictionary[ name ];

		}

		console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

		return 0;

	};


	THREE.Mesh.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		var vA = new THREE.Vector3();
		var vB = new THREE.Vector3();
		var vC = new THREE.Vector3();

		var tempA = new THREE.Vector3();
		var tempB = new THREE.Vector3();
		var tempC = new THREE.Vector3();

		var uvA = new THREE.Vector2();
		var uvB = new THREE.Vector2();
		var uvC = new THREE.Vector2();

		var barycoord = new THREE.Vector3();

		var intersectionPoint = new THREE.Vector3();
		var intersectionPointWorld = new THREE.Vector3();

		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

			THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

			uv1.multiplyScalar( barycoord.x );
			uv2.multiplyScalar( barycoord.y );
			uv3.multiplyScalar( barycoord.z );

			uv1.add( uv2 ).add( uv3 );

			return uv1.clone();

		}

		return function raycast( raycaster, intersects ) {

			var geometry = this.geometry;
			var material = this.material;

			if ( material === undefined ) return;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( this.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return;

			}

			// Check boundingBox before continuing

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

					return;

				}

			}

			var a, b, c;

			if ( geometry instanceof THREE.BufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;

				if ( index !== null ) {

					var indices = index.array;
					var positions = attributes.position.array;

					for ( var i = 0, l = indices.length; i < l; i += 3 ) {

						a = indices[ i ];
						b = indices[ i + 1 ];
						c = indices[ i + 2 ];

						vA.fromArray( positions, a * 3 );
						vB.fromArray( positions, b * 3 );
						vC.fromArray( positions, c * 3 );

						if ( material.side === THREE.BackSide ) {

							if ( ray.intersectTriangle( vC, vB, vA, true, intersectionPoint ) === null ) continue;

						} else {

							if ( ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

						}

						intersectionPointWorld.copy( intersectionPoint );
						intersectionPointWorld.applyMatrix4( this.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						var uv;

						if ( attributes.uv !== undefined ) {

							var uvs = attributes.uv.array;
							uvA.fromArray( uvs, a * 2 );
							uvB.fromArray( uvs, b * 2 );
							uvC.fromArray( uvs, c * 2 );
							uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

						}

						intersects.push( {

							distance: distance,
							point: intersectionPointWorld.clone(),
							uv: uv,
							face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
							faceIndex: Math.floor( i / 3 ), // triangle number in indices buffer semantics
							object: this

						} );

					}

				} else {

					var positions = attributes.position.array;

					for ( var i = 0, l = positions.length; i < l; i += 9 ) {

						vA.fromArray( positions, i );
						vB.fromArray( positions, i + 3 );
						vC.fromArray( positions, i + 6 );

						if ( material.side === THREE.BackSide ) {

							if ( ray.intersectTriangle( vC, vB, vA, true, intersectionPoint ) === null ) continue;

						} else {

							if ( ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

						}

						intersectionPointWorld.copy( intersectionPoint );
						intersectionPointWorld.applyMatrix4( this.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						var uv;

						if ( attributes.uv !== undefined ) {

							var uvs = attributes.uv.array;
							uvA.fromArray( uvs, i );
							uvB.fromArray( uvs, i + 2 );
							uvC.fromArray( uvs, i + 4 );
							uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

						}

						a = i / 3;
						b = a + 1;
						c = a + 2;

						intersects.push( {

							distance: distance,
							point: intersectionPointWorld.clone(),
							uv: uv,
							face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
							index: a, // triangle number in positions buffer semantics
							object: this

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
				var materials = isFaceMaterial === true ? material.materials : null;

				var vertices = geometry.vertices;
				var faces = geometry.faces;

				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

					var face = faces[ f ];
					var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

					if ( faceMaterial === undefined ) continue;

					a = vertices[ face.a ];
					b = vertices[ face.b ];
					c = vertices[ face.c ];

					if ( faceMaterial.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;

						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) continue;

							var targets = morphTargets[ t ].vertices;

							vA.addScaledVector( tempA.subVectors( targets[ face.a ], a ), influence );
							vB.addScaledVector( tempB.subVectors( targets[ face.b ], b ), influence );
							vC.addScaledVector( tempC.subVectors( targets[ face.c ], c ), influence );

						}

						vA.add( a );
						vB.add( b );
						vC.add( c );

						a = vA;
						b = vB;
						c = vC;

					}

					if ( faceMaterial.side === THREE.BackSide ) {

						if ( ray.intersectTriangle( c, b, a, true, intersectionPoint ) === null ) continue;

					} else {

						if ( ray.intersectTriangle( a, b, c, faceMaterial.side !== THREE.DoubleSide, intersectionPoint ) === null ) continue;

					}

					intersectionPointWorld.copy( intersectionPoint );
					intersectionPointWorld.applyMatrix4( this.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					var uv;

					if ( geometry.faceVertexUvs[ 0 ].length > 0 ) {

						var uvs = geometry.faceVertexUvs[ 0 ][ f ];
						uvA.copy( uvs[ 0 ] );
						uvB.copy( uvs[ 1 ] );
						uvC.copy( uvs[ 2 ] );
						uv = uvIntersection( intersectionPoint, a, b, c, uvA, uvB, uvC );

					}

					intersects.push( {

						distance: distance,
						point: intersectionPointWorld.clone(),
						uv: uv,
						face: face,
						faceIndex: f,
						object: this

					} );

				}

			}

		};

	}() );

	THREE.Mesh.prototype.clone = function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	};

	THREE.Mesh.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		// only serialize if not in meta geometries cache
		if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

			meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

		}

		// only serialize if not in meta materials cache
		if ( meta.materials[ this.material.uuid ] === undefined ) {

			meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

		}

		data.object.geometry = this.geometry.uuid;
		data.object.material = this.material.uuid;

		return data;

	};

	// File:src/objects/Bone.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.Bone = function ( skin ) {

		THREE.Object3D.call( this );

		this.type = 'Bone';

		this.skin = skin;

	};

	THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Bone.prototype.constructor = THREE.Bone;

	THREE.Bone.prototype.copy = function ( source ) {
		
		THREE.Object3D.prototype.copy.call( this, source );
		
		this.skin = source.skin;
		
		return this;

	};

	// File:src/objects/Skeleton.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

		this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

		this.identityMatrix = new THREE.Matrix4();

		// copy the bone array

		bones = bones || [];

		this.bones = bones.slice( 0 );

		// create a bone texture or an array of floats

		if ( this.useVertexTexture ) {

			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
			//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
			//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
			//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

			
			var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
			size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
			size = Math.max( size, 4 );

			this.boneTextureWidth = size;
			this.boneTextureHeight = size;

			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );

		} else {

			this.boneMatrices = new Float32Array( 16 * this.bones.length );

		}

		// use the supplied bone inverses or calculate the inverses

		if ( boneInverses === undefined ) {

			this.calculateInverses();

		} else {

			if ( this.bones.length === boneInverses.length ) {

				this.boneInverses = boneInverses.slice( 0 );

			} else {

				console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

				this.boneInverses = [];

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					this.boneInverses.push( new THREE.Matrix4() );

				}

			}

		}

	};

	THREE.Skeleton.prototype.calculateInverses = function () {

		this.boneInverses = [];

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			var inverse = new THREE.Matrix4();

			if ( this.bones[ b ] ) {

				inverse.getInverse( this.bones[ b ].matrixWorld );

			}

			this.boneInverses.push( inverse );

		}

	};

	THREE.Skeleton.prototype.pose = function () {

		var bone;

		// recover the bind-time world matrices

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				bone.matrixWorld.getInverse( this.boneInverses[ b ] );

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				if ( bone.parent ) {

					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	};

	THREE.Skeleton.prototype.update = ( function () {

		var offsetMatrix = new THREE.Matrix4();

		return function update() {

			// flatten bone matrices to array

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				// compute the offset between the current and the original transform

				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
				offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

			}

			if ( this.useVertexTexture ) {

				this.boneTexture.needsUpdate = true;

			}

		};

	} )();

	THREE.Skeleton.prototype.clone = function () {

		return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

	};

	// File:src/objects/SkinnedMesh.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

		THREE.Mesh.call( this, geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = "attached";
		this.bindMatrix = new THREE.Matrix4();
		this.bindMatrixInverse = new THREE.Matrix4();

		// init bones

		// TODO: remove bone creation as there is no reason (other than
		// convenience) for THREE.SkinnedMesh to do this.

		var bones = [];

		if ( this.geometry && this.geometry.bones !== undefined ) {

			var bone, gbone;

			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

				gbone = this.geometry.bones[ b ];

				bone = new THREE.Bone( this );
				bones.push( bone );

				bone.name = gbone.name;
				bone.position.fromArray( gbone.pos );
				bone.quaternion.fromArray( gbone.rotq );
				if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

			}

			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

				gbone = this.geometry.bones[ b ];

				if ( gbone.parent !== - 1 ) {

					bones[ gbone.parent ].add( bones[ b ] );

				} else {

					this.add( bones[ b ] );

				}

			}

		}

		this.normalizeSkinWeights();

		this.updateMatrixWorld( true );
		this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

	};


	THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

	THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );
			
			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );

	};

	THREE.SkinnedMesh.prototype.pose = function () {

		this.skeleton.pose();

	};

	THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

		if ( this.geometry instanceof THREE.Geometry ) {

			for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

				var sw = this.geometry.skinWeights[ i ];

				var scale = 1.0 / sw.lengthManhattan();

				if ( scale !== Infinity ) {

					sw.multiplyScalar( scale );

				} else {

					sw.set( 1 ); // this will be normalized by the shader anyway

				}

			}

		} else {

			// skinning weights assumed to be normalized for THREE.BufferGeometry

		}

	};

	THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

		THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

		if ( this.bindMode === "attached" ) {

			this.bindMatrixInverse.getInverse( this.matrixWorld );

		} else if ( this.bindMode === "detached" ) {

			this.bindMatrixInverse.getInverse( this.bindMatrix );

		} else {

			console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

		}

	};

	THREE.SkinnedMesh.prototype.clone = function() {

		return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );

	};

	// File:src/objects/MorphAnimMesh.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.MorphAnimMesh = function ( geometry, material ) {

		THREE.Mesh.call( this, geometry, material );

		this.type = 'MorphAnimMesh';

		// API

		this.duration = 1000; // milliseconds
		this.mirroredLoop = false;
		this.time = 0;

		// internals

		this.lastKeyframe = 0;
		this.currentKeyframe = 0;

		this.direction = 1;
		this.directionBackwards = false;

		this.setFrameRange( 0, geometry.morphTargets.length - 1 );

	};

	THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;

	THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

		this.startKeyframe = start;
		this.endKeyframe = end;

		this.length = this.endKeyframe - this.startKeyframe + 1;

	};

	THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

		this.direction = 1;
		this.directionBackwards = false;

	};

	THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

		this.direction = - 1;
		this.directionBackwards = true;

	};

	THREE.MorphAnimMesh.prototype.parseAnimations = function () {

		var geometry = this.geometry;

		if ( ! geometry.animations ) geometry.animations = {};

		var firstAnimation, animations = geometry.animations;

		var pattern = /([a-z]+)_?(\d+)/;

		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

			var morph = geometry.morphTargets[ i ];
			var parts = morph.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				var label = parts[ 1 ];

				if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };

				var animation = animations[ label ];

				if ( i < animation.start ) animation.start = i;
				if ( i > animation.end ) animation.end = i;

				if ( ! firstAnimation ) firstAnimation = label;

			}

		}

		geometry.firstAnimation = firstAnimation;

	};

	THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

		if ( ! this.geometry.animations ) this.geometry.animations = {};

		this.geometry.animations[ label ] = { start: start, end: end };

	};

	THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

		var animation = this.geometry.animations[ label ];

		if ( animation ) {

			this.setFrameRange( animation.start, animation.end );
			this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
			this.time = 0;

		} else {

			console.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );

		}

	};

	THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

		var frameTime = this.duration / this.length;

		this.time += this.direction * delta;

		if ( this.mirroredLoop ) {

			if ( this.time > this.duration || this.time < 0 ) {

				this.direction *= - 1;

				if ( this.time > this.duration ) {

					this.time = this.duration;
					this.directionBackwards = true;

				}

				if ( this.time < 0 ) {

					this.time = 0;
					this.directionBackwards = false;

				}

			}

		} else {

			this.time = this.time % this.duration;

			if ( this.time < 0 ) this.time += this.duration;

		}

		var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

		var influences = this.morphTargetInfluences;

		if ( keyframe !== this.currentKeyframe ) {

			influences[ this.lastKeyframe ] = 0;
			influences[ this.currentKeyframe ] = 1;
			influences[ keyframe ] = 0;

			this.lastKeyframe = this.currentKeyframe;
			this.currentKeyframe = keyframe;

		}

		var mix = ( this.time % frameTime ) / frameTime;

		if ( this.directionBackwards ) {

			mix = 1 - mix;

		}

		influences[ this.currentKeyframe ] = mix;
		influences[ this.lastKeyframe ] = 1 - mix;

	};

	THREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {

		var influences = this.morphTargetInfluences;

		for ( var i = 0, l = influences.length; i < l; i ++ ) {

			influences[ i ] = 0;

		}

		if ( a > - 1 ) influences[ a ] = 1 - t;
		if ( b > - 1 ) influences[ b ] = t;

	};

	THREE.MorphAnimMesh.prototype.copy = function ( source ) {

		THREE.Mesh.prototype.copy.call( this, source );

		this.duration = source.duration;
		this.mirroredLoop = source.mirroredLoop;
		this.time = source.time;

		this.lastKeyframe = source.lastKeyframe;
		this.currentKeyframe = source.currentKeyframe;

		this.direction = source.direction;
		this.directionBackwards = source.directionBackwards;

		return this;

	};

	// File:src/objects/LOD.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LOD = function () {

		THREE.Object3D.call( this );

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			},
			objects: {
				get: function () {

					console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
					return this.levels;

				}
			}
		} );

	};


	THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LOD.prototype.constructor = THREE.LOD;

	THREE.LOD.prototype.addLevel = function ( object, distance ) {

		if ( distance === undefined ) distance = 0;

		distance = Math.abs( distance );

		var levels = this.levels;

		for ( var l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

	};

	THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

		var levels = this.levels;

		for ( var i = 1, l = levels.length; i < l; i ++ ) {

			if ( distance < levels[ i ].distance ) {

				break;

			}

		}

		return levels[ i - 1 ].object;

	};

	THREE.LOD.prototype.raycast = ( function () {

		var matrixPosition = new THREE.Vector3();

		return function raycast( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		};

	}() );

	THREE.LOD.prototype.update = function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function update( camera ) {

			var levels = this.levels;

			if ( levels.length > 1 ) {

				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );

				var distance = v1.distanceTo( v2 );

				levels[ 0 ].object.visible = true;

				for ( var i = 1, l = levels.length; i < l; i ++ ) {

					if ( distance >= levels[ i ].distance ) {

						levels[ i - 1 ].object.visible = false;
						levels[ i ].object.visible = true;

					} else {

						break;

					}

				}

				for ( ; i < l; i ++ ) {

					levels[ i ].object.visible = false;

				}

			}

		};

	}();

	THREE.LOD.prototype.copy = function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source, false );

		var levels = source.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		return this;

	};

	THREE.LOD.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.levels = [];

		var levels = this.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	};

	// File:src/objects/Sprite.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Sprite = ( function () {

		var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
		var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
		var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

		var geometry = new THREE.BufferGeometry();
		geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		return function Sprite( material ) {

			THREE.Object3D.call( this );

			this.type = 'Sprite';

			this.geometry = geometry;
			this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

		};

	} )();

	THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Sprite.prototype.constructor = THREE.Sprite;

	THREE.Sprite.prototype.raycast = ( function () {

		var matrixPosition = new THREE.Vector3();

		return function raycast( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
			var guessSizeSq = this.scale.x * this.scale.y;

			if ( distanceSq > guessSizeSq ) {

				return;

			}

			intersects.push( {

				distance: Math.sqrt( distanceSq ),
				point: this.position,
				face: null,
				object: this

			} );

		};

	}() );

	THREE.Sprite.prototype.clone = function () {

		return new this.constructor( this.material ).copy( this );

	};

	THREE.Sprite.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		// only serialize if not in meta materials cache
		if ( meta.materials[ this.material.uuid ] === undefined ) {

			meta.materials[ this.material.uuid ] = this.material.toJSON();

		}

		data.object.material = this.material.uuid;

		return data;

	};

	// Backwards compatibility

	THREE.Particle = THREE.Sprite;

	// File:src/objects/LensFlare.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.LensFlare = function ( texture, size, distance, blending, color ) {

		THREE.Object3D.call( this );

		this.lensFlares = [];

		this.positionScreen = new THREE.Vector3();
		this.customUpdateCallback = undefined;

		if ( texture !== undefined ) {

			this.add( texture, size, distance, blending, color );

		}

	};

	THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LensFlare.prototype.constructor = THREE.LensFlare;


	/*
	 * Add: adds another flare
	 */

	THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new THREE.Color( 0xffffff );
		if ( blending === undefined ) blending = THREE.NormalBlending;

		distance = Math.min( distance, Math.max( 0, distance ) );

		this.lensFlares.push( {
			texture: texture,	// THREE.Texture
			size: size, 		// size in pixels (-1 = use texture.width)
			distance: distance, 	// distance (0-1) from light source (0=at light source)
			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
			scale: 1, 		// scale
			rotation: 0, 		// rotation
			opacity: opacity,	// opacity
			color: color,		// color
			blending: blending	// blending
		} );

	};

	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */

	THREE.LensFlare.prototype.updateLensFlares = function () {

		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;

		for ( f = 0; f < fl; f ++ ) {

			flare = this.lensFlares[ f ];

			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;

			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

		}

	};

	THREE.LensFlare.prototype.copy = function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source );

		this.positionScreen.copy( source.positionScreen );
		this.customUpdateCallback = source.customUpdateCallback;

		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

			this.lensFlares.push( source.lensFlares[ i ] );

		}

		return this;

	};

	// File:src/scenes/Scene.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Scene = function () {

		THREE.Object3D.call( this );

		this.type = 'Scene';

		this.fog = null;
		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

	};

	THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Scene.prototype.constructor = THREE.Scene;

	THREE.Scene.prototype.copy = function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source );

		if ( source.fog !== null ) this.fog = source.fog.clone();
		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	};

	// File:src/scenes/Fog.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Fog = function ( color, near, far ) {

		this.name = '';

		this.color = new THREE.Color( color );

		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;

	};

	THREE.Fog.prototype.clone = function () {

		return new THREE.Fog( this.color.getHex(), this.near, this.far );

	};

	// File:src/scenes/FogExp2.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.FogExp2 = function ( color, density ) {

		this.name = '';

		this.color = new THREE.Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;

	};

	THREE.FogExp2.prototype.clone = function () {

		return new THREE.FogExp2( this.color.getHex(), this.density );

	};

	// File:src/renderers/shaders/ShaderChunk.js

	THREE.ShaderChunk = {};

	// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

	THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

	THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

	THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

	THREE.ShaderChunk[ 'aomap_fragment'] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

	THREE.ShaderChunk[ 'aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

	THREE.ShaderChunk[ 'begin_vertex'] = "\nvec3 transformed = vec3( position );\n";

	// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

	THREE.ShaderChunk[ 'beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";

	// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

	THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

	THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

	THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

	THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/common.glsl

	THREE.ShaderChunk[ 'common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n	// Original approximation by Christophe Schlick '94\n	//;float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n	// Optimized variant (presented by Epic at SIGGRAPH '13)\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n	// geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n	// factor of 1/PI in distribution term omitted\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	//float dotNL = saturate( dot( normal, lightDir ) );\n	//float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";

	// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

	THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

	// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

	THREE.ShaderChunk[ 'displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

	THREE.ShaderChunk[ 'emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

	THREE.ShaderChunk[ 'emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

	THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// Transforming Normal Vectors with the Inverse Transformation\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

	THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

	THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

	THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

	THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

	THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

	THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		// attenuation\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n			// attenuation\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n			// diffuse\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack += ambientLightColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

	THREE.ShaderChunk[ 'lights_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		// attenuation\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		// diffuse\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n		// specular\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n			// attenuation\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n			// diffuse\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n			// specular\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n		// diffuse\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n		// specular\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		// diffuse\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalDiffuseLight += lightColor;\n\n		// specular (sky term only)\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * max( dotProduct, 0.0 );\n\n	}\n\n#endif\n\n#ifdef METAL\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;\n\n#else\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

	THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

	THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

	THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

	THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

	THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

	THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

	THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

	THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

	THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

	THREE.ShaderChunk[ 'map_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

	THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

	THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

	THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

	THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

	THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n	// Per-Pixel Tangent Space Normal Mapping\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

	THREE.ShaderChunk[ 'project_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

	THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n		#endif\n\n	}\n\n	outgoingLight = outgoingLight * shadowColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

	THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

	THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

	THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

	THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

	THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

	THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

	THREE.ShaderChunk[ 'uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

	THREE.ShaderChunk[ 'uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

	THREE.ShaderChunk[ 'uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

	THREE.ShaderChunk[ 'uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

	THREE.ShaderChunk[ 'uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

	THREE.ShaderChunk[ 'uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

	THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/UniformsUtils.js

	/**
	 * Uniform Utilities
	 */

	THREE.UniformsUtils = {

		merge: function ( uniforms ) {

			var merged = {};

			for ( var u = 0; u < uniforms.length; u ++ ) {

				var tmp = this.clone( uniforms[ u ] );

				for ( var p in tmp ) {

					merged[ p ] = tmp[ p ];

				}

			}

			return merged;

		},

		clone: function ( uniforms_src ) {

			var uniforms_dst = {};

			for ( var u in uniforms_src ) {

				uniforms_dst[ u ] = {};

				for ( var p in uniforms_src[ u ] ) {

					var parameter_src = uniforms_src[ u ][ p ];

					if ( parameter_src instanceof THREE.Color ||
						 parameter_src instanceof THREE.Vector2 ||
						 parameter_src instanceof THREE.Vector3 ||
						 parameter_src instanceof THREE.Vector4 ||
						 parameter_src instanceof THREE.Matrix3 ||
						 parameter_src instanceof THREE.Matrix4 ||
						 parameter_src instanceof THREE.Texture ) {

						uniforms_dst[ u ][ p ] = parameter_src.clone();

					} else if ( Array.isArray( parameter_src ) ) {

						uniforms_dst[ u ][ p ] = parameter_src.slice();

					} else {

						uniforms_dst[ u ][ p ] = parameter_src;

					}

				}

			}

			return uniforms_dst;

		}

	};

	// File:src/renderers/shaders/UniformsLib.js

	/**
	 * Uniforms library for shared webgl shaders
	 */

	THREE.UniformsLib = {

		common: {

			"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },

			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

			"specularMap" : { type: "t", value: null },
			"alphaMap" : { type: "t", value: null },

			"envMap" : { type: "t", value: null },
			"flipEnvMap" : { type: "f", value: - 1 },
			"reflectivity" : { type: "f", value: 1.0 },
			"refractionRatio" : { type: "f", value: 0.98 }

		},

		aomap: {

			"aoMap" : { type: "t", value: null },
			"aoMapIntensity" : { type: "f", value: 1 },

		},

		lightmap: {

			"lightMap" : { type: "t", value: null },
			"lightMapIntensity" : { type: "f", value: 1 },

		},

		emissivemap: {

			"emissiveMap" : { type: "t", value: null },

		},

		bumpmap: {

			"bumpMap" : { type: "t", value: null },
			"bumpScale" : { type: "f", value: 1 }

		},

		normalmap: {

			"normalMap" : { type: "t", value: null },
			"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }

		},

		displacementmap: {

			"displacementMap" : { type: "t", value: null },
			"displacementScale" : { type: "f", value: 1 },
			"displacementBias" : { type: "f", value: 0 }

		},

		fog : {

			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

		},

		lights: {

			"ambientLightColor" : { type: "fv", value: [] },

			"directionalLightDirection" : { type: "fv", value: [] },
			"directionalLightColor" : { type: "fv", value: [] },

			"hemisphereLightDirection" : { type: "fv", value: [] },
			"hemisphereLightSkyColor" : { type: "fv", value: [] },
			"hemisphereLightGroundColor" : { type: "fv", value: [] },

			"pointLightColor" : { type: "fv", value: [] },
			"pointLightPosition" : { type: "fv", value: [] },
			"pointLightDistance" : { type: "fv1", value: [] },
			"pointLightDecay" : { type: "fv1", value: [] },

			"spotLightColor" : { type: "fv", value: [] },
			"spotLightPosition" : { type: "fv", value: [] },
			"spotLightDirection" : { type: "fv", value: [] },
			"spotLightDistance" : { type: "fv1", value: [] },
			"spotLightAngleCos" : { type: "fv1", value: [] },
			"spotLightExponent" : { type: "fv1", value: [] },
			"spotLightDecay" : { type: "fv1", value: [] }

		},

		points: {

			"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },
			"size" : { type: "f", value: 1.0 },
			"scale" : { type: "f", value: 1.0 },
			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

		},

		shadowmap: {

			"shadowMap": { type: "tv", value: [] },
			"shadowMapSize": { type: "v2v", value: [] },

			"shadowBias" : { type: "fv1", value: [] },
			"shadowDarkness": { type: "fv1", value: [] },

			"shadowMatrix" : { type: "m4v", value: [] }

		}

	};

	// File:src/renderers/shaders/ShaderLib.js

	/**
	 * Webgl Shader Library for three.js
	 *
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */


	THREE.ShaderLib = {

		'basic': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "shadowmap" ]

			] ),

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],

				"	#ifdef USE_ENVMAP",

					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"	#endif",

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	vec3 totalAmbientLight = vec3( 1.0 );", // hardwired

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "aomap_fragment" ],

				"	outgoingLight = diffuseColor.rgb * totalAmbientLight;", // simple shader

					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],		// TODO: Shadows on an otherwise unlit surface doesn't make sense.

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'lambert': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],

				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
				}

			] ),

			vertexShader: [

				"#define LAMBERT",

				"varying vec3 vLightFront;",

				"#ifdef DOUBLE_SIDED",

				"	varying vec3 vLightBack;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],

					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_lambert_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform float opacity;",

				"varying vec3 vLightFront;",

				"#ifdef DOUBLE_SIDED",

				"	varying vec3 vLightBack;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],

				"	#ifdef DOUBLE_SIDED",

				"		if ( gl_FrontFacing )",
				"			outgoingLight += diffuseColor.rgb * vLightFront + emissive;",
				"		else",
				"			outgoingLight += diffuseColor.rgb * vLightBack + emissive;",

				"	#else",

				"		outgoingLight += diffuseColor.rgb * vLightFront + emissive;",

				"	#endif",

					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'phong': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "lightmap" ],
				THREE.UniformsLib[ "emissivemap" ],
				THREE.UniformsLib[ "bumpmap" ],
				THREE.UniformsLib[ "normalmap" ],
				THREE.UniformsLib[ "displacementmap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],

				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
					"shininess": { type: "f", value: 30 }
				}

			] ),

			vertexShader: [

				"#define PHONG",

				"varying vec3 vViewPosition;",

				"#ifndef FLAT_SHADED",

				"	varying vec3 vNormal;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],

					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

				"	vNormal = normalize( transformedNormal );",

				"#endif",

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "displacementmap_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"	vViewPosition = - mvPosition.xyz;",

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_phong_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"#define PHONG",

				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform vec3 specular;",
				"uniform float shininess;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
				THREE.ShaderChunk[ "normalmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	vec3 totalAmbientLight = ambientLightColor;",
				"	vec3 totalEmissiveLight = emissive;",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "aomap_fragment" ],
					THREE.ShaderChunk[ "emissivemap_fragment" ],

					THREE.ShaderChunk[ "lights_phong_fragment" ],

					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'points': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "points" ],
				THREE.UniformsLib[ "shadowmap" ]

			] ),

			vertexShader: [

				"uniform float size;",
				"uniform float scale;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "color_vertex" ],

				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				"	#ifdef USE_SIZEATTENUATION",
				"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
				"	#else",
				"		gl_PointSize = size;",
				"	#endif",

				"	gl_Position = projectionMatrix * mvPosition;",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform vec3 psColor;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_particle_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( psColor, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_particle_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],

				"	outgoingLight = diffuseColor.rgb;", // simple shader

					THREE.ShaderChunk[ "shadowmap_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'dashed': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],

				{
					"scale"    : { type: "f", value: 1 },
					"dashSize" : { type: "f", value: 1 },
					"totalSize": { type: "f", value: 2 }
				}

			] ),

			vertexShader: [

				"uniform float scale;",
				"attribute float lineDistance;",

				"varying float vLineDistance;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "color_vertex" ],

				"	vLineDistance = scale * lineDistance;",

				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"	gl_Position = projectionMatrix * mvPosition;",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform float opacity;",

				"uniform float dashSize;",
				"uniform float totalSize;",

				"varying float vLineDistance;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

				"		discard;",

				"	}",

				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],

				"	outgoingLight = diffuseColor.rgb;", // simple shader

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'depth': {

			uniforms: {

				"mNear": { type: "f", value: 1.0 },
				"mFar" : { type: "f", value: 2000.0 },
				"opacity" : { type: "f", value: 1.0 }

			},

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform float mNear;",
				"uniform float mFar;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"	#ifdef USE_LOGDEPTHBUF_EXT",

				"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

				"	#else",

				"		float depth = gl_FragCoord.z / gl_FragCoord.w;",

				"	#endif",

				"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"	gl_FragColor = vec4( vec3( color ), opacity );",

				"}"

			].join( "\n" )

		},

		'normal': {

			uniforms: {

				"opacity" : { type: "f", value: 1.0 }

			},

			vertexShader: [

				"varying vec3 vNormal;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vNormal = normalize( normalMatrix * normal );",

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform float opacity;",
				"varying vec3 vNormal;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join( "\n" )

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		'cube': {

			uniforms: { "tCube": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },

			vertexShader: [

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vWorldPosition = transformDirection( position, modelMatrix );",

				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform samplerCube tCube;",
				"uniform float tFlip;",

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join( "\n" )

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		'equirect': {

			uniforms: { "tEquirect": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },

			vertexShader: [

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vWorldPosition = transformDirection( position, modelMatrix );",

				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform sampler2D tEquirect;",
				"uniform float tFlip;",

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

					// "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
					"vec3 direction = normalize( vWorldPosition );",
					"vec2 sampleUV;",
					"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
					"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
					"gl_FragColor = texture2D( tEquirect, sampleUV );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join( "\n" )

		},

		/* Depth encoding into RGBA texture
		 *
		 * based on SpiderGL shadow map example
		 * http://spidergl.org/example.php?id=6
		 *
		 * originally from
		 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
		 *
		 * see also
		 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
		 */

		'depthRGBA': {

			uniforms: {},

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "skinbase_vertex" ],

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"vec4 pack_depth( const in float depth ) {",

				"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
				"	res -= res.xxyz * bit_mask;",
				"	return res;",

				"}",

				"void main() {",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"	#ifdef USE_LOGDEPTHBUF_EXT",

				"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

				"	#else",

				"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

				"	#endif",

					//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
					//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
					//"gl_FragData[ 0 ] = pack_depth( z );",
					//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

				"}"

			].join( "\n" )

		}

	};

	// File:src/renderers/WebGLRenderer.js

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	THREE.WebGLRenderer = function ( parameters ) {

		console.log( 'THREE.WebGLRenderer', THREE.REVISION );

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,

		_width = _canvas.width,
		_height = _canvas.height,

		pixelRatio = 1,

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

		_clearColor = new THREE.Color( 0x000000 ),
		_clearAlpha = 0;

		var lights = [];

		var opaqueObjects = [];
		var opaqueObjectsLastIndex = -1;
		var transparentObjects = [];
		var transparentObjectsLastIndex = -1;

		var opaqueImmediateObjects = [];
		var opaqueImmediateObjectsLastIndex = -1;
		var transparentImmediateObjects = [];
		var transparentImmediateObjectsLastIndex = -1;

		var morphInfluences = new Float32Array( 8 );


		var sprites = [];
		var lensFlares = [];

		// public properties

		this.domElement = _canvas;
		this.context = null;

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// flags

		this.autoScaleCubemaps = true;

		// internal properties

		var _this = this,

		// internal state cache

		_currentProgram = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryProgram = '',
		_currentCamera = null,

		_usedTextureUnits = 0,

		_viewportX = 0,
		_viewportY = 0,
		_viewportWidth = _canvas.width,
		_viewportHeight = _canvas.height,
		_currentWidth = 0,
		_currentHeight = 0,

		// frustum

		_frustum = new THREE.Frustum(),

		 // camera matrices cache

		_projScreenMatrix = new THREE.Matrix4(),

		_vector3 = new THREE.Vector3(),

		// light arrays cache

		_direction = new THREE.Vector3(),

		_lightsNeedUpdate = true,

		_lights = {

			ambient: [ 0, 0, 0 ],
			directional: { length: 0, colors: [], positions: [] },
			point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
			spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
			hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

		},

		// info

		_infoMemory = {

			geometries: 0,
			textures: 0

		},

		_infoRender = {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		};

		this.info = {

			render: _infoRender,
			memory: _infoMemory,
			programs: null

		};


		// initialize

		var _gl;

		try {

			var attributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};

			_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

			if ( _gl === null ) {

				if ( _canvas.getContext( 'webgl' ) !== null ) {

					throw 'Error creating WebGL context with your selected attributes.';

				} else {

					throw 'Error creating WebGL context.';

				}

			}

			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error );

		}

		var extensions = new THREE.WebGLExtensions( _gl );

		extensions.get( 'OES_texture_float' );
		extensions.get( 'OES_texture_float_linear' );
		extensions.get( 'OES_texture_half_float' );
		extensions.get( 'OES_texture_half_float_linear' );
		extensions.get( 'OES_standard_derivatives' );
		extensions.get( 'ANGLE_instanced_arrays' );

		if ( extensions.get( 'OES_element_index_uint' ) ) {

			THREE.BufferGeometry.MaxIndex = 4294967296;

		}

		var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );

		var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
		var properties = new THREE.WebGLProperties();
		var objects = new THREE.WebGLObjects( _gl, properties, this.info );
		var programCache = new THREE.WebGLPrograms( this, capabilities );

		this.info.programs = programCache.programs;

		var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
		var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

		//

		function glClearColor( r, g, b, a ) {

			if ( _premultipliedAlpha === true ) {

				r *= a; g *= a; b *= a;

			}

			_gl.clearColor( r, g, b, a );

		}

		function setDefaultGLState() {

			state.init();

			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		}

		function resetGLState() {

			_currentProgram = null;
			_currentCamera = null;

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;

			_lightsNeedUpdate = true;

			state.reset();

		}

		setDefaultGLState();

		this.context = _gl;
		this.capabilities = capabilities;
		this.extensions = extensions;
		this.state = state;

		// shadow map

		var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );

		this.shadowMap = shadowMap;


		// Plugins

		var spritePlugin = new THREE.SpritePlugin( this, sprites );
		var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			extensions.get( 'WEBGL_lose_context' ).loseContext();

		};

		this.getMaxAnisotropy = ( function () {

			var value;

			return function getMaxAnisotropy() {

				if ( value !== undefined ) return value;

				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( extension !== null ) {

					value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

				} else {

					value = 0;

				}

				return value;

			}

		} )();

		this.getPrecision = function () {

			return capabilities.precision;

		};

		this.getPixelRatio = function () {

			return pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value !== undefined ) pixelRatio = value;

		};

		this.getSize = function () {

			return {
				width: _width,
				height: _height
			};

		};

		this.setSize = function ( width, height, updateStyle ) {

			_width = width;
			_height = height;

			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.setViewport = function ( x, y, width, height ) {

			_viewportX = x * pixelRatio;
			_viewportY = y * pixelRatio;

			_viewportWidth = width * pixelRatio;
			_viewportHeight = height * pixelRatio;

			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		};

		this.setScissor = function ( x, y, width, height ) {

			_gl.scissor(
				x * pixelRatio,
				y * pixelRatio,
				width * pixelRatio,
				height * pixelRatio
			);

		};

		this.enableScissorTest = function ( boolean ) {

			state.setScissorTest( boolean );

		};

		// Clearing

		this.getClearColor = function () {

			return _clearColor;

		};

		this.setClearColor = function ( color, alpha ) {

			_clearColor.set( color );

			_clearAlpha = alpha !== undefined ? alpha : 1;

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		};

		this.getClearAlpha = function () {

			return _clearAlpha;

		};

		this.setClearAlpha = function ( alpha ) {

			_clearAlpha = alpha;

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		};

		this.clear = function ( color, depth, stencil ) {

			var bits = 0;

			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			_gl.clear( _gl.COLOR_BUFFER_BIT );

		};

		this.clearDepth = function () {

			_gl.clear( _gl.DEPTH_BUFFER_BIT );

		};

		this.clearStencil = function () {

			_gl.clear( _gl.STENCIL_BUFFER_BIT );

		};

		this.clearTarget = function ( renderTarget, color, depth, stencil ) {

			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );

		};

		// Reset

		this.resetGLState = resetGLState;

		this.dispose = function() {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			resetGLState();
			setDefaultGLState();

			properties.clear();

		};

		function onTextureDispose( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			_infoMemory.textures --;


		}

		function onRenderTargetDispose( event ) {

			var renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			_infoMemory.textures --;

		}

		function onMaterialDispose( event ) {

			var material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateTexture( texture ) {

			var textureProperties = properties.get( texture );

			if ( texture.image && textureProperties.__image__webglTextureCube ) {

				// cube texture

				_gl.deleteTexture( textureProperties.__image__webglTextureCube );

			} else {

				// 2D texture

				if ( textureProperties.__webglInit === undefined ) return;

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			// remove all webgl properties
			properties.delete( texture );

		}

		function deallocateRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			if ( ! renderTarget || renderTargetProperties.__webglTexture === undefined ) return;

			_gl.deleteTexture( renderTargetProperties.__webglTexture );

			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

				for ( var i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer );

			}

			properties.delete( renderTarget );

		}

		function deallocateMaterial( material ) {

			releaseMaterialProgramReference( material );

			properties.delete( material );

		}


		function releaseMaterialProgramReference( material ) {

			var programInfo = properties.get( material ).program;

			material.program = undefined;

			if ( programInfo !== undefined ) {

				programCache.releaseProgram( programInfo );
			}

		}

		// Buffer rendering

		this.renderBufferImmediate = function ( object, program, material ) {

			state.initAttributes();

			var buffers = properties.get( object );

			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

			var attributes = program.getAttributes();

			if ( object.hasPositions ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

				if ( material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading ) {

					for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

						var array = object.normalArray;

						var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
						var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
						var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

						array[ i + 0 ] = nx;
						array[ i + 1 ] = ny;
						array[ i + 2 ] = nz;

						array[ i + 3 ] = nx;
						array[ i + 4 ] = ny;
						array[ i + 5 ] = nz;

						array[ i + 6 ] = nx;
						array[ i + 7 ] = ny;
						array[ i + 8 ] = nz;

					}

				}

				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( attributes.normal );

				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasUvs && material.map ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( attributes.uv );

				_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( attributes.color );

				_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

			}

			state.disableUnusedAttributes();

			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

			object.count = 0;

		};

		this.renderBufferDirect = function ( camera, lights, fog, geometry, material, object, group ) {

			setMaterial( material );

			var program = setProgram( camera, lights, fog, material, object );

			var updateBuffers = false;
			var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

			if ( geometryProgram !== _currentGeometryProgram ) {

				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;

			}

			// morph targets

			var morphTargetInfluences = object.morphTargetInfluences;

			if ( morphTargetInfluences !== undefined ) {

				var activeInfluences = [];

				for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

					var influence = morphTargetInfluences[ i ];
					activeInfluences.push( [ influence, i ] );

				}

				activeInfluences.sort( numericalSort );

				if ( activeInfluences.length > 8 ) {

					activeInfluences.length = 8;

				}

				var morphAttributes = geometry.morphAttributes;

				for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

					var influence = activeInfluences[ i ];
					morphInfluences[ i ] = influence[ 0 ];

					if ( influence[ 0 ] !== 0 ) {

						var index = influence[ 1 ];

						if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
						if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

					} else {

						if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
						if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

					}

				}

				var uniforms = program.getUniforms();

				if ( uniforms.morphTargetInfluences !== null ) {

					_gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );

				}

				updateBuffers = true;

			}

			//

			var index = geometry.index;
			var position = geometry.attributes.position;

			if ( material.wireframe === true ) {

				index = objects.getWireframeAttribute( geometry );

			}

			var renderer;

			if ( index !== null ) {

				renderer = indexedBufferRenderer;
				renderer.setIndex( index );

			} else {

				renderer = bufferRenderer;

			}

			if ( updateBuffers ) {

				setupVertexAttributes( material, program, geometry );

				if ( index !== null ) {

					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

				}

			}

			if ( group === undefined ) {

				var count;

				if ( index !== null ) {

					count = index.array.length;

				} else {

					count = position.count;

				}

				var drawRange = geometry.drawRange;

				group = {
					start: drawRange.start,
					count: Math.min( drawRange.count, count )
				};

			}

			if ( object instanceof THREE.Mesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * pixelRatio );
					renderer.setMode( _gl.LINES );

				} else {

					renderer.setMode( _gl.TRIANGLES );

				}

				if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

					renderer.renderInstances( geometry );

				} else {

					renderer.render( group.start, group.count );

				}

			} else if ( object instanceof THREE.Line ) {

				var lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * pixelRatio );

				if ( object instanceof THREE.LineSegments ) {

					renderer.setMode( _gl.LINES );

				} else {

					renderer.setMode( _gl.LINE_STRIP );

				}

				renderer.render( group.start, group.count );

			} else if ( object instanceof THREE.Points ) {

				renderer.setMode( _gl.POINTS );
				renderer.render( group.start, group.count );

			}

		};

		function setupVertexAttributes( material, program, geometry, startIndex ) {

			var extension;

			if ( geometry instanceof THREE.InstancedBufferGeometry ) {

				extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			if ( startIndex === undefined ) startIndex = 0;

			state.initAttributes();

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.getAttributes();

			var materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( var name in programAttributes ) {

				var programAttribute = programAttributes[ name ];

				if ( programAttribute >= 0 ) {

					var geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute !== undefined ) {

						state.enableAttribute( programAttribute );

						var size = geometryAttribute.itemSize;
						var buffer = objects.getAttributeBuffer( geometryAttribute );

						if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;

							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

							if ( data instanceof THREE.InstancedInterleavedBuffer ) {

								if ( extension === null ) {

									console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
									return;

								}

								extension.vertexAttribDivisorANGLE( programAttribute, data.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = data.meshPerAttribute * data.count;

								}

							}

						} else {

							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

							if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

								if ( extension === null ) {

									console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
									return;

								}

								extension.vertexAttribDivisorANGLE( programAttribute, geometryAttribute.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							}

						}

					} else if ( materialDefaultAttributeValues !== undefined ) {

						var value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;

								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;

								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;

								default:
									_gl.vertexAttrib1fv( programAttribute, value );

							}

						}

					}

				}

			}

			state.disableUnusedAttributes();

		}

		// Sorting

		function numericalSort ( a, b ) {

			return b[ 0 ] - a[ 0 ];

		}

		function painterSortStable ( a, b ) {

			if ( a.object.renderOrder !== b.object.renderOrder ) {

				return a.object.renderOrder - b.object.renderOrder;

			} else if ( a.material.id !== b.material.id ) {

				return a.material.id - b.material.id;

			} else if ( a.z !== b.z ) {

				return a.z - b.z;

			} else {

				return a.id - b.id;

			}

		}

		function reversePainterSortStable ( a, b ) {

			if ( a.object.renderOrder !== b.object.renderOrder ) {

				return a.object.renderOrder - b.object.renderOrder;

			} if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return a.id - b.id;

			}

		}

		// Rendering

		this.render = function ( scene, camera, renderTarget, forceClear ) {

			if ( camera instanceof THREE.Camera === false ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			var fog = scene.fog;

			// reset caching for this frame

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
			_currentCamera = null;
			_lightsNeedUpdate = true;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null ) camera.updateMatrixWorld();

			camera.matrixWorldInverse.getInverse( camera.matrixWorld );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			lights.length = 0;

			opaqueObjectsLastIndex = -1;
			transparentObjectsLastIndex = -1;

			opaqueImmediateObjectsLastIndex = -1;
			transparentImmediateObjectsLastIndex = -1;

			sprites.length = 0;
			lensFlares.length = 0;

			projectObject( scene );

			opaqueObjects.length = opaqueObjectsLastIndex + 1;
			transparentObjects.length = transparentObjectsLastIndex + 1;

			opaqueImmediateObjects.length = opaqueImmediateObjectsLastIndex + 1;
			transparentImmediateObjects.length = transparentImmediateObjectsLastIndex + 1;

			if ( _this.sortObjects === true ) {

				opaqueObjects.sort( painterSortStable );
				transparentObjects.sort( reversePainterSortStable );

			}

			//

			shadowMap.render( scene, camera );

			//

			_infoRender.calls = 0;
			_infoRender.vertices = 0;
			_infoRender.faces = 0;
			_infoRender.points = 0;

			this.setRenderTarget( renderTarget );

			if ( this.autoClear || forceClear ) {

				this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

			}

			//

			if ( scene.overrideMaterial ) {

				var overrideMaterial = scene.overrideMaterial;

				renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
				renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );

				renderObjectsImmediate( opaqueImmediateObjects, camera, lights, fog, overrideMaterial );
				renderObjectsImmediate( transparentImmediateObjects, camera, lights, fog, overrideMaterial );

			} else {

				// opaque pass (front-to-back order)

				state.setBlending( THREE.NoBlending );

				renderObjects( opaqueObjects, camera, lights, fog );
				renderObjectsImmediate( opaqueImmediateObjects, camera, lights, fog );

				// transparent pass (back-to-front order)

				renderObjects( transparentObjects, camera, lights, fog );
				renderObjectsImmediate( transparentImmediateObjects, camera, lights, fog );

			}

			// custom render plugins (post pass)

			spritePlugin.render( scene, camera );
			lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

			// Generate mipmap if we're using any kind of mipmap filtering

			if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

				updateRenderTargetMipmap( renderTarget );

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.setDepthTest( true );
			state.setDepthWrite( true );
			state.setColorWrite( true );

			// _gl.finish();

		};

		function pushImmediateRenderItem( object ) {

			var array, index;

			// allocate the next position in the appropriate array

			if ( object.material.transparent ) {

				array = transparentImmediateObjects;
				index = ++ transparentImmediateObjectsLastIndex;

			} else {

				array = opaqueImmediateObjects;
				index = ++ opaqueImmediateObjectsLastIndex;

			}

			// recycle existing position or grow the array

			if ( index < array.length ) {

				array[ index ] = object;

			} else {

				// assert( index === array.length );
				array.push( object );

			}


		}

		function pushRenderItem( object, geometry, material, z, group ) {

			var array, index;

			// allocate the next position in the appropriate array

			if ( material.transparent ) {

				array = transparentObjects;
				index = ++ transparentObjectsLastIndex;

			} else {

				array = opaqueObjects;
				index = ++ opaqueObjectsLastIndex;

			}

			// recycle existing render item or grow the array

			var renderItem = array[ index ];

			if ( renderItem !== undefined ) {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.z = _vector3.z;
				renderItem.group = group;

			} else {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					z: _vector3.z,
					group: group
				};

				// assert( index === array.length );
				array.push( renderItem );

			}

		}

		function projectObject( object ) {

			if ( object.visible === false ) return;

			if ( object instanceof THREE.Light ) {

				lights.push( object );

			} else if ( object instanceof THREE.Sprite ) {

				sprites.push( object );

			} else if ( object instanceof THREE.LensFlare ) {

				lensFlares.push( object );

			} else if ( object instanceof THREE.ImmediateRenderObject ) {

				pushImmediateRenderItem( object );

			} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

				if ( object instanceof THREE.SkinnedMesh ) {

					object.skeleton.update();

				}

				if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

					var material = object.material;

					if ( material.visible === true ) {

						if ( _this.sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

						}

						var geometry = objects.update( object );

						if ( material instanceof THREE.MeshFaceMaterial ) {

							var groups = geometry.groups;
							var materials = material.materials;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = materials[ group.materialIndex ];

								if ( groupMaterial.visible === true ) {

									pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

								}

							}

						} else {

							pushRenderItem( object, geometry, material, _vector3.z );

						}

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ] );

			}

		}

		function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var renderItem = renderList[ i ];

				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;

				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
				object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

				_this.renderBufferDirect( camera, lights, fog, geometry, material, object, group );

			}

		}

		function renderObjectsImmediate( renderList, camera, lights, fog, overrideMaterial ) {

			var material = overrideMaterial;

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var object = renderList[ i ];

				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
				object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

				if ( overrideMaterial === undefined ) material = object.material;

				setMaterial( material );

				var program = setProgram( camera, lights, fog, material, object );

				_currentGeometryProgram = '';

				object.render( function ( object ) {

					_this.renderBufferImmediate( object, program, material );

				} );

			}

		}

		function initMaterial( material, lights, fog, object ) {

			var materialProperties = properties.get( material );

			var parameters = programCache.getParameters( material, lights, fog, object );
			var code = programCache.getProgramCode( material, parameters );

			var program = materialProperties.program;
			var programChange = true;

			if ( program === undefined ) {

				// new material
				material.addEventListener( 'dispose', onMaterialDispose );

			} else if ( program.code !== code ) {

				// changed glsl or parameters
				releaseMaterialProgramReference( material );

			} else if ( parameters.shaderID !== undefined ) {

				// same glsl and uniform list
				return;

			} else {

				// only rebuild uniform list
				programChange = false;

			}

			if ( programChange ) {

				if ( parameters.shaderID ) {

					var shader = THREE.ShaderLib[ parameters.shaderID ];

					materialProperties.__webglShader = {
						name: material.type,
						uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};

				} else {

					materialProperties.__webglShader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};

				}

				material.__webglShader = materialProperties.__webglShader;

				program = programCache.acquireProgram( material, parameters, code );

				materialProperties.program = program;
				material.program = program;

			}

			var attributes = program.getAttributes();

			if ( material.morphTargets ) {

				material.numSupportedMorphTargets = 0;

				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

					if ( attributes[ 'morphTarget' + i ] >= 0 ) {

						material.numSupportedMorphTargets ++;

					}

				}

			}

			if ( material.morphNormals ) {

				material.numSupportedMorphNormals = 0;

				for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

					if ( attributes[ 'morphNormal' + i ] >= 0 ) {

						material.numSupportedMorphNormals ++;

					}

				}

			}

			materialProperties.uniformsList = [];

			var uniformLocations = materialProperties.program.getUniforms();

			for ( var u in materialProperties.__webglShader.uniforms ) {

				var location = uniformLocations[ u ];

				if ( location ) {

					materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );

				}

			}

		}

		function setMaterial( material ) {

			setMaterialFaces( material );

			if ( material.transparent === true ) {

				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

			} else {

				state.setBlending( THREE.NoBlending );

			}

			state.setDepthFunc( material.depthFunc );
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );
			state.setColorWrite( material.colorWrite );
			state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		}

		function setMaterialFaces( material ) {

			material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
			state.setFlipSided( material.side === THREE.BackSide );

		}

		function setProgram( camera, lights, fog, material, object ) {

			_usedTextureUnits = 0;

			var materialProperties = properties.get( material );

			if ( material.needsUpdate || ! materialProperties.program ) {

				initMaterial( material, lights, fog, object );
				material.needsUpdate = false;

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.__webglShader.uniforms;

			if ( program.id !== _currentProgram ) {

				_gl.useProgram( program.program );
				_currentProgram = program.id;

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				if ( _currentMaterialId === - 1 ) refreshLights = true;
				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || camera !== _currentCamera ) {

				_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

				if ( capabilities.logarithmicDepthBuffer ) {

					_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}


				if ( camera !== _currentCamera ) _currentCamera = camera;

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material instanceof THREE.ShaderMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material.envMap ) {

					if ( p_uniforms.cameraPosition !== undefined ) {

						_vector3.setFromMatrixPosition( camera.matrixWorld );
						_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

					}

				}

				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.ShaderMaterial ||
					 material.skinning ) {

					if ( p_uniforms.viewMatrix !== undefined ) {

						_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

					}

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen

			if ( material.skinning ) {

				if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {

					_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

				}

				if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {

					_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

				}

				if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {

					if ( p_uniforms.boneTexture !== undefined ) {

						var textureUnit = getTextureUnit();

						_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
						_this.setTexture( object.skeleton.boneTexture, textureUnit );

					}

					if ( p_uniforms.boneTextureWidth !== undefined ) {

						_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

					}

					if ( p_uniforms.boneTextureHeight !== undefined ) {

						_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

					}

				} else if ( object.skeleton && object.skeleton.boneMatrices ) {

					if ( p_uniforms.boneGlobalMatrices !== undefined ) {

						_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

					}

				}

			}

			if ( refreshMaterial ) {

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					refreshUniformsFog( m_uniforms, fog );

				}

				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material.lights ) {

					if ( _lightsNeedUpdate ) {

						refreshLights = true;
						setupLights( lights, camera );
						_lightsNeedUpdate = false;

					}

					if ( refreshLights ) {

						refreshUniformsLights( m_uniforms, _lights );
						markUniformsLightsNeedsUpdate( m_uniforms, true );

					} else {

						markUniformsLightsNeedsUpdate( m_uniforms, false );

					}

				}

				if ( material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshPhongMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

				}

				// refresh single material specific uniforms

				if ( material instanceof THREE.LineBasicMaterial ) {

					refreshUniformsLine( m_uniforms, material );

				} else if ( material instanceof THREE.LineDashedMaterial ) {

					refreshUniformsLine( m_uniforms, material );
					refreshUniformsDash( m_uniforms, material );

				} else if ( material instanceof THREE.PointsMaterial ) {

					refreshUniformsParticle( m_uniforms, material );

				} else if ( material instanceof THREE.MeshPhongMaterial ) {

					refreshUniformsPhong( m_uniforms, material );

				} else if ( material instanceof THREE.MeshDepthMaterial ) {

					m_uniforms.mNear.value = camera.near;
					m_uniforms.mFar.value = camera.far;
					m_uniforms.opacity.value = material.opacity;

				} else if ( material instanceof THREE.MeshNormalMaterial ) {

					m_uniforms.opacity.value = material.opacity;

				}

				if ( object.receiveShadow && ! material._shadowPass ) {

					refreshUniformsShadow( m_uniforms, lights );

				}

				// load common uniforms

				loadUniformsGeneric( materialProperties.uniformsList );

			}

			loadUniformsMatrices( p_uniforms, object );

			if ( p_uniforms.modelMatrix !== undefined ) {

				_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

			}

			return program;

		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon ( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			uniforms.diffuse.value = material.color;

			if ( material.emissive ) {

				uniforms.emissive.value = material.emissive;

			}

			uniforms.map.value = material.map;
			uniforms.specularMap.value = material.specularMap;
			uniforms.alphaMap.value = material.alphaMap;

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			}

			if ( uvScaleMap !== undefined ) {

				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;

				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

			}

			uniforms.envMap.value = material.envMap;
			uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;

		}

		function refreshUniformsLine ( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash ( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsParticle ( uniforms, material ) {

			uniforms.psColor.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size;
			uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

			uniforms.map.value = material.map;

			if ( material.map !== null ) {

				var offset = material.map.offset;
				var repeat = material.map.repeat;

				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

			}

		}

		function refreshUniformsFog ( uniforms, fog ) {

			uniforms.fogColor.value = fog.color;

			if ( fog instanceof THREE.Fog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog instanceof THREE.FogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshUniformsPhong ( uniforms, material ) {

			uniforms.specular.value = material.specular;
			uniforms.shininess.value = material.shininess;

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsLights ( uniforms, lights ) {

			uniforms.ambientLightColor.value = lights.ambient;

			uniforms.directionalLightColor.value = lights.directional.colors;
			uniforms.directionalLightDirection.value = lights.directional.positions;

			uniforms.pointLightColor.value = lights.point.colors;
			uniforms.pointLightPosition.value = lights.point.positions;
			uniforms.pointLightDistance.value = lights.point.distances;
			uniforms.pointLightDecay.value = lights.point.decays;

			uniforms.spotLightColor.value = lights.spot.colors;
			uniforms.spotLightPosition.value = lights.spot.positions;
			uniforms.spotLightDistance.value = lights.spot.distances;
			uniforms.spotLightDirection.value = lights.spot.directions;
			uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
			uniforms.spotLightExponent.value = lights.spot.exponents;
			uniforms.spotLightDecay.value = lights.spot.decays;

			uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
			uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
			uniforms.hemisphereLightDirection.value = lights.hemi.positions;

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate ( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;

			uniforms.directionalLightColor.needsUpdate = value;
			uniforms.directionalLightDirection.needsUpdate = value;

			uniforms.pointLightColor.needsUpdate = value;
			uniforms.pointLightPosition.needsUpdate = value;
			uniforms.pointLightDistance.needsUpdate = value;
			uniforms.pointLightDecay.needsUpdate = value;

			uniforms.spotLightColor.needsUpdate = value;
			uniforms.spotLightPosition.needsUpdate = value;
			uniforms.spotLightDistance.needsUpdate = value;
			uniforms.spotLightDirection.needsUpdate = value;
			uniforms.spotLightAngleCos.needsUpdate = value;
			uniforms.spotLightExponent.needsUpdate = value;
			uniforms.spotLightDecay.needsUpdate = value;

			uniforms.hemisphereLightSkyColor.needsUpdate = value;
			uniforms.hemisphereLightGroundColor.needsUpdate = value;
			uniforms.hemisphereLightDirection.needsUpdate = value;

		}

		function refreshUniformsShadow ( uniforms, lights ) {

			if ( uniforms.shadowMatrix ) {

				var j = 0;

				for ( var i = 0, il = lights.length; i < il; i ++ ) {

					var light = lights[ i ];

					if ( ! light.castShadow ) continue;

					if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight ) ) {

						uniforms.shadowMap.value[ j ] = light.shadowMap;
						uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

						uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

						uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
						uniforms.shadowBias.value[ j ] = light.shadowBias;

						j ++;

					}

				}

			}

		}

		// Uniforms (load to GPU)

		function loadUniformsMatrices ( uniforms, object ) {

			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );

			if ( uniforms.normalMatrix ) {

				_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );

			}

		}

		function getTextureUnit() {

			var textureUnit = _usedTextureUnits;

			if ( textureUnit >= capabilities.maxTextures ) {

				console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

			}

			_usedTextureUnits += 1;

			return textureUnit;

		}

		function loadUniformsGeneric ( uniforms ) {

			var texture, textureUnit;

			for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

				var uniform = uniforms[ j ][ 0 ];

				// needsUpdate property is not added to all uniforms.
				if ( uniform.needsUpdate === false ) continue;

				var type = uniform.type;
				var value = uniform.value;
				var location = uniforms[ j ][ 1 ];

				switch ( type ) {

					case '1i':
						_gl.uniform1i( location, value );
						break;

					case '1f':
						_gl.uniform1f( location, value );
						break;

					case '2f':
						_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
						break;

					case '3f':
						_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
						break;

					case '4f':
						_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
						break;

					case '1iv':
						_gl.uniform1iv( location, value );
						break;

					case '3iv':
						_gl.uniform3iv( location, value );
						break;

					case '1fv':
						_gl.uniform1fv( location, value );
						break;

					case '2fv':
						_gl.uniform2fv( location, value );
						break;

					case '3fv':
						_gl.uniform3fv( location, value );
						break;

					case '4fv':
						_gl.uniform4fv( location, value );
						break;

					case 'Matrix3fv':
						_gl.uniformMatrix3fv( location, false, value );
						break;

					case 'Matrix4fv':
						_gl.uniformMatrix4fv( location, false, value );
						break;

					//

					case 'i':

						// single integer
						_gl.uniform1i( location, value );

						break;

					case 'f':

						// single float
						_gl.uniform1f( location, value );

						break;

					case 'v2':

						// single THREE.Vector2
						_gl.uniform2f( location, value.x, value.y );

						break;

					case 'v3':

						// single THREE.Vector3
						_gl.uniform3f( location, value.x, value.y, value.z );

						break;

					case 'v4':

						// single THREE.Vector4
						_gl.uniform4f( location, value.x, value.y, value.z, value.w );

						break;

					case 'c':

						// single THREE.Color
						_gl.uniform3f( location, value.r, value.g, value.b );

						break;

					case 'iv1':

						// flat array of integers (JS or typed array)
						_gl.uniform1iv( location, value );

						break;

					case 'iv':

						// flat array of integers with 3 x N size (JS or typed array)
						_gl.uniform3iv( location, value );

						break;

					case 'fv1':

						// flat array of floats (JS or typed array)
						_gl.uniform1fv( location, value );

						break;

					case 'fv':

						// flat array of floats with 3 x N size (JS or typed array)
						_gl.uniform3fv( location, value );

						break;

					case 'v2v':

						// array of THREE.Vector2

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 2 * value.length );

						}

						for ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {

							uniform._array[ i2 + 0 ] = value[ i ].x;
							uniform._array[ i2 + 1 ] = value[ i ].y;

						}

						_gl.uniform2fv( location, uniform._array );

						break;

					case 'v3v':

						// array of THREE.Vector3

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 3 * value.length );

						}

						for ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {

							uniform._array[ i3 + 0 ] = value[ i ].x;
							uniform._array[ i3 + 1 ] = value[ i ].y;
							uniform._array[ i3 + 2 ] = value[ i ].z;

						}

						_gl.uniform3fv( location, uniform._array );

						break;

					case 'v4v':

						// array of THREE.Vector4

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 4 * value.length );

						}

						for ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {

							uniform._array[ i4 + 0 ] = value[ i ].x;
							uniform._array[ i4 + 1 ] = value[ i ].y;
							uniform._array[ i4 + 2 ] = value[ i ].z;
							uniform._array[ i4 + 3 ] = value[ i ].w;

						}

						_gl.uniform4fv( location, uniform._array );

						break;

					case 'm3':

						// single THREE.Matrix3
						_gl.uniformMatrix3fv( location, false, value.elements );

						break;

					case 'm3v':

						// array of THREE.Matrix3

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 9 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

						}

						_gl.uniformMatrix3fv( location, false, uniform._array );

						break;

					case 'm4':

						// single THREE.Matrix4
						_gl.uniformMatrix4fv( location, false, value.elements );

						break;

					case 'm4v':

						// array of THREE.Matrix4

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 16 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

						}

						_gl.uniformMatrix4fv( location, false, uniform._array );

						break;

					case 't':

						// single THREE.Texture (2d or cube)

						texture = value;
						textureUnit = getTextureUnit();

						_gl.uniform1i( location, textureUnit );

						if ( ! texture ) continue;

						if ( texture instanceof THREE.CubeTexture ||
							 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

							// CompressedTexture can have Array in image :/

							setCubeTexture( texture, textureUnit );

						} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

							setCubeTextureDynamic( texture, textureUnit );

						} else {

							_this.setTexture( texture, textureUnit );

						}

						break;

					case 'tv':

						// array of THREE.Texture (2d)

						if ( uniform._array === undefined ) {

							uniform._array = [];

						}

						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

							uniform._array[ i ] = getTextureUnit();

						}

						_gl.uniform1iv( location, uniform._array );

						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

							texture = uniform.value[ i ];
							textureUnit = uniform._array[ i ];

							if ( ! texture ) continue;

							_this.setTexture( texture, textureUnit );

						}

						break;

					default:

						console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

				}

			}

		}

		function setColorLinear( array, offset, color, intensity ) {

			array[ offset + 0 ] = color.r * intensity;
			array[ offset + 1 ] = color.g * intensity;
			array[ offset + 2 ] = color.b * intensity;

		}

		function setupLights ( lights, camera ) {

			var l, ll, light,
			r = 0, g = 0, b = 0,
			color, skyColor, groundColor,
			intensity,
			distance,

			zlights = _lights,

			viewMatrix = camera.matrixWorldInverse,

			dirColors = zlights.directional.colors,
			dirPositions = zlights.directional.positions,

			pointColors = zlights.point.colors,
			pointPositions = zlights.point.positions,
			pointDistances = zlights.point.distances,
			pointDecays = zlights.point.decays,

			spotColors = zlights.spot.colors,
			spotPositions = zlights.spot.positions,
			spotDistances = zlights.spot.distances,
			spotDirections = zlights.spot.directions,
			spotAnglesCos = zlights.spot.anglesCos,
			spotExponents = zlights.spot.exponents,
			spotDecays = zlights.spot.decays,

			hemiSkyColors = zlights.hemi.skyColors,
			hemiGroundColors = zlights.hemi.groundColors,
			hemiPositions = zlights.hemi.positions,

			dirLength = 0,
			pointLength = 0,
			spotLength = 0,
			hemiLength = 0,

			dirCount = 0,
			pointCount = 0,
			spotCount = 0,
			hemiCount = 0,

			dirOffset = 0,
			pointOffset = 0,
			spotOffset = 0,
			hemiOffset = 0;

			for ( l = 0, ll = lights.length; l < ll; l ++ ) {

				light = lights[ l ];

				if ( light.onlyShadow ) continue;

				color = light.color;
				intensity = light.intensity;
				distance = light.distance;

				if ( light instanceof THREE.AmbientLight ) {

					if ( ! light.visible ) continue;

					r += color.r;
					g += color.g;
					b += color.b;

				} else if ( light instanceof THREE.DirectionalLight ) {

					dirCount += 1;

					if ( ! light.visible ) continue;

					_direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.transformDirection( viewMatrix );

					dirOffset = dirLength * 3;

					dirPositions[ dirOffset + 0 ] = _direction.x;
					dirPositions[ dirOffset + 1 ] = _direction.y;
					dirPositions[ dirOffset + 2 ] = _direction.z;

					setColorLinear( dirColors, dirOffset, color, intensity );

					dirLength += 1;

				} else if ( light instanceof THREE.PointLight ) {

					pointCount += 1;

					if ( ! light.visible ) continue;

					pointOffset = pointLength * 3;

					setColorLinear( pointColors, pointOffset, color, intensity );

					_vector3.setFromMatrixPosition( light.matrixWorld );
					_vector3.applyMatrix4( viewMatrix );

					pointPositions[ pointOffset + 0 ] = _vector3.x;
					pointPositions[ pointOffset + 1 ] = _vector3.y;
					pointPositions[ pointOffset + 2 ] = _vector3.z;

					// distance is 0 if decay is 0, because there is no attenuation at all.
					pointDistances[ pointLength ] = distance;
					pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

					pointLength += 1;

				} else if ( light instanceof THREE.SpotLight ) {

					spotCount += 1;

					if ( ! light.visible ) continue;

					spotOffset = spotLength * 3;

					setColorLinear( spotColors, spotOffset, color, intensity );

					_direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.copy( _direction ).applyMatrix4( viewMatrix );

					spotPositions[ spotOffset + 0 ] = _vector3.x;
					spotPositions[ spotOffset + 1 ] = _vector3.y;
					spotPositions[ spotOffset + 2 ] = _vector3.z;

					spotDistances[ spotLength ] = distance;

					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.transformDirection( viewMatrix );

					spotDirections[ spotOffset + 0 ] = _direction.x;
					spotDirections[ spotOffset + 1 ] = _direction.y;
					spotDirections[ spotOffset + 2 ] = _direction.z;

					spotAnglesCos[ spotLength ] = Math.cos( light.angle );
					spotExponents[ spotLength ] = light.exponent;
					spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

					spotLength += 1;

				} else if ( light instanceof THREE.HemisphereLight ) {

					hemiCount += 1;

					if ( ! light.visible ) continue;

					_direction.setFromMatrixPosition( light.matrixWorld );
					_direction.transformDirection( viewMatrix );

					hemiOffset = hemiLength * 3;

					hemiPositions[ hemiOffset + 0 ] = _direction.x;
					hemiPositions[ hemiOffset + 1 ] = _direction.y;
					hemiPositions[ hemiOffset + 2 ] = _direction.z;

					skyColor = light.color;
					groundColor = light.groundColor;

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

					hemiLength += 1;

				}

			}

			// null eventual remains from removed lights
			// (this is to avoid if in shader)

			for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
			for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
			for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

			zlights.directional.length = dirLength;
			zlights.point.length = pointLength;
			zlights.spot.length = spotLength;
			zlights.hemi.length = hemiLength;

			zlights.ambient[ 0 ] = r;
			zlights.ambient[ 1 ] = g;
			zlights.ambient[ 2 ] = b;

		}

		// GL state setting

		this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

			if ( cullFace === THREE.CullFaceNone ) {

				state.disable( _gl.CULL_FACE );

			} else {

				if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

					_gl.frontFace( _gl.CW );

				} else {

					_gl.frontFace( _gl.CCW );

				}

				if ( cullFace === THREE.CullFaceBack ) {

					_gl.cullFace( _gl.BACK );

				} else if ( cullFace === THREE.CullFaceFront ) {

					_gl.cullFace( _gl.FRONT );

				} else {

					_gl.cullFace( _gl.FRONT_AND_BACK );

				}

				state.enable( _gl.CULL_FACE );

			}

		};

		// Textures

		function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

			var extension;

			if ( isImagePowerOfTwo ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

			} else {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

				if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );

				}

			}

			extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension ) {

				if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function uploadTexture( textureProperties, texture, slot ) {

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				_infoMemory.textures ++;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			texture.image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

			var image = texture.image,
			isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture instanceof THREE.DataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture instanceof THREE.CompressedTexture ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

							state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				}

			}

			if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		this.setTexture = function ( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				var image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
					return;

				}

				if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
					return;

				}

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		};

		function clampToMaxSize ( image, maxSize ) {

			if ( image.width > maxSize || image.height > maxSize ) {

				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.

				var scale = maxSize / Math.max( image.width, image.height );

				var canvas = document.createElement( 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

				console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

				return canvas;

			}

			return image;

		}

		function setCubeTexture ( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.image.length === 6 ) {

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					if ( ! textureProperties.__image__webglTextureCube ) {

						texture.addEventListener( 'dispose', onTextureDispose );

						textureProperties.__image__webglTextureCube = _gl.createTexture();

						_infoMemory.textures ++;

					}

					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

					var isCompressed = texture instanceof THREE.CompressedTexture;
					var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

					var cubeImage = [];

					for ( var i = 0; i < 6; i ++ ) {

						if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

						} else {

							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

						}

					}

					var image = cubeImage[ 0 ],
					isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
					glFormat = paramThreeToGL( texture.format ),
					glType = paramThreeToGL( texture.type );

					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed ) {

							if ( isDataTexture ) {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							var mipmap, mipmaps = cubeImage[ i ].mipmaps;

							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

								mipmap = mipmaps[ j ];

								if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									} else {

										console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

									}

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

					if ( texture.generateMipmaps && isImagePowerOfTwo ) {

						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

					}

					textureProperties.__version = texture.version;

					if ( texture.onUpdate ) texture.onUpdate( texture );

				} else {

					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				}

			}

		}

		function setCubeTextureDynamic ( texture, slot ) {

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

		}

		// Render targets

		function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get( renderTarget ).__webglTexture, 0 );

		}

		function setupRenderBuffer ( renderbuffer, renderTarget ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			/* For some reason this is not working. Defaulting to RGBA4.
			} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
			*/

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

			}

		}

		this.setRenderTarget = function ( renderTarget ) {

			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

				var renderTargetProperties = properties.get( renderTarget );

				if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
				if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

				renderTargetProperties.__webglTexture = _gl.createTexture();

				_infoMemory.textures ++;

				// Setup texture, create render and frame buffers

				var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
					glFormat = paramThreeToGL( renderTarget.format ),
					glType = paramThreeToGL( renderTarget.type );

				if ( isCube ) {

					renderTargetProperties.__webglFramebuffer = [];
					renderTargetProperties.__webglRenderbuffer = [];

					state.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTargetProperties.__webglTexture );

					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
						renderTargetProperties.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

						state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

						setupFrameBuffer( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
						setupRenderBuffer( renderTargetProperties.__webglRenderbuffer[ i ], renderTarget );

					}

					if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				} else {

					renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

					if ( renderTarget.shareDepthFrom ) {

						renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

					} else {

						renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();

					}

					state.bindTexture( _gl.TEXTURE_2D, renderTargetProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

					if ( renderTarget.shareDepthFrom ) {

						if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

						} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

						}

					} else {

						setupRenderBuffer( renderTargetProperties.__webglRenderbuffer, renderTarget );

					}

					if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

				}

				// Release everything

				if ( isCube ) {

					state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

				} else {

					state.bindTexture( _gl.TEXTURE_2D, null );

				}

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

			var framebuffer, width, height, vx, vy;

			if ( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );

				if ( isCube ) {

					framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

				} else {

					framebuffer = renderTargetProperties.__webglFramebuffer;

				}

				width = renderTarget.width;
				height = renderTarget.height;

				vx = 0;
				vy = 0;

			} else {

				framebuffer = null;

				width = _viewportWidth;
				height = _viewportHeight;

				vx = _viewportX;
				vy = _viewportY;

			}

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.viewport( vx, vy, width, height );

				_currentFramebuffer = framebuffer;

			}

			_currentWidth = width;
			_currentHeight = height;

		};

		this.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {

			if ( ! ( renderTarget instanceof THREE.WebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			if ( properties.get( renderTarget ).__webglFramebuffer ) {

				if ( renderTarget.format !== THREE.RGBAFormat ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );
					return;

				}

				var restore = false;

				if ( properties.get( renderTarget ).__webglFramebuffer !== _currentFramebuffer ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, properties.get( renderTarget ).__webglFramebuffer );

					restore = true;

				}

				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

					_gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

				if ( restore ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

				}

			}

		};

		function updateRenderTargetMipmap ( renderTarget ) {

			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( renderTarget ).__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				state.bindTexture( _gl.TEXTURE_2D, properties.get( renderTarget ).__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_2D );
				state.bindTexture( _gl.TEXTURE_2D, null );

			}

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback ( f ) {

			if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		// Map three.js constants to WebGL constants

		function paramThreeToGL ( p ) {

			var extension;

			if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
			if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
			if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

			if ( p === THREE.NearestFilter ) return _gl.NEAREST;
			if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
			if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

			if ( p === THREE.LinearFilter ) return _gl.LINEAR;
			if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
			if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

			if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
			if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

			if ( p === THREE.ByteType ) return _gl.BYTE;
			if ( p === THREE.ShortType ) return _gl.SHORT;
			if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
			if ( p === THREE.IntType ) return _gl.INT;
			if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
			if ( p === THREE.FloatType ) return _gl.FLOAT;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

			}

			if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
			if ( p === THREE.RGBFormat ) return _gl.RGB;
			if ( p === THREE.RGBAFormat ) return _gl.RGBA;
			if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
			if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

			if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
			if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
			if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

			if ( p === THREE.ZeroFactor ) return _gl.ZERO;
			if ( p === THREE.OneFactor ) return _gl.ONE;
			if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
			if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
			if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
			if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
			if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
			if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

			if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
			if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
			if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			}

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			}

			extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				if ( p === THREE.MinEquation ) return extension.MIN_EXT;
				if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

			}

			return 0;

		}

		// DEPRECATED

		this.supportsFloatTextures = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return extensions.get( 'OES_texture_float' );

		};

		this.supportsHalfFloatTextures = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return extensions.get( 'OES_texture_half_float' );

		};

		this.supportsStandardDerivatives = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return extensions.get( 'OES_standard_derivatives' );

		};

		this.supportsCompressedTextureS3TC = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return extensions.get( 'WEBGL_compressed_texture_s3tc' );

		};

		this.supportsCompressedTexturePVRTC = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		};

		this.supportsBlendMinMax = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return extensions.get( 'EXT_blend_minmax' );

		};

		this.supportsVertexTextures = function () {

			return capabilities.vertexTextures;

		};

		this.supportsInstancedArrays = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return extensions.get( 'ANGLE_instanced_arrays' );

		};

		//

		this.initMaterial = function () {

			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

		};

		this.addPrePlugin = function () {

			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

		};

		this.addPostPlugin = function () {

			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

		};

		this.updateShadowMap = function () {

			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

		};

		Object.defineProperties( this, {
			shadowMapEnabled: {
				get: function () {

					return shadowMap.enabled;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
					shadowMap.enabled = value;

				}
			},
			shadowMapType: {
				get: function () {

					return shadowMap.type;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
					shadowMap.type = value;

				}
			},
			shadowMapCullFace: {
				get: function () {

					return shadowMap.cullFace;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
					shadowMap.cullFace = value;

				}
			},
			shadowMapDebug: {
				get: function () {

					return shadowMap.debug;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
					shadowMap.debug = value;

				}
			}
		} );

	};

	// File:src/renderers/WebGLRenderTarget.js

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.WebGLRenderTarget = function ( width, height, options ) {

		this.uuid = THREE.Math.generateUUID();

		this.width = width;
		this.height = height;

		options = options || {};

		this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

		this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
		this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

		this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );

		this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
		this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

		this.generateMipmaps = true;

		this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

	};

	THREE.WebGLRenderTarget.prototype = {

		constructor: THREE.WebGLRenderTarget,

		setSize: function ( width, height ) {

			if ( this.width !== width || this.height !== height ) {

				this.width = width;
				this.height = height;

				this.dispose();

			}

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.width = source.width;
			this.height = source.height;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );

			this.format = source.format;
			this.type = source.type;

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;

			this.generateMipmaps = source.generateMipmaps;

			this.shareDepthFrom = source.shareDepthFrom;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

	// File:src/renderers/WebGLRenderTargetCube.js

	/**
	 * @author alteredq / http://alteredqualia.com
	 */

	THREE.WebGLRenderTargetCube = function ( width, height, options ) {

		THREE.WebGLRenderTarget.call( this, width, height, options );

		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

	};

	THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
	THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

	// File:src/renderers/webgl/WebGLBufferRenderer.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			_gl.drawArrays( mode, start, count );

			_infoRender.calls ++;
			_infoRender.vertices += count;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

		}

		function renderInstances( geometry ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

			var position = geometry.attributes.position;

			if ( position instanceof THREE.InterleavedBufferAttribute ) {

				extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );

			} else {

				extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );

			}

		}

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	};

	// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		var type, size;

		function setIndex( index ) {

			if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

				type = _gl.UNSIGNED_INT;
				size = 4;

			} else {

				type = _gl.UNSIGNED_SHORT;
				size = 2;

			}

		}

		function render( start, count ) {

			_gl.drawElements( mode, count, type, start * size );

			_infoRender.calls ++;
			_infoRender.vertices += count;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

		}

		function renderInstances( geometry ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

			var index = geometry.index;

			extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount );

		}

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	};

	// File:src/renderers/webgl/WebGLExtensions.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLExtensions = function ( gl ) {

		var extensions = {};

		this.get = function ( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			var extension;

			switch ( name ) {

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			extensions[ name ] = extension;

			return extension;

		};

	};

	// File:src/renderers/webgl/WebGLCapabilities.js

	THREE.WebGLCapabilities = function ( gl, extensions, parameters ) {

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		this.getMaxPrecision = getMaxPrecision;

		this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
		this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

		this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

		this.vertexTextures = this.maxVertexTextures > 0;
		this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
		this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

		var _maxPrecision = getMaxPrecision( this.precision );

		if ( _maxPrecision !== this.precision ) {

			console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
			this.precision = _maxPrecision;

		}

		if ( this.logarithmicDepthBuffer ) {

			this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );

		}

	};

	// File:src/renderers/webgl/WebGLGeometries.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLGeometries = function ( gl, properties, info ) {

		var geometries = {};

		function get( object ) {

			var geometry = object.geometry;

			if ( geometries[ geometry.id ] !== undefined ) {

				return geometries[ geometry.id ];

			}

			geometry.addEventListener( 'dispose', onGeometryDispose );

			var buffergeometry;

			if ( geometry instanceof THREE.BufferGeometry ) {

				buffergeometry = geometry;

			} else if ( geometry instanceof THREE.Geometry ) {

				if ( geometry._bufferGeometry === undefined ) {

					geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );

				}

				buffergeometry = geometry._bufferGeometry;

			}

			geometries[ geometry.id ] = buffergeometry;

			info.memory.geometries ++;

			return buffergeometry;

		}

		function onGeometryDispose( event ) {

			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];

			deleteAttributes( buffergeometry.attributes );

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			var property = properties.get( geometry );
			if ( property.wireframe ) deleteAttribute( property.wireframe );

			info.memory.geometries --;

		}

		function getAttributeBuffer( attribute ) {

			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

				return properties.get( attribute.data ).__webglBuffer;

			}

			return properties.get( attribute ).__webglBuffer;

		}

		function deleteAttribute( attribute ) {

			var buffer = getAttributeBuffer( attribute );

			if ( buffer !== undefined ) {

				gl.deleteBuffer( buffer );
				removeAttributeBuffer( attribute );

			}

		}

		function deleteAttributes( attributes ) {

			for ( var name in attributes ) {

				deleteAttribute( attributes[ name ] );

			}

		}

		function removeAttributeBuffer( attribute ) {

			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

				properties.delete( attribute.data );

			} else {

				properties.delete( attribute );

			}

		}

		this.get = get;

	};

	// File:src/renderers/webgl/WebGLObjects.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLObjects = function ( gl, properties, info ) {

		var geometries = new THREE.WebGLGeometries( gl, properties, info );

		//

		function update( object ) {

			// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

			var geometry = geometries.get( object );

			if ( object.geometry instanceof THREE.Geometry ) {

				geometry.updateFromObject( object );

			}

			var index = geometry.index;
			var attributes = geometry.attributes;

			if ( index !== null ) {

				updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

			}

			for ( var name in attributes ) {

				updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

			}

			// morph targets

			var morphAttributes = geometry.morphAttributes;

			for ( var name in morphAttributes ) {

				var array = morphAttributes[ name ];

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					updateAttribute( array[ i ], gl.ARRAY_BUFFER );

				}

			}

			return geometry;

		}

		function updateAttribute( attribute, bufferType ) {

			var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

			var attributeProperties = properties.get( data );

			if ( attributeProperties.__webglBuffer === undefined ) {

				createBuffer( attributeProperties, data, bufferType );

			} else if ( attributeProperties.version !== data.version ) {

				updateBuffer( attributeProperties, data, bufferType );

			}

		}

		function createBuffer( attributeProperties, data, bufferType ) {

			attributeProperties.__webglBuffer = gl.createBuffer();
			gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

			var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

			gl.bufferData( bufferType, data.array, usage );

			attributeProperties.version = data.version;

		}

		function updateBuffer( attributeProperties, data, bufferType ) {

			gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

			if ( data.dynamic === false || data.updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, data.array );

			} else if ( data.updateRange.count === 0 ) {

				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

			} else {

				gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
								  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

				data.updateRange.count = 0; // reset range

			}

			attributeProperties.version = data.version;

		}

		function getAttributeBuffer( attribute ) {

			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

				return properties.get( attribute.data ).__webglBuffer;

			}

			return properties.get( attribute ).__webglBuffer;

		}

		function getWireframeAttribute( geometry ) {

			var property = properties.get( geometry );

			if ( property.wireframe !== undefined ) {

				return property.wireframe;

			}

			var indices = [];

			var index = geometry.index;
			var attributes = geometry.attributes;
			var position = attributes.position;

			// console.time( 'wireframe' );

			if ( index !== null ) {

				var edges = {};
				var array = index.array;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];

					if ( checkEdge( edges, a, b ) ) indices.push( a, b );
					if ( checkEdge( edges, b, c ) ) indices.push( b, c );
					if ( checkEdge( edges, c, a ) ) indices.push( c, a );

				}

			} else {

				var array = attributes.position.array;

				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					var a = i + 0;
					var b = i + 1;
					var c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			// console.timeEnd( 'wireframe' );

			var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
			var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );

			updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

			property.wireframe = attribute;

			return attribute;

		}

		function checkEdge( edges, a, b ) {

			if ( a > b ) {

				var tmp = a;
				a = b;
				b = tmp;

			}

			var list = edges[ a ];

			if ( list === undefined ) {

				edges[ a ] = [ b ];
				return true;

			} else if ( list.indexOf( b ) === -1 ) {

				list.push( b );
				return true;

			}

			return false;

		}

		this.getAttributeBuffer = getAttributeBuffer;
		this.getWireframeAttribute = getWireframeAttribute;

		this.update = update;

	};

	// File:src/renderers/webgl/WebGLProgram.js

	THREE.WebGLProgram = ( function () {

		var programIdCount = 0;

		function generateDefines( defines ) {

			var chunks = [];

			for ( var name in defines ) {

				var value = defines[ name ];

				if ( value === false ) continue;

				chunks.push( '#define ' + name + ' ' + value );

			}

			return chunks.join( '\n' );

		}

		function fetchUniformLocations( gl, program, identifiers ) {

			var uniforms = {};

			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

			for ( var i = 0; i < n; i ++ ) {

				var info = gl.getActiveUniform( program, i );
				var name = info.name;
				var location = gl.getUniformLocation( program, name );

				// console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

				var suffixPos = name.lastIndexOf( '[0]' );
				if ( suffixPos !== - 1 && suffixPos === name.length - 3 ) {

					uniforms[ name.substr( 0, suffixPos ) ] = location;

				}

				uniforms[ name ] = location;

			}

			return uniforms;

		}

		function fetchAttributeLocations( gl, program, identifiers ) {

			var attributes = {};

			var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

			for ( var i = 0; i < n; i ++ ) {

				var info = gl.getActiveAttrib( program, i );
				var name = info.name;

				// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

				attributes[ name ] = gl.getAttribLocation( program, name );

			}

			return attributes;

		}

		function filterEmptyLine( string ) {

			return string !== '';

		}

		return function WebGLProgram( renderer, code, material, parameters ) {

			var gl = renderer.context;

			var defines = material.defines;

			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;

			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

			if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

			} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

			}

			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

			if ( parameters.envMap ) {

				switch ( material.envMap.mapping ) {

					case THREE.CubeReflectionMapping:
					case THREE.CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;

					case THREE.EquirectangularReflectionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;

					case THREE.SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;

				}

				switch ( material.envMap.mapping ) {

					case THREE.CubeRefractionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;

				}

				switch ( material.combine ) {

					case THREE.MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;

					case THREE.MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;

					case THREE.AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;

				}

			}

			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

			// console.log( 'building new program ' );

			//

			var customDefines = generateDefines( defines );

			//

			var program = gl.createProgram();

			var prefixVertex, prefixFragment;

			if ( material instanceof THREE.RawShaderMaterial ) {

				prefixVertex = '';
				prefixFragment = '';

			} else {

				prefixVertex = [

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					'#define SHADER_NAME ' + material.__webglShader.name,

					customDefines,

					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

					renderer.gammaInput ? '#define GAMMA_INPUT' : '',
					renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
					'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
					'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
					'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

					'#define MAX_SHADOWS ' + parameters.maxShadows,

					'#define MAX_BONES ' + parameters.maxBones,

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',

					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',


					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',

					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',

					'#ifdef USE_COLOR',

					'	attribute vec3 color;',

					'#endif',

					'#ifdef USE_MORPHTARGETS',

					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',

					'	#ifdef USE_MORPHNORMALS',

					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',

					'	#else',

					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',

					'	#endif',

					'#endif',

					'#ifdef USE_SKINNING',

					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',

					'#endif',

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

				prefixFragment = [

					parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					'#define SHADER_NAME ' + material.__webglShader.name,

					customDefines,

					'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
					'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
					'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
					'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

					'#define MAX_SHADOWS ' + parameters.maxShadows,

					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

					renderer.gammaInput ? '#define GAMMA_INPUT' : '',
					renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.metal ? '#define METAL' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

			}

			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;

			var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
			var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );

			// Force a particular attribute to index 0.

			if ( material.index0AttributeName !== undefined ) {

				gl.bindAttribLocation( program, 0, material.index0AttributeName );

			} else if ( parameters.morphTargets === true ) {

				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );

			}

			gl.linkProgram( program );

			var programLog = gl.getProgramInfoLog( program );
			var vertexLog = gl.getShaderInfoLog( glVertexShader );
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

			var runnable = true;
			var haveDiagnostics = true;

			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

				runnable = false;

				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				this.diagnostics = {

					runnable: runnable,
					material: material,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

			// clean up

			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );

			// set up caching for uniform locations

			var cachedUniforms;

			this.getUniforms = function() {

				if ( cachedUniforms === undefined ) {

					cachedUniforms = fetchUniformLocations( gl, program );

				}

				return cachedUniforms;

			};

			// set up caching for attribute locations

			var cachedAttributes;

			this.getAttributes = function() {

				if ( cachedAttributes === undefined ) {

					cachedAttributes = fetchAttributeLocations( gl, program );

				}

				return cachedAttributes;

			};

			// free resource

			this.destroy = function() {

				gl.deleteProgram( program );
				this.program = undefined;

			};

			// DEPRECATED

			Object.defineProperties( this, {

				uniforms: {
					get: function() {

						console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();

					}
				},

				attributes: {
					get: function() {

						console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();

					}
				}

			} );


			//

			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;

			return this;

		};

	} )();

	// File:src/renderers/webgl/WebGLPrograms.js

	THREE.WebGLPrograms = function ( renderer, capabilities ) {

		var programs = [];

		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points'
		};

		var parameterNames = [
			"precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
			"lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "specularMap",
			"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights",
			"maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled",
			"shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided",
			"flipSided"
		];


		function allocateBones ( object ) {

			if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				var maxBones = nVertexMatrices;

				if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

					maxBones = Math.min( object.skeleton.bones.length, maxBones );

					if ( maxBones < object.skeleton.bones.length ) {

						console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

					}

				}

				return maxBones;

			}

		}

		function allocateLights( lights ) {

			var dirLights = 0;
			var pointLights = 0;
			var spotLights = 0;
			var hemiLights = 0;

			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

				var light = lights[ l ];

				if ( light.onlyShadow || light.visible === false ) continue;

				if ( light instanceof THREE.DirectionalLight ) dirLights ++;
				if ( light instanceof THREE.PointLight ) pointLights ++;
				if ( light instanceof THREE.SpotLight ) spotLights ++;
				if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

			}

			return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

		}

		function allocateShadows( lights ) {

			var maxShadows = 0;

			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

				var light = lights[ l ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight ) maxShadows ++;
				if ( light instanceof THREE.DirectionalLight ) maxShadows ++;

			}

			return maxShadows;

		}

		this.getParameters = function ( material, lights, fog, object ) {

			var shaderID = shaderIDs[ material.type ];
			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxLightCount = allocateLights( lights );
			var maxShadows = allocateShadows( lights );
			var maxBones = allocateBones( object );
			var precision = renderer.getPrecision();

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			var parameters = {

				shaderID: shaderID,

				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,

				map: !! material.map,
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				displacementMap: !! material.displacementMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				combine: material.combine,

				vertexColors: material.vertexColors,

				fog: fog,
				useFog: material.fog,
				fogExp: fog instanceof THREE.FogExp2,

				flatShading: material.shading === THREE.FlatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

				skinning: material.skinning,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,

				maxDirLights: maxLightCount.directional,
				maxPointLights: maxLightCount.point,
				maxSpotLights: maxLightCount.spot,
				maxHemiLights: maxLightCount.hemi,

				maxShadows: maxShadows,
				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && maxShadows > 0,
				shadowMapType: renderer.shadowMap.type,
				shadowMapDebug: renderer.shadowMap.debug,

				alphaTest: material.alphaTest,
				metal: material.metal,
				doubleSided: material.side === THREE.DoubleSide,
				flipSided: material.side === THREE.BackSide

			};

			return parameters;

		};

		this.getProgramCode = function ( material, parameters ) {

			var chunks = [];

			if ( parameters.shaderID ) {

				chunks.push( parameters.shaderID );

			} else {

				chunks.push( material.fragmentShader );
				chunks.push( material.vertexShader );

			}

			if ( material.defines !== undefined ) {

				for ( var name in material.defines ) {

					chunks.push( name );
					chunks.push( material.defines[ name ] );

				}

			}

			for ( var i = 0; i < parameterNames.length; i ++ ) {

				var parameterName = parameterNames[ i ];
				chunks.push( parameterName );
				chunks.push( parameters[ parameterName ] );

			}

			return chunks.join();

		};

		this.acquireProgram = function ( material, parameters, code ) {

			var program;

			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

				var programInfo = programs[ p ];

				if ( programInfo.code === code ) {

					program = programInfo;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new THREE.WebGLProgram( renderer, code, material, parameters );
				programs.push( program );

			}

			return program;

		};

		this.releaseProgram = function( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		};

		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;

	};

	// File:src/renderers/webgl/WebGLProperties.js

	/**
	* @author fordacious / fordacious.github.io
	*/

	THREE.WebGLProperties = function () {

		var properties = {};

		this.get = function ( object ) {

			var uuid = object.uuid;
			var map = properties[ uuid ];

			if ( map === undefined ) {

				map = {};
				properties[ uuid ] = map;

			}

			return map;

		};

		this.delete = function ( object ) {

			delete properties[ object.uuid ];

		};

		this.clear = function () {

			properties = {};

		};

	};

	// File:src/renderers/webgl/WebGLShader.js

	THREE.WebGLShader = ( function () {

		var addLineNumbers = function ( string ) {

			var lines = string.split( '\n' );

			for ( var i = 0; i < lines.length; i ++ ) {

				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

			}

			return lines.join( '\n' );

		};

		return function WebGLShader( gl, type, string ) {

			var shader = gl.createShader( type );

			gl.shaderSource( shader, string );
			gl.compileShader( shader );

			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

			}

			if ( gl.getShaderInfoLog( shader ) !== '' ) {

				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

			}

			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			return shader;

		};

	} )();

	// File:src/renderers/webgl/WebGLShadowMap.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {

		var _gl = _renderer.context,
		_state = _renderer.state,
		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4(),

		_min = new THREE.Vector3(),
		_max = new THREE.Vector3(),

		_matrixPosition = new THREE.Vector3(),

		_renderList = [];

		// init

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		var _depthMaterial = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader
		 } );

		var _depthMaterialMorph = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: true
		} );

		var _depthMaterialSkin = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			skinning: true
		} );

		var _depthMaterialMorphSkin = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: true,
			skinning: true
		} );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

		//

		var scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = THREE.PCFShadowMap;
		this.cullFace = THREE.CullFaceFront;

		this.render = function ( scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			// set GL state for depth map

			_gl.clearColor( 1, 1, 1, 1 );
			_state.disable( _gl.BLEND );

			_state.enable( _gl.CULL_FACE );
			_gl.frontFace( _gl.CCW );

			if ( scope.cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.BACK );

			}

			_state.setDepthTest( true );

			// render depth map

			for ( var i = 0, il = _lights.length; i < il; i ++ ) {

				var light = _lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( ! light.shadowMap ) {

					var shadowFilter = THREE.LinearFilter;

					if ( scope.type === THREE.PCFSoftShadowMap ) {

						shadowFilter = THREE.NearestFilter;

					}

					var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

					light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
					light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

					light.shadowMatrix = new THREE.Matrix4();

				}

				if ( ! light.shadowCamera ) {

					if ( light instanceof THREE.SpotLight ) {

						light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

					} else if ( light instanceof THREE.DirectionalLight ) {

						light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

					} else {

						console.error( "THREE.ShadowMapPlugin: Unsupported light type for shadow", light );
						continue;

					}

					scene.add( light.shadowCamera );

					if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

				}

				if ( light.shadowCameraVisible && ! light.cameraHelper ) {

					light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
					scene.add( light.cameraHelper );

				}

				var shadowMap = light.shadowMap;
				var shadowMatrix = light.shadowMatrix;
				var shadowCamera = light.shadowCamera;

				//

				shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
				_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
				shadowCamera.lookAt( _matrixPosition );
				shadowCamera.updateMatrixWorld();

				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

				//

				if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
				if ( light.shadowCameraVisible ) light.cameraHelper.update();

				// compute shadow matrix

				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);

				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				// update camera matrices and frustum

				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				// render shadow map

				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();

				// set object matrices & frustum culling

				_renderList.length = 0;

				projectObject( scene, shadowCamera );


				// render regular objects

				for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

					var object = _renderList[ j ];
					var geometry = _objects.update( object );
					var material = object.material;

					if ( material instanceof THREE.MeshFaceMaterial ) {

						var groups = geometry.groups;
						var materials = material.materials;

						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

							var group = groups[ k ];
							var groupMaterial = materials[ group.materialIndex ];

							if ( groupMaterial.visible === true ) {

								_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, getDepthMaterial( object, groupMaterial ), object, group );

							}

						}

					} else {

						_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, getDepthMaterial( object, material ), object );

					}

				}

			}

			// restore GL state

			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();

			_renderer.setClearColor( clearColor, clearAlpha );
			_state.enable( _gl.BLEND );

			if ( scope.cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.BACK );

			}

			_renderer.resetGLState();

			scope.needsUpdate = false;

		};

		function getDepthMaterial( object, material ) {

			var geometry = object.geometry;

			var useMorphing = geometry.morphTargets !== undefined && geometry.morphTargets.length > 0 && material.morphTargets;
			var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

			var depthMaterial;

			if ( object.customDepthMaterial ) {

				depthMaterial = object.customDepthMaterial;

			} else if ( useSkinning ) {

				depthMaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

			} else if ( useMorphing ) {

				depthMaterial = _depthMaterialMorph;

			} else {

				depthMaterial = _depthMaterial;

			}

			depthMaterial.visible = material.visible;
			depthMaterial.wireframe = material.wireframe;
			depthMaterial.wireframeLinewidth = material.wireframeLinewidth;

			return depthMaterial;

		}

		function projectObject( object, camera ) {

			if ( object.visible === false ) return;

			if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

				if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

					var material = object.material;

					if ( material.visible === true ) {

						object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
						_renderList.push( object );

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera );

			}

		}

	};

	// File:src/renderers/webgl/WebGLState.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {

		var _this = this;

		var newAttributes = new Uint8Array( 16 );
		var enabledAttributes = new Uint8Array( 16 );

		var capabilities = {};

		var compressedTextureFormats = null;

		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;

		var currentDepthFunc = null;
		var currentDepthWrite = null;

		var currentColorWrite = null;

		var currentFlipSided = null;

		var currentLineWidth = null;

		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

		var currentTextureSlot = undefined;
		var currentBoundTextures = {};

		this.init = function () {

			gl.clearColor( 0, 0, 0, 1 );
			gl.clearDepth( 1 );
			gl.clearStencil( 0 );

			this.enable( gl.DEPTH_TEST );
			gl.depthFunc( gl.LEQUAL );

			gl.frontFace( gl.CCW );
			gl.cullFace( gl.BACK );
			this.enable( gl.CULL_FACE );

			this.enable( gl.BLEND );
			gl.blendEquation( gl.FUNC_ADD );
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

		};

		this.initAttributes = function () {

			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

				newAttributes[ i ] = 0;

			}

		};

		this.enableAttribute = function ( attribute ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

		};

		this.disableUnusedAttributes = function () {

			for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		};

		this.enable = function ( id ) {

			if ( capabilities[ id ] !== true ) {

				gl.enable( id );
				capabilities[ id ] = true;

			}

		};

		this.disable = function ( id ) {

			if ( capabilities[ id ] !== false ) {

				gl.disable( id );
				capabilities[ id ] = false;

			}

		};

		this.getCompressedTextureFormats = function () {

			if ( compressedTextureFormats === null ) {

				compressedTextureFormats = [];

				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

					var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

					for ( var i = 0; i < formats.length; i ++ ) {

						compressedTextureFormats.push( formats[ i ] );

					}

				}

			}

			return compressedTextureFormats;

		};

		this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

			if ( blending !== currentBlending ) {

				if ( blending === THREE.NoBlending ) {

					this.disable( gl.BLEND );

				} else if ( blending === THREE.AdditiveBlending ) {

					this.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

				} else if ( blending === THREE.SubtractiveBlending ) {

					// TODO: Find blendFuncSeparate() combination

					this.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

				} else if ( blending === THREE.MultiplyBlending ) {

					// TODO: Find blendFuncSeparate() combination

					this.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

				} else if ( blending === THREE.CustomBlending ) {

					this.enable( gl.BLEND );

				} else {

					this.enable( gl.BLEND );
					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				}

				currentBlending = blending;

			}

			if ( blending === THREE.CustomBlending ) {

				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;

				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

					gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;

				}

				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

					gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;

				}

			} else {

				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

			}

		};

		this.setDepthFunc = function ( depthFunc ) {

			if ( currentDepthFunc !== depthFunc ) {

				if ( depthFunc ) {

					switch ( depthFunc ) {

						case THREE.NeverDepth:

							gl.depthFunc( gl.NEVER );
							break;

						case THREE.AlwaysDepth:

							gl.depthFunc( gl.ALWAYS );
							break;

						case THREE.LessDepth:

							gl.depthFunc( gl.LESS );
							break;

						case THREE.LessEqualDepth:

							gl.depthFunc( gl.LEQUAL );
							break;

						case THREE.EqualDepth:

							gl.depthFunc( gl.EQUAL );
							break;

						case THREE.GreaterEqualDepth:

							gl.depthFunc( gl.GEQUAL );
							break;

						case THREE.GreaterDepth:

							gl.depthFunc( gl.GREATER );
							break;

						case THREE.NotEqualDepth:

							gl.depthFunc( gl.NOTEQUAL );
							break;

						default:

							gl.depthFunc( gl.LEQUAL );

					}

				} else {

					gl.depthFunc( gl.LEQUAL );

				}

				currentDepthFunc = depthFunc;

			}

		};

		this.setDepthTest = function ( depthTest ) {

			if ( depthTest ) {

				this.enable( gl.DEPTH_TEST );

			} else {

				this.disable( gl.DEPTH_TEST );

			}

		};

		this.setDepthWrite = function ( depthWrite ) {

			if ( currentDepthWrite !== depthWrite ) {

				gl.depthMask( depthWrite );
				currentDepthWrite = depthWrite;

			}

		};

		this.setColorWrite = function ( colorWrite ) {

			if ( currentColorWrite !== colorWrite ) {

				gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
				currentColorWrite = colorWrite;

			}

		};

		this.setFlipSided = function ( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( gl.CW );

				} else {

					gl.frontFace( gl.CCW );

				}

				currentFlipSided = flipSided;

			}

		};

		this.setLineWidth = function ( width ) {

			if ( width !== currentLineWidth ) {

				gl.lineWidth( width );

				currentLineWidth = width;

			}

		};

		this.setPolygonOffset = function ( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				this.enable( gl.POLYGON_OFFSET_FILL );

			} else {

				this.disable( gl.POLYGON_OFFSET_FILL );

			}

			if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		};

		this.setScissorTest = function ( scissorTest ) {

			if ( scissorTest ) {

				this.enable( gl.SCISSOR_TEST );

			} else {

				this.disable( gl.SCISSOR_TEST );

			}

		};

		// texture

		this.activeTexture = function ( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		this.bindTexture = function ( webglType, webglTexture ) {

			if ( currentTextureSlot === undefined ) {

				_this.activeTexture();

			}

			var boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		};

		this.compressedTexImage2D = function () {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( error );

			}

		};

		this.texImage2D = function () {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( error );

			}

		};

		//

		this.reset = function () {

			for ( var i = 0; i < enabledAttributes.length; i ++ ) {

				if ( enabledAttributes[ i ] === 1 ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

			capabilities = {};

			compressedTextureFormats = null;

			currentBlending = null;

			currentDepthWrite = null;
			currentColorWrite = null;

			currentFlipSided = null;

		};

	};

	// File:src/renderers/webgl/plugins/LensFlarePlugin.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.LensFlarePlugin = function ( renderer, flares ) {

		var gl = renderer.context;
		var state = renderer.state;

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
		var hasVertexTexture;

		var tempTexture, occlusionTexture;

		var init = function () {

			var vertices = new Float32Array( [
				- 1, - 1,  0, 0,
				 1, - 1,  1, 0,
				 1,  1,  1, 1,
				- 1,  1,  0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			// buffers

			vertexBuffer     = gl.createBuffer();
			elementBuffer    = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			// textures

			tempTexture      = gl.createTexture();
			occlusionTexture = gl.createTexture();

			state.bindTexture( gl.TEXTURE_2D, tempTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

			state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

			hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

			var shader;

			if ( hasVertexTexture ) {

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"uniform sampler2D occlusionMap;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if( renderType == 2 ) {",

								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							// pink square

							"if( renderType == 0 ) {",

								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

							// restore

							"} else if( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

			} else {

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if( renderType == 2 ) {",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"precision mediump float;",

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform sampler2D occlusionMap;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",

						"void main() {",

							// pink square

							"if( renderType == 0 ) {",

								"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

							// restore

							"} else if( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
								"visibility = ( 1.0 - visibility / 4.0 );",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * visibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

			}

			program = createProgram( shader );

			attributes = {
				vertex: gl.getAttribLocation ( program, "position" ),
				uv:     gl.getAttribLocation ( program, "uv" )
			};

			uniforms = {
				renderType:     gl.getUniformLocation( program, "renderType" ),
				map:            gl.getUniformLocation( program, "map" ),
				occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
				opacity:        gl.getUniformLocation( program, "opacity" ),
				color:          gl.getUniformLocation( program, "color" ),
				scale:          gl.getUniformLocation( program, "scale" ),
				rotation:       gl.getUniformLocation( program, "rotation" ),
				screenPosition: gl.getUniformLocation( program, "screenPosition" )
			};

		};

		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */

		this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

			if ( flares.length === 0 ) return;

			var tempPosition = new THREE.Vector3();

			var invAspect = viewportHeight / viewportWidth,
				halfViewportWidth = viewportWidth * 0.5,
				halfViewportHeight = viewportHeight * 0.5;

			var size = 16 / viewportHeight,
				scale = new THREE.Vector2( size * invAspect, size );

			var screenPosition = new THREE.Vector3( 1, 1, 0 ),
				screenPositionPixels = new THREE.Vector2( 1, 1 );

			if ( program === undefined ) {

				init();

			}

			gl.useProgram( program );

			state.initAttributes();
			state.enableAttribute( attributes.vertex );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();

			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/uniforms

			gl.uniform1i( uniforms.occlusionMap, 0 );
			gl.uniform1i( uniforms.map, 1 );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			state.disable( gl.CULL_FACE );
			gl.depthMask( false );

			for ( var i = 0, l = flares.length; i < l; i ++ ) {

				size = 16 / viewportHeight;
				scale.set( size * invAspect, size );

				// calc object screen position

				var flare = flares[ i ];

				tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

				tempPosition.applyMatrix4( camera.matrixWorldInverse );
				tempPosition.applyProjection( camera.projectionMatrix );

				// setup arrays for gl programs

				screenPosition.copy( tempPosition );

				screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
				screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

				// screen cull

				if ( hasVertexTexture || (
					screenPositionPixels.x > 0 &&
					screenPositionPixels.x < viewportWidth &&
					screenPositionPixels.y > 0 &&
					screenPositionPixels.y < viewportHeight ) ) {

					// save current RGB to temp texture

					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, null );
					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


					// render pink quad

					gl.uniform1i( uniforms.renderType, 0 );
					gl.uniform2f( uniforms.scale, scale.x, scale.y );
					gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

					state.disable( gl.BLEND );
					state.enable( gl.DEPTH_TEST );

					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


					// copy result to occlusionMap

					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


					// restore graphics

					gl.uniform1i( uniforms.renderType, 1 );
					state.disable( gl.DEPTH_TEST );

					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


					// update object positions

					flare.positionScreen.copy( screenPosition );

					if ( flare.customUpdateCallback ) {

						flare.customUpdateCallback( flare );

					} else {

						flare.updateLensFlares();

					}

					// render flares

					gl.uniform1i( uniforms.renderType, 2 );
					state.enable( gl.BLEND );

					for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

						var sprite = flare.lensFlares[ j ];

						if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;

							size = sprite.size * sprite.scale / viewportHeight;

							scale.x = size * invAspect;
							scale.y = size;

							gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
							gl.uniform2f( uniforms.scale, scale.x, scale.y );
							gl.uniform1f( uniforms.rotation, sprite.rotation );

							gl.uniform1f( uniforms.opacity, sprite.opacity );
							gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

							state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
							renderer.setTexture( sprite.texture, 1 );

							gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

						}

					}

				}

			}

			// restore gl

			state.enable( gl.CULL_FACE );
			state.enable( gl.DEPTH_TEST );
			gl.depthMask( true );

			renderer.resetGLState();

		};

		function createProgram ( shader ) {

			var program = gl.createProgram();

			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );

			var prefix = "precision " + renderer.getPrecision() + " float;\n";

			gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			gl.shaderSource( vertexShader, prefix + shader.vertexShader );

			gl.compileShader( fragmentShader );
			gl.compileShader( vertexShader );

			gl.attachShader( program, fragmentShader );
			gl.attachShader( program, vertexShader );

			gl.linkProgram( program );

			return program;

		}

	};

	// File:src/renderers/webgl/plugins/SpritePlugin.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SpritePlugin = function ( renderer, sprites ) {

		var gl = renderer.context;
		var state = renderer.state;

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;

		var texture;

		// decompose matrixWorld

		var spritePosition = new THREE.Vector3();
		var spriteRotation = new THREE.Quaternion();
		var spriteScale = new THREE.Vector3();

		var init = function () {

			var vertices = new Float32Array( [
				- 0.5, - 0.5,  0, 0,
				  0.5, - 0.5,  1, 0,
				  0.5,   0.5,  1, 1,
				- 0.5,   0.5,  0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			vertexBuffer  = gl.createBuffer();
			elementBuffer = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			program = createProgram();

			attributes = {
				position:			gl.getAttribLocation ( program, 'position' ),
				uv:					gl.getAttribLocation ( program, 'uv' )
			};

			uniforms = {
				uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
				uvScale:			gl.getUniformLocation( program, 'uvScale' ),

				rotation:			gl.getUniformLocation( program, 'rotation' ),
				scale:				gl.getUniformLocation( program, 'scale' ),

				color:				gl.getUniformLocation( program, 'color' ),
				map:				gl.getUniformLocation( program, 'map' ),
				opacity:			gl.getUniformLocation( program, 'opacity' ),

				modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

				fogType:			gl.getUniformLocation( program, 'fogType' ),
				fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
				fogNear:			gl.getUniformLocation( program, 'fogNear' ),
				fogFar:				gl.getUniformLocation( program, 'fogFar' ),
				fogColor:			gl.getUniformLocation( program, 'fogColor' ),

				alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
			};

			var canvas = document.createElement( 'canvas' );
			canvas.width = 8;
			canvas.height = 8;

			var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 8, 8 );

			texture = new THREE.Texture( canvas );
			texture.needsUpdate = true;

		};

		this.render = function ( scene, camera ) {

			if ( sprites.length === 0 ) return;

			// setup gl

			if ( program === undefined ) {

				init();

			}

			gl.useProgram( program );

			state.initAttributes();
			state.enableAttribute( attributes.position );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();

			state.disable( gl.CULL_FACE );
			state.enable( gl.BLEND );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			state.activeTexture( gl.TEXTURE0 );
			gl.uniform1i( uniforms.map, 0 );

			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;

			if ( fog ) {

				gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

				if ( fog instanceof THREE.Fog ) {

					gl.uniform1f( uniforms.fogNear, fog.near );
					gl.uniform1f( uniforms.fogFar, fog.far );

					gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;

				} else if ( fog instanceof THREE.FogExp2 ) {

					gl.uniform1f( uniforms.fogDensity, fog.density );

					gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;

				}

			} else {

				gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;

			}


			// update positions and sort

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];

				sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

			}

			sprites.sort( painterSortStable );

			// render all sprites

			var scale = [];

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];
				var material = sprite.material;

				gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

				sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

				scale[ 0 ] = spriteScale.x;
				scale[ 1 ] = spriteScale.y;

				var fogType = 0;

				if ( scene.fog && material.fog ) {

					fogType = sceneFogType;

				}

				if ( oldFogType !== fogType ) {

					gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;

				}

				if ( material.map !== null ) {

					gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

				} else {

					gl.uniform2f( uniforms.uvOffset, 0, 0 );
					gl.uniform2f( uniforms.uvScale, 1, 1 );

				}

				gl.uniform1f( uniforms.opacity, material.opacity );
				gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

				gl.uniform1f( uniforms.rotation, material.rotation );
				gl.uniform2fv( uniforms.scale, scale );

				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				state.setDepthTest( material.depthTest );
				state.setDepthWrite( material.depthWrite );

				if ( material.map && material.map.image && material.map.image.width ) {

					renderer.setTexture( material.map, 0 );

				} else {

					renderer.setTexture( texture, 0 );

				}

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

			}

			// restore gl

			state.enable( gl.CULL_FACE );

			renderer.resetGLState();

		};

		function createProgram () {

			var program = gl.createProgram();

			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

			gl.shaderSource( vertexShader, [

				'precision ' + renderer.getPrecision() + ' float;',

				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',

				'attribute vec2 position;',
				'attribute vec2 uv;',

				'varying vec2 vUV;',

				'void main() {',

					'vUV = uvOffset + uv * uvScale;',

					'vec2 alignedPosition = position * scale;',

					'vec2 rotatedPosition;',
					'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
					'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

					'vec4 finalPosition;',

					'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
					'finalPosition.xy += rotatedPosition;',
					'finalPosition = projectionMatrix * finalPosition;',

					'gl_Position = finalPosition;',

				'}'

			].join( '\n' ) );

			gl.shaderSource( fragmentShader, [

				'precision ' + renderer.getPrecision() + ' float;',

				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',

				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',

				'varying vec2 vUV;',

				'void main() {',

					'vec4 texture = texture2D( map, vUV );',

					'if ( texture.a < alphaTest ) discard;',

					'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

					'if ( fogType > 0 ) {',

						'float depth = gl_FragCoord.z / gl_FragCoord.w;',
						'float fogFactor = 0.0;',

						'if ( fogType == 1 ) {',

							'fogFactor = smoothstep( fogNear, fogFar, depth );',

						'} else {',

							'const float LOG2 = 1.442695;',
							'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
							'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

						'}',

						'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

					'}',

				'}'

			].join( '\n' ) );

			gl.compileShader( vertexShader );
			gl.compileShader( fragmentShader );

			gl.attachShader( program, vertexShader );
			gl.attachShader( program, fragmentShader );

			gl.linkProgram( program );

			return program;

		}

		function painterSortStable ( a, b ) {

			if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return b.id - a.id;

			}

		}

	};

	// File:src/extras/GeometryUtils.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.GeometryUtils = {

		merge: function ( geometry1, geometry2, materialIndexOffset ) {

			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

			var matrix;

			if ( geometry2 instanceof THREE.Mesh ) {

				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;

			}

			geometry1.merge( geometry2, matrix, materialIndexOffset );

		},

		center: function ( geometry ) {

			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();

		}

	};

	// File:src/extras/ImageUtils.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Daosheng Mu / https://github.com/DaoshengMu/
	 */

	THREE.ImageUtils = {

		crossOrigin: undefined,

		loadTexture: function ( url, mapping, onLoad, onError ) {

			var loader = new THREE.ImageLoader();
			loader.crossOrigin = this.crossOrigin;

			var texture = new THREE.Texture( undefined, mapping );

			loader.load( url, function ( image ) {

				texture.image = image;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, undefined, function ( event ) {

				if ( onError ) onError( event );

			} );

			texture.sourceFile = url;

			return texture;

		},

		loadTextureCube: function ( array, mapping, onLoad, onError ) {

			var images = [];

			var loader = new THREE.ImageLoader();
			loader.crossOrigin = this.crossOrigin;

			var texture = new THREE.CubeTexture( images, mapping );

			var loaded = 0;

			var loadTexture = function ( i ) {

				loader.load( array[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded += 1;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, undefined, onError );

			};

			for ( var i = 0, il = array.length; i < il; ++ i ) {

				loadTexture( i );

			}

			return texture;

		},

		loadCompressedTexture: function () {

			console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

		},

		loadCompressedTextureCube: function () {

			console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

		},

		getNormalMap: function ( image, depth ) {

			// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

			var cross = function ( a, b ) {

				return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

			};

			var subtract = function ( a, b ) {

				return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

			};

			var normalize = function ( a ) {

				var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
				return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

			};

			depth = depth | 1;

			var width = image.width;
			var height = image.height;

			var canvas = document.createElement( 'canvas' );
			canvas.width = width;
			canvas.height = height;

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0 );

			var data = context.getImageData( 0, 0, width, height ).data;
			var imageData = context.createImageData( width, height );
			var output = imageData.data;

			for ( var x = 0; x < width; x ++ ) {

				for ( var y = 0; y < height; y ++ ) {

					var ly = y - 1 < 0 ? 0 : y - 1;
					var uy = y + 1 > height - 1 ? height - 1 : y + 1;
					var lx = x - 1 < 0 ? 0 : x - 1;
					var ux = x + 1 > width - 1 ? width - 1 : x + 1;

					var points = [];
					var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
					points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
					points.push( [ 1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

					var normals = [];
					var num_points = points.length;

					for ( var i = 0; i < num_points; i ++ ) {

						var v1 = points[ i ];
						var v2 = points[ ( i + 1 ) % num_points ];
						v1 = subtract( v1, origin );
						v2 = subtract( v2, origin );
						normals.push( normalize( cross( v1, v2 ) ) );

					}

					var normal = [ 0, 0, 0 ];

					for ( var i = 0; i < normals.length; i ++ ) {

						normal[ 0 ] += normals[ i ][ 0 ];
						normal[ 1 ] += normals[ i ][ 1 ];
						normal[ 2 ] += normals[ i ][ 2 ];

					}

					normal[ 0 ] /= normals.length;
					normal[ 1 ] /= normals.length;
					normal[ 2 ] /= normals.length;

					var idx = ( y * width + x ) * 4;

					output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
					output[ idx + 3 ] = 255;

				}

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		},

		generateDataTexture: function ( width, height, color ) {

			var size = width * height;
			var data = new Uint8Array( 3 * size );

			var r = Math.floor( color.r * 255 );
			var g = Math.floor( color.g * 255 );
			var b = Math.floor( color.b * 255 );

			for ( var i = 0; i < size; i ++ ) {

				data[ i * 3 ] 	   = r;
				data[ i * 3 + 1 ] = g;
				data[ i * 3 + 2 ] = b;

			}

			var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
			texture.needsUpdate = true;

			return texture;

		}

	};

	// File:src/extras/SceneUtils.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SceneUtils = {

		createMultiMaterialObject: function ( geometry, materials ) {

			var group = new THREE.Group();

			for ( var i = 0, l = materials.length; i < l; i ++ ) {

				group.add( new THREE.Mesh( geometry, materials[ i ] ) );

			}

			return group;

		},

		detach: function ( child, parent, scene ) {

			child.applyMatrix( parent.matrixWorld );
			parent.remove( child );
			scene.add( child );

		},

		attach: function ( child, scene, parent ) {

			var matrixWorldInverse = new THREE.Matrix4();
			matrixWorldInverse.getInverse( parent.matrixWorld );
			child.applyMatrix( matrixWorldInverse );

			scene.remove( child );
			parent.add( child );

		}

	};

	// File:src/extras/FontUtils.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For Text operations in three.js (See TextGeometry)
	 *
	 * It uses techniques used in:
	 *
	 *	Triangulation ported from AS3
	 *		Simple Polygon Triangulation
	 *		http://actionsnippet.com/?p=1462
	 *
	 * 	A Method to triangulate shapes with holes
	 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
	 *
	 */

	THREE.FontUtils = {

		faces: {},

		// Just for now. face[weight][style]

		face: 'helvetiker',
		weight: 'normal',
		style: 'normal',
		size: 150,
		divisions: 10,

		getFace: function () {

			try {

				return this.faces[ this.face.toLowerCase() ][ this.weight ][ this.style ];

			} catch ( e ) {

				throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

			}

		},

		loadFace: function ( data ) {

			var family = data.familyName.toLowerCase();

			var ThreeFont = this;

			ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

			ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
			ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

			ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

			return data;

		},

		drawText: function ( text ) {

			// RenderText

			var i,
				face = this.getFace(),
				scale = this.size / face.resolution,
				offset = 0,
				chars = String( text ).split( '' ),
				length = chars.length;

			var fontPaths = [];

			for ( i = 0; i < length; i ++ ) {

				var path = new THREE.Path();

				var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
				offset += ret.offset;

				fontPaths.push( ret.path );

			}

			// get the width

			var width = offset / 2;
			//
			// for ( p = 0; p < allPts.length; p++ ) {
			//
			// 	allPts[ p ].x -= width;
			//
			// }

			//var extract = this.extractPoints( allPts, characterPts );
			//extract.contour = allPts;

			//extract.paths = fontPaths;
			//extract.offset = width;

			return { paths: fontPaths, offset: width };

		},




		extractGlyphPoints: function ( c, face, scale, offset, path ) {

			var pts = [];

			var i, i2, divisions,
				outline, action, length,
				scaleX, scaleY,
				x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
				laste,
				glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

			if ( ! glyph ) return;

			if ( glyph.o ) {

				outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
				length = outline.length;

				scaleX = scale;
				scaleY = scale;

				for ( i = 0; i < length; ) {

					action = outline[ i ++ ];

					//console.log( action );

					switch ( action ) {

					case 'm':

						// Move To

						x = outline[ i ++ ] * scaleX + offset;
						y = outline[ i ++ ] * scaleY;

						path.moveTo( x, y );
						break;

					case 'l':

						// Line To

						x = outline[ i ++ ] * scaleX + offset;
						y = outline[ i ++ ] * scaleY;
						path.lineTo( x, y );
						break;

					case 'q':

						// QuadraticCurveTo

						cpx  = outline[ i ++ ] * scaleX + offset;
						cpy  = outline[ i ++ ] * scaleY;
						cpx1 = outline[ i ++ ] * scaleX + offset;
						cpy1 = outline[ i ++ ] * scaleY;

						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

						laste = pts[ pts.length - 1 ];

						if ( laste ) {

							cpx0 = laste.x;
							cpy0 = laste.y;

							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

								var t = i2 / divisions;
								THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
								THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

							}

						}

						break;

					case 'b':

						// Cubic Bezier Curve

						cpx  = outline[ i ++ ] *  scaleX + offset;
						cpy  = outline[ i ++ ] *  scaleY;
						cpx1 = outline[ i ++ ] *  scaleX + offset;
						cpy1 = outline[ i ++ ] *  scaleY;
						cpx2 = outline[ i ++ ] *  scaleX + offset;
						cpy2 = outline[ i ++ ] *  scaleY;

						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

						laste = pts[ pts.length - 1 ];

						if ( laste ) {

							cpx0 = laste.x;
							cpy0 = laste.y;

							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

								var t = i2 / divisions;
								THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
								THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

							}

						}

						break;

					}

				}

			}



			return { offset: glyph.ha * scale, path: path };

		}

	};


	THREE.FontUtils.generateShapes = function ( text, parameters ) {

		// Parameters

		parameters = parameters || {};

		var size = parameters.size !== undefined ? parameters.size : 100;
		var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

		var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
		var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
		var style = parameters.style !== undefined ? parameters.style : 'normal';

		THREE.FontUtils.size = size;
		THREE.FontUtils.divisions = curveSegments;

		THREE.FontUtils.face = font;
		THREE.FontUtils.weight = weight;
		THREE.FontUtils.style = style;

		// Get a Font data json object

		var data = THREE.FontUtils.drawText( text );

		var paths = data.paths;
		var shapes = [];

		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	};


	/**
	 * This code is a quick port of code written in C++ which was submitted to
	 * flipcode.com by John W. Ratcliff  // July 22, 2000
	 * See original code and more information here:
	 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
	 *
	 * ported to actionscript by Zevan Rosser
	 * www.actionsnippet.com
	 *
	 * ported to javascript by Joshua Koo
	 * http://www.lab4games.net/zz85/blog
	 *
	 */


	( function ( namespace ) {

		var EPSILON = 0.0000000001;

		// takes in an contour array and returns

		var process = function ( contour, indices ) {

			var n = contour.length;

			if ( n < 3 ) return null;

			var result = [],
				verts = [],
				vertIndices = [];

			/* we want a counter-clockwise polygon in verts */

			var u, v, w;

			if ( area( contour ) > 0.0 ) {

				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

			} else {

				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

			}

			var nv = n;

			/*  remove nv - 2 vertices, creating 1 triangle every time */

			var count = 2 * nv;   /* error detection */

			for ( v = nv - 1; nv > 2; ) {

				/* if we loop, it is probably a non-simple polygon */

				if ( ( count -- ) <= 0 ) {

					//** Triangulate: ERROR - probable bad polygon!

					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					console.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );

					if ( indices ) return vertIndices;
					return result;

				}

				/* three consecutive vertices in current polygon, <u,v,w> */

				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

				if ( snip( contour, u, v, w, nv, verts ) ) {

					var a, b, c, s, t;

					/* true names of the vertices */

					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];

					/* output Triangle */

					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );


					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

					/* remove v from the remaining polygon */

					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

						verts[ s ] = verts[ t ];

					}

					nv --;

					/* reset error detection counter */

					count = 2 * nv;

				}

			}

			if ( indices ) return vertIndices;
			return result;

		};

		// calculate area of the contour polygon

		var area = function ( contour ) {

			var n = contour.length;
			var a = 0.0;

			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		};

		var snip = function ( contour, u, v, w, n, verts ) {

			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;

			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;

			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;

			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;

			if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			for ( p = 0; p < n; p ++ ) {

				px = contour[ verts[ p ] ].x;
				py = contour[ verts[ p ] ].y;

				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;

				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;

			}

			return true;

		};


		namespace.Triangulate = process;
		namespace.Triangulate.area = area;

		return namespace;

	} )( THREE.FontUtils );

	// To use the typeface.js face files, hook up the API

	THREE.typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
	if ( typeof self !== 'undefined' ) self._typeface_js = THREE.typeface_js;

	// File:src/extras/audio/Audio.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Audio = function ( listener ) {

		THREE.Object3D.call( this );

		this.type = 'Audio';

		this.context = listener.context;
		this.source = this.context.createBufferSource();
		this.source.onended = this.onEnded.bind( this );

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );

		this.autoplay = false;

		this.startTime = 0;
		this.playbackRate = 1;
		this.isPlaying = false;

	};

	THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Audio.prototype.constructor = THREE.Audio;

	THREE.Audio.prototype.load = function ( file ) {

		var scope = this;

		var request = new XMLHttpRequest();
		request.open( 'GET', file, true );
		request.responseType = 'arraybuffer';
		request.onload = function ( e ) {

			scope.context.decodeAudioData( this.response, function ( buffer ) {

				scope.source.buffer = buffer;

				if ( scope.autoplay ) scope.play();

			} );

		};
		request.send();

		return this;

	};

	THREE.Audio.prototype.play = function () {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		var source = this.context.createBufferSource();

		source.buffer = this.source.buffer;
		source.loop = this.source.loop;
		source.onended = this.source.onended;
		source.start( 0, this.startTime );
		source.playbackRate.value = this.playbackRate;

		this.isPlaying = true;

		this.source = source;

		this.connect();

	};

	THREE.Audio.prototype.pause = function () {

		this.source.stop();
		this.startTime = this.context.currentTime;

	};

	THREE.Audio.prototype.stop = function () {

		this.source.stop();
		this.startTime = 0;

	};

	THREE.Audio.prototype.connect = function () {

		if ( this.filter !== undefined ) {

			this.source.connect( this.filter );
			this.filter.connect( this.panner );

		} else {

			this.source.connect( this.panner );

		}

	};

	THREE.Audio.prototype.disconnect = function () {

		if ( this.filter !== undefined ) {

			this.source.disconnect( this.filter );
			this.filter.disconnect( this.panner );

		} else {

			this.source.disconnect( this.panner );

		}

	};

	THREE.Audio.prototype.setFilter = function ( value ) {

		if ( this.isPlaying === true ) {

			this.disconnect();
			this.filter = value;
			this.connect();

		} else {

			this.filter = value;

		}

	};

	THREE.Audio.prototype.getFilter = function () {

		return this.filter;

	};

	THREE.Audio.prototype.setPlaybackRate = function ( value ) {

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.value = this.playbackRate;

		}

	};

	THREE.Audio.prototype.getPlaybackRate = function () {

		return this.playbackRate;

	};

	THREE.Audio.prototype.onEnded = function() {

		this.isPlaying = false;

	};

	THREE.Audio.prototype.setLoop = function ( value ) {

		this.source.loop = value;

	};

	THREE.Audio.prototype.getLoop = function () {

		return this.source.loop;

	};

	THREE.Audio.prototype.setRefDistance = function ( value ) {

		this.panner.refDistance = value;

	};

	THREE.Audio.prototype.getRefDistance = function () {

		return this.panner.refDistance;

	};

	THREE.Audio.prototype.setRolloffFactor = function ( value ) {

		this.panner.rolloffFactor = value;

	};

	THREE.Audio.prototype.getRolloffFactor = function () {

		return this.panner.rolloffFactor;

	};

	THREE.Audio.prototype.setVolume = function ( value ) {

		this.gain.gain.value = value;

	};

	THREE.Audio.prototype.getVolume = function () {

		return this.gain.gain.value;

	};

	THREE.Audio.prototype.updateMatrixWorld = ( function () {

		var position = new THREE.Vector3();

		return function updateMatrixWorld( force ) {

			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

			position.setFromMatrixPosition( this.matrixWorld );

			this.panner.setPosition( position.x, position.y, position.z );

		};

	} )();

	// File:src/extras/audio/AudioListener.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AudioListener = function () {

		THREE.Object3D.call( this );

		this.type = 'AudioListener';

		this.context = new ( window.AudioContext || window.webkitAudioContext )();

	};

	THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
	THREE.AudioListener.prototype.constructor = THREE.AudioListener;

	THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3();

		var orientation = new THREE.Vector3();

		return function updateMatrixWorld( force ) {

			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

			var listener = this.context.listener;
			var up = this.up;

			this.matrixWorld.decompose( position, quaternion, scale );

			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

			listener.setPosition( position.x, position.y, position.z );
			listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

		};

	} )();

	// File:src/extras/core/Curve.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTagentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 * THREE.ClosedSplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/

	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/

	THREE.Curve = function () {

	};

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	THREE.Curve.prototype.getPoint = function ( t ) {

		console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
		return null;

	};

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	THREE.Curve.prototype.getPointAt = function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t );

	};

	// Get sequence of points using getPoint( t )

	THREE.Curve.prototype.getPoints = function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPoint( d / divisions ) );

		}

		return pts;

	};

	// Get sequence of points using getPointAt( u )

	THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPointAt( d / divisions ) );

		}

		return pts;

	};

	// Get total curve arc length

	THREE.Curve.prototype.getLength = function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	};

	// Get list of cumulative segment lengths

	THREE.Curve.prototype.getLengths = function ( divisions ) {

		if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length === divisions + 1 )
			&& ! this.needsUpdate ) {

			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

	};


	THREE.Curve.prototype.updateArcLengths = function() {

		this.needsUpdate = true;
		this.getLengths();

	};

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		//var time = Date.now();

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		//console.log('b' , i, low, high, Date.now()- time);

		if ( arcLengths[ i ] === targetArcLength ) {

			var t = i / ( il - 1 );
			return t;

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];

		var segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		var t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	};

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	THREE.Curve.prototype.getTangent = function( t ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var vec = pt2.clone().sub( pt1 );
		return vec.normalize();

	};


	THREE.Curve.prototype.getTangentAt = function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t );

	};





	/**************************************************************
	 *	Utils
	 **************************************************************/

	THREE.Curve.Utils = {

		tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

			return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

		},

		// Puay Bing, thanks for helping with this derivative!

		tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

			return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
				3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
				6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
				3 * t * t * p3;

		},

		tangentSpline: function ( t, p0, p1, p2, p3 ) {

			// To check if my formulas are correct

			var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
			var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
			var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
			var h11 = 3 * t * t - 2 * t;	// t3 − t2

			return h00 + h10 + h01 + h11;

		},

		// Catmull-Rom

		interpolate: function( p0, p1, p2, p3, t ) {

			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	};


	// TODO: Transformation for Curves?

	/**************************************************************
	 *	3D Curves
	 **************************************************************/

	// A Factory method for creating new curve subclasses

	THREE.Curve.create = function ( constructor, getPointFunc ) {

		constructor.prototype = Object.create( THREE.Curve.prototype );
		constructor.prototype.constructor = constructor;
		constructor.prototype.getPoint = getPointFunc;

		return constructor;

	};

	// File:src/extras/core/CurvePath.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	THREE.CurvePath = function () {

		this.curves = [];
		this.bends = [];

		this.autoClose = false; // Automatically closes the path

	};

	THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
	THREE.CurvePath.prototype.constructor = THREE.CurvePath;

	THREE.CurvePath.prototype.add = function ( curve ) {

		this.curves.push( curve );

	};

	THREE.CurvePath.prototype.checkConnection = function() {
		// TODO
		// If the ending of curve is not connected to the starting
		// or the next curve, then, this is not a real path
	};

	THREE.CurvePath.prototype.closePath = function() {

		// TODO Test
		// and verify for vector3 (needs to implement equals)
		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[ 0 ].getPoint( 0 );
		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );

		}

	};

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	THREE.CurvePath.prototype.getPoint = function( t ) {

		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0, diff, curve;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				diff = curveLengths[ i ] - d;
				curve = this.curves[ i ];

				var u = 1 - diff / curve.getLength();

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	};

	/*
	THREE.CurvePath.prototype.getTangent = function( t ) {
	};*/


	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	THREE.CurvePath.prototype.getLength = function() {

		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	};

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	THREE.CurvePath.prototype.getCurveLengths = function() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		var lengths = [], sums = 0;
		var i, il = this.curves.length;

		for ( i = 0; i < il; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	};



	// Returns min and max coordinates

	THREE.CurvePath.prototype.getBoundingBox = function () {

		var points = this.getPoints();

		var maxX, maxY, maxZ;
		var minX, minY, minZ;

		maxX = maxY = Number.NEGATIVE_INFINITY;
		minX = minY = Number.POSITIVE_INFINITY;

		var p, i, il, sum;

		var v3 = points[ 0 ] instanceof THREE.Vector3;

		sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

		for ( i = 0, il = points.length; i < il; i ++ ) {

			p = points[ i ];

			if ( p.x > maxX ) maxX = p.x;
			else if ( p.x < minX ) minX = p.x;

			if ( p.y > maxY ) maxY = p.y;
			else if ( p.y < minY ) minY = p.y;

			if ( v3 ) {

				if ( p.z > maxZ ) maxZ = p.z;
				else if ( p.z < minZ ) minZ = p.z;

			}

			sum.add( p );

		}

		var ret = {

			minX: minX,
			minY: minY,
			maxX: maxX,
			maxY: maxY

		};

		if ( v3 ) {

			ret.maxZ = maxZ;
			ret.minZ = minZ;

		}

		return ret;

	};

	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/

	/// Generate geometry from path points (for Line or Points objects)

	THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

		var pts = this.getPoints( divisions, true );
		return this.createGeometry( pts );

	};

	// Generate geometry from equidistant sampling along the path

	THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

		var pts = this.getSpacedPoints( divisions, true );
		return this.createGeometry( pts );

	};

	THREE.CurvePath.prototype.createGeometry = function( points ) {

		var geometry = new THREE.Geometry();

		for ( var i = 0; i < points.length; i ++ ) {

			geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0 ) );

		}

		return geometry;

	};


	/**************************************************************
	 *	Bend / Wrap Helper Methods
	 **************************************************************/

	// Wrap path / Bend modifiers?

	THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

		this.bends.push( bendpath );

	};

	THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

		var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
		var i, il;

		if ( ! bends ) {

			bends = this.bends;

		}

		for ( i = 0, il = bends.length; i < il; i ++ ) {

			oldPts = this.getWrapPoints( oldPts, bends[ i ] );

		}

		return oldPts;

	};

	THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

		var oldPts = this.getSpacedPoints( segments );

		var i, il;

		if ( ! bends ) {

			bends = this.bends;

		}

		for ( i = 0, il = bends.length; i < il; i ++ ) {

			oldPts = this.getWrapPoints( oldPts, bends[ i ] );

		}

		return oldPts;

	};

	// This returns getPoints() bend/wrapped around the contour of a path.
	// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

	THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

		var bounds = this.getBoundingBox();

		var i, il, p, oldX, oldY, xNorm;

		for ( i = 0, il = oldPts.length; i < il; i ++ ) {

			p = oldPts[ i ];

			oldX = p.x;
			oldY = p.y;

			xNorm = oldX / bounds.maxX;

			// If using actual distance, for length > path, requires line extrusions
			//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

			xNorm = path.getUtoTmapping( xNorm, oldX );

			// check for out of bounds?

			var pathPt = path.getPoint( xNorm );
			var normal = path.getTangent( xNorm );
			normal.set( - normal.y, normal.x ).multiplyScalar( oldY );

			p.x = pathPt.x + normal.x;
			p.y = pathPt.y + normal.y;

		}

		return oldPts;

	};

	// File:src/extras/core/Path.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/

	THREE.Path = function ( points ) {

		THREE.CurvePath.call( this );

		this.actions = [];

		if ( points ) {

			this.fromPoints( points );

		}

	};

	THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
	THREE.Path.prototype.constructor = THREE.Path;

	THREE.PathActions = {

		MOVE_TO: 'moveTo',
		LINE_TO: 'lineTo',
		QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
		BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
		CSPLINE_THRU: 'splineThru',				// Catmull-Rom spline
		ARC: 'arc',								// Circle
		ELLIPSE: 'ellipse'
	};

	// TODO Clean up PATH API

	// Create path using straight lines to connect all points
	// - vectors: array of Vector2

	THREE.Path.prototype.fromPoints = function ( vectors ) {

		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

		for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

			this.lineTo( vectors[ v ].x, vectors[ v ].y );

		}

	};

	// startPath() endPath()?

	THREE.Path.prototype.moveTo = function ( x, y ) {

		var args = Array.prototype.slice.call( arguments );
		this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

	};

	THREE.Path.prototype.lineTo = function ( x, y ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

	};

	THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
													new THREE.Vector2( aCPx, aCPy ),
													new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

	};

	THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
												   aCP2x, aCP2y,
												   aX, aY ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCP1x, aCP1y ),
												new THREE.Vector2( aCP2x, aCP2y ),
												new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

	};

	THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

		var args = Array.prototype.slice.call( arguments );
		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
		//---
		var npts = [ new THREE.Vector2( x0, y0 ) ];
		Array.prototype.push.apply( npts, pts );

		var curve = new THREE.SplineCurve( npts );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

	};

	// FUTURE: Change the API or follow canvas API?

	THREE.Path.prototype.arc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {

		var lastargs = this.actions[ this.actions.length - 1 ].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

	 };

	 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

	 };

	THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var lastargs = this.actions[ this.actions.length - 1 ].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius,
			aStartAngle, aEndAngle, aClockwise, aRotation );

	 };


	THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var args = [
			aX, aY,
			xRadius, yRadius,
			aStartAngle, aEndAngle,
			aClockwise,
			aRotation || 0 // aRotation is optional.
		];
		var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
										aStartAngle, aEndAngle, aClockwise, aRotation );
		this.curves.push( curve );

		var lastPoint = curve.getPoint( 1 );
		args.push( lastPoint.x );
		args.push( lastPoint.y );

		this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

	 };

	THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

		if ( ! divisions ) divisions = 40;

		var points = [];

		for ( var i = 0; i < divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

			//if( !this.getPoint( i / divisions ) ) throw "DIE";

		}

		// if ( closedPath ) {
		//
		// 	points.push( points[ 0 ] );
		//
		// }

		return points;

	};

	/* Return an array of vectors based on contour of the path */

	THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

		if ( this.useSpacedPoints ) {

			return this.getSpacedPoints( divisions, closedPath );

		}

		divisions = divisions || 12;

		var points = [];

		var i, il, item, action, args;
		var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
			laste, j,
			t, tx, ty;

		for ( i = 0, il = this.actions.length; i < il; i ++ ) {

			item = this.actions[ i ];

			action = item.action;
			args = item.args;

			switch ( action ) {

			case THREE.PathActions.MOVE_TO:

				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

				break;

			case THREE.PathActions.LINE_TO:

				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

				break;

			case THREE.PathActions.QUADRATIC_CURVE_TO:

				cpx  = args[ 2 ];
				cpy  = args[ 3 ];

				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];

				if ( points.length > 0 ) {

					laste = points[ points.length - 1 ];

					cpx0 = laste.x;
					cpy0 = laste.y;

				} else {

					laste = this.actions[ i - 1 ].args;

					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];

				}

				for ( j = 1; j <= divisions; j ++ ) {

					t = j / divisions;

					tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
					ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

					points.push( new THREE.Vector2( tx, ty ) );

				}

				break;

			case THREE.PathActions.BEZIER_CURVE_TO:

				cpx  = args[ 4 ];
				cpy  = args[ 5 ];

				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];

				cpx2 = args[ 2 ];
				cpy2 = args[ 3 ];

				if ( points.length > 0 ) {

					laste = points[ points.length - 1 ];

					cpx0 = laste.x;
					cpy0 = laste.y;

				} else {

					laste = this.actions[ i - 1 ].args;

					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];

				}


				for ( j = 1; j <= divisions; j ++ ) {

					t = j / divisions;

					tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
					ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

					points.push( new THREE.Vector2( tx, ty ) );

				}

				break;

			case THREE.PathActions.CSPLINE_THRU:

				laste = this.actions[ i - 1 ].args;

				var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
				var spts = [ last ];

				var n = divisions * args[ 0 ].length;

				spts = spts.concat( args[ 0 ] );

				var spline = new THREE.SplineCurve( spts );

				for ( j = 1; j <= n; j ++ ) {

					points.push( spline.getPointAt( j / n ) );

				}

				break;

			case THREE.PathActions.ARC:

				var aX = args[ 0 ], aY = args[ 1 ],
					aRadius = args[ 2 ],
					aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
					aClockwise = !! args[ 5 ];

				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;

				for ( j = 1; j <= tdivisions; j ++ ) {

					t = j / tdivisions;

					if ( ! aClockwise ) {

						t = 1 - t;

					}

					angle = aStartAngle + t * deltaAngle;

					tx = aX + aRadius * Math.cos( angle );
					ty = aY + aRadius * Math.sin( angle );

					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

					points.push( new THREE.Vector2( tx, ty ) );

				}

				//console.log(points);

				break;

			case THREE.PathActions.ELLIPSE:

				var aX = args[ 0 ], aY = args[ 1 ],
					xRadius = args[ 2 ],
					yRadius = args[ 3 ],
					aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
					aClockwise = !! args[ 6 ],
					aRotation = args[ 7 ];


				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;

				var cos, sin;
				if ( aRotation !== 0 ) {
			
					cos = Math.cos( aRotation );
					sin = Math.sin( aRotation );

				}

				for ( j = 1; j <= tdivisions; j ++ ) {

					t = j / tdivisions;

					if ( ! aClockwise ) {

						t = 1 - t;

					}

					angle = aStartAngle + t * deltaAngle;

					tx = aX + xRadius * Math.cos( angle );
					ty = aY + yRadius * Math.sin( angle );

					if ( aRotation !== 0 ) {

						var x = tx, y = ty;

						// Rotate the point about the center of the ellipse.
						tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
						ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

					}

					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

					points.push( new THREE.Vector2( tx, ty ) );

				}

				//console.log(points);

				break;

			} // end switch

		}



		// Normalize to remove the closing point by default.
		var lastPoint = points[ points.length - 1 ];
		var EPSILON = 0.0000000001;
		if ( Math.abs( lastPoint.x - points[ 0 ].x ) < EPSILON &&
				 Math.abs( lastPoint.y - points[ 0 ].y ) < EPSILON )
			points.splice( points.length - 1, 1 );
		if ( closedPath ) {

			points.push( points[ 0 ] );

		}

		return points;

	};

	//
	// Breaks path into shapes
	//
	//	Assumptions (if parameter isCCW==true the opposite holds):
	//	- solid shapes are defined clockwise (CW)
	//	- holes are defined counterclockwise (CCW)
	//
	//	If parameter noHoles==true:
	//  - all subPaths are regarded as solid shapes
	//  - definition order CW/CCW has no relevance
	//

	THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

		function extractSubpaths( inActions ) {

			var i, il, item, action, args;

			var subPaths = [], lastPath = new THREE.Path();

			for ( i = 0, il = inActions.length; i < il; i ++ ) {

				item = inActions[ i ];

				args = item.args;
				action = item.action;

				if ( action === THREE.PathActions.MOVE_TO ) {

					if ( lastPath.actions.length !== 0 ) {

						subPaths.push( lastPath );
						lastPath = new THREE.Path();

					}

				}

				lastPath[ action ].apply( lastPath, args );

			}

			if ( lastPath.actions.length !== 0 ) {

				subPaths.push( lastPath );

			}

			// console.log(subPaths);

			return	subPaths;

		}

		function toShapesNoHoles( inSubpaths ) {

			var shapes = [];

			for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {

				var tmpPath = inSubpaths[ i ];

				var tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			//console.log("shape", shapes);

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			var EPSILON = 0.0000000001;

			var polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				var edgeLowPt  = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];

				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}


		var subPaths = extractSubpaths( this.actions );
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		var solid, tmpPath, tmpShape, shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		var i, il;

		for ( i = 0, il = subPaths.length; i < il; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = THREE.Shape.Utils.isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.actions = tmpPath.actions;
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			var ambiguous = false;
			var toChange = [];

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}
			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				var sho = newShapeHoles[ sIdx ];
				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					var ho = sho[ hIdx ];
					var hole_unassigned = true;
					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}
					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}
			// console.log("ambiguous: ", ambiguous);
			if ( toChange.length > 0 ) {

				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

			}

		}

		var tmpHoles, j, jl;
		for ( i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];
			for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	};

	// File:src/extras/core/Shape.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	THREE.Shape = function () {

		THREE.Path.apply( this, arguments );
		this.holes = [];

	};

	THREE.Shape.prototype = Object.create( THREE.Path.prototype );
	THREE.Shape.prototype.constructor = THREE.Shape;

	// Convenience method to return ExtrudeGeometry

	THREE.Shape.prototype.extrude = function ( options ) {

		var extruded = new THREE.ExtrudeGeometry( this, options );
		return extruded;

	};

	// Convenience method to return ShapeGeometry

	THREE.Shape.prototype.makeGeometry = function ( options ) {

		var geometry = new THREE.ShapeGeometry( this, options );
		return geometry;

	};

	// Get points of holes

	THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

		var i, il = this.holes.length, holesPts = [];

		for ( i = 0; i < il; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

		}

		return holesPts;

	};

	// Get points of holes (spaced by regular distance)

	THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

		var i, il = this.holes.length, holesPts = [];

		for ( i = 0; i < il; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

		}

		return holesPts;

	};


	// Get points of shape and holes (keypoints based on segments parameter)

	THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

		return {

			shape: this.getTransformedPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	};

	THREE.Shape.prototype.extractPoints = function ( divisions ) {

		if ( this.useSpacedPoints ) {

			return this.extractAllSpacedPoints( divisions );

		}

		return this.extractAllPoints( divisions );

	};

	//
	// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
	//
	// 	return {
	//
	// 		shape: this.transform( bend, divisions ),
	// 		holes: this.getPointsHoles( divisions, bend )
	//
	// 	};
	//
	// };

	// Get points of shape and holes (spaced by regular distance)

	THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

		return {

			shape: this.getTransformedSpacedPoints( divisions ),
			holes: this.getSpacedPointsHoles( divisions )

		};

	};

	/**************************************************************
	 *	Utils
	 **************************************************************/

	THREE.Shape.Utils = {

		triangulateShape: function ( contour, holes ) {

			function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

				// inOtherPt needs to be collinear to the inSegment
				if ( inSegPt1.x !== inSegPt2.x ) {

					if ( inSegPt1.x < inSegPt2.x ) {

						return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

					} else {

						return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

					}

				} else {

					if ( inSegPt1.y < inSegPt2.y ) {

						return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

					} else {

						return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

					}

				}

			}

			function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

				var EPSILON = 0.0000000001;

				var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
				var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

				var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
				var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

				var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
				var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

				if ( Math.abs( limit ) > EPSILON ) {

					// not parallel

					var perpSeg2;
					if ( limit > 0 ) {

						if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

					} else {

						if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

					}

					// i.e. to reduce rounding errors
					// intersection at endpoint of segment#1?
					if ( perpSeg2 === 0 ) {

						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
						return [ inSeg1Pt1 ];

					}
					if ( perpSeg2 === limit ) {

						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
						return [ inSeg1Pt2 ];

					}
					// intersection at endpoint of segment#2?
					if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
					if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

					// return real intersection point
					var factorSeg1 = perpSeg2 / limit;
					return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
								y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

				} else {

					// parallel or collinear
					if ( ( perpSeg1 !== 0 ) ||
						 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

					// they are collinear or degenerate
					var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
					var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
					// both segments are points
					if ( seg1Pt && seg2Pt ) {

						if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
							 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
						return [ inSeg1Pt1 ];                 						// they are the same point

					}
					// segment#1  is a single point
					if ( seg1Pt ) {

						if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
						return [ inSeg1Pt1 ];

					}
					// segment#2  is a single point
					if ( seg2Pt ) {

						if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
						return [ inSeg2Pt1 ];

					}

					// they are collinear segments, which might overlap
					var seg1min, seg1max, seg1minVal, seg1maxVal;
					var seg2min, seg2max, seg2minVal, seg2maxVal;
					if ( seg1dx !== 0 ) {

						// the segments are NOT on a vertical line
						if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

						} else {

							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

						}
						if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

						} else {

							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

						}

					} else {

						// the segments are on a vertical line
						if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

						} else {

							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

						}
						if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

						} else {

							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

						}

					}
					if ( seg1minVal <= seg2minVal ) {

						if ( seg1maxVal <  seg2minVal )	return [];
						if ( seg1maxVal === seg2minVal )	{

							if ( inExcludeAdjacentSegs )		return [];
							return [ seg2min ];

						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
						return	[ seg2min, seg2max ];

					} else {

						if ( seg1minVal >  seg2maxVal )	return [];
						if ( seg1minVal === seg2maxVal )	{

							if ( inExcludeAdjacentSegs )		return [];
							return [ seg1min ];

						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
						return	[ seg1min, seg2max ];

					}

				}

			}

			function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

				// The order of legs is important

				var EPSILON = 0.0000000001;

				// translation of all points, so that Vertex is at (0,0)
				var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
				var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
				var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

				// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
				var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
				var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

				if ( Math.abs( from2toAngle ) > EPSILON ) {

					// angle != 180 deg.

					var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
					// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

					if ( from2toAngle > 0 ) {

						// main angle < 180 deg.
						return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

					} else {

						// main angle > 180 deg.
						return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

					}

				} else {

					// angle == 180 deg.
					// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
					return	( from2otherAngle > 0 );

				}

			}


			function removeHoles( contour, holes ) {

				var shape = contour.concat(); // work on this shape
				var hole;

				function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

					// Check if hole point lies within angle around shape point
					var lastShapeIdx = shape.length - 1;

					var prevShapeIdx = inShapeIdx - 1;
					if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

					var nextShapeIdx = inShapeIdx + 1;
					if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

					var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
					if ( ! insideAngle ) {

						// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
						return	false;

					}

					// Check if shape point lies within angle around hole point
					var lastHoleIdx = hole.length - 1;

					var prevHoleIdx = inHoleIdx - 1;
					if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

					var nextHoleIdx = inHoleIdx + 1;
					if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

					insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
					if ( ! insideAngle ) {

						// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
						return	false;

					}

					return	true;

				}

				function intersectsShapeEdge( inShapePt, inHolePt ) {

					// checks for intersections with shape edges
					var sIdx, nextIdx, intersection;
					for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

						nextIdx = sIdx + 1; nextIdx %= shape.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;

					}

					return	false;

				}

				var indepHoles = [];

				function intersectsHoleEdge( inShapePt, inHolePt ) {

					// checks for intersections with hole edges
					var ihIdx, chkHole,
						hIdx, nextIdx, intersection;
					for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

						chkHole = holes[ indepHoles[ ihIdx ]];
						for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

							nextIdx = hIdx + 1; nextIdx %= chkHole.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
							if ( intersection.length > 0 )		return	true;

						}

					}
					return	false;

				}

				var holeIndex, shapeIndex,
					shapePt, holePt,
					holeIdx, cutKey, failedCuts = [],
					tmpShape1, tmpShape2,
					tmpHole1, tmpHole2;

				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

					indepHoles.push( h );

				}

				var minShapeIndex = 0;
				var counter = indepHoles.length * 2;
				while ( indepHoles.length > 0 ) {

					counter --;
					if ( counter < 0 ) {

						console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
						break;

					}

					// search for shape-vertex and hole-vertex,
					// which can be connected without intersections
					for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

						shapePt = shape[ shapeIndex ];
						holeIndex	= - 1;

						// search for hole which can be reached without intersections
						for ( var h = 0; h < indepHoles.length; h ++ ) {

							holeIdx = indepHoles[ h ];

							// prevent multiple checks
							cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
							if ( failedCuts[ cutKey ] !== undefined )			continue;

							hole = holes[ holeIdx ];
							for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

								holePt = hole[ h2 ];
								if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
								if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
								if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

								holeIndex = h2;
								indepHoles.splice( h, 1 );

								tmpShape1 = shape.slice( 0, shapeIndex + 1 );
								tmpShape2 = shape.slice( shapeIndex );
								tmpHole1 = hole.slice( holeIndex );
								tmpHole2 = hole.slice( 0, holeIndex + 1 );

								shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

								minShapeIndex = shapeIndex;

								// Debug only, to show the selected cuts
								// glob_CutLines.push( [ shapePt, holePt ] );

								break;

							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found

							failedCuts[ cutKey ] = true;			// remember failure

						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

					}

				}

				return shape; 			/* shape with no holes */

			}


			var i, il, f, face,
				key, index,
				allPointsMap = {};

			// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

			var allpoints = contour.concat();

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				Array.prototype.push.apply( allpoints, holes[ h ] );

			}

			//console.log( "allpoints",allpoints, allpoints.length );

			// prepare all points map

			for ( i = 0, il = allpoints.length; i < il; i ++ ) {

				key = allpoints[ i ].x + ":" + allpoints[ i ].y;

				if ( allPointsMap[ key ] !== undefined ) {

					console.warn( "THREE.Shape: Duplicate point", key );

				}

				allPointsMap[ key ] = i;

			}

			// remove holes by cutting paths to holes and adding them to the shape
			var shapeWithoutHoles = removeHoles( contour, holes );

			var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
			//console.log( "triangles",triangles, triangles.length );

			// check all face vertices against all points map

			for ( i = 0, il = triangles.length; i < il; i ++ ) {

				face = triangles[ i ];

				for ( f = 0; f < 3; f ++ ) {

					key = face[ f ].x + ":" + face[ f ].y;

					index = allPointsMap[ key ];

					if ( index !== undefined ) {

						face[ f ] = index;

					}

				}

			}

			return triangles.concat();

		},

		isClockWise: function ( pts ) {

			return THREE.FontUtils.Triangulate.area( pts ) < 0;

		},

		// Bezier Curves formulas obtained from
		// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

		// Quad Bezier Functions

		b2p0: function ( t, p ) {

			var k = 1 - t;
			return k * k * p;

		},

		b2p1: function ( t, p ) {

			return 2 * ( 1 - t ) * t * p;

		},

		b2p2: function ( t, p ) {

			return t * t * p;

		},

		b2: function ( t, p0, p1, p2 ) {

			return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

		},

		// Cubic Bezier Functions

		b3p0: function ( t, p ) {

			var k = 1 - t;
			return k * k * k * p;

		},

		b3p1: function ( t, p ) {

			var k = 1 - t;
			return 3 * k * k * t * p;

		},

		b3p2: function ( t, p ) {

			var k = 1 - t;
			return 3 * k * t * t * p;

		},

		b3p3: function ( t, p ) {

			return t * t * t * p;

		},

		b3: function ( t, p0, p1, p2, p3 ) {

			return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

		}

	};

	// File:src/extras/curves/LineCurve.js

	/**************************************************************
	 *	Line
	 **************************************************************/

	THREE.LineCurve = function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	};

	THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.LineCurve.prototype.constructor = THREE.LineCurve;

	THREE.LineCurve.prototype.getPoint = function ( t ) {

		var point = this.v2.clone().sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	THREE.LineCurve.prototype.getPointAt = function ( u ) {

		return this.getPoint( u );

	};

	THREE.LineCurve.prototype.getTangent = function( t ) {

		var tangent = this.v2.clone().sub( this.v1 );

		return tangent.normalize();

	};

	// File:src/extras/curves/QuadraticBezierCurve.js

	/**************************************************************
	 *	Quadratic Bezier curve
	 **************************************************************/


	THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	};

	THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


	THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

		var vector = new THREE.Vector2();

		vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

		return vector;

	};


	THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

		var vector = new THREE.Vector2();

		vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

		// returns unit vector

		return vector.normalize();

	};

	// File:src/extras/curves/CubicBezierCurve.js

	/**************************************************************
	 *	Cubic Bezier curve
	 **************************************************************/

	THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	};

	THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

	THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

		var tx, ty;

		tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

		return new THREE.Vector2( tx, ty );

	};

	THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

		var tx, ty;

		tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

		var tangent = new THREE.Vector2( tx, ty );
		tangent.normalize();

		return tangent;

	};

	// File:src/extras/curves/SplineCurve.js

	/**************************************************************
	 *	Spline curve
	 **************************************************************/

	THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

		this.points = ( points == undefined ) ? [] : points;

	};

	THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

	THREE.SplineCurve.prototype.getPoint = function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		var vector = new THREE.Vector2();

		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

		return vector;

	};

	// File:src/extras/curves/EllipseCurve.js

	/**************************************************************
	 *	Ellipse curve
	 **************************************************************/

	THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;
		
		this.aRotation = aRotation || 0;

	};

	THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

	THREE.EllipseCurve.prototype.getPoint = function ( t ) {

		var deltaAngle = this.aEndAngle - this.aStartAngle;

		if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
		if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

		var angle;

		if ( this.aClockwise === true ) {

			angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

		} else {

			angle = this.aStartAngle + t * deltaAngle;

		}
		
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );

			var tx = x, ty = y;

			// Rotate the point about the center of the ellipse.
			x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
			y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

		}

		return new THREE.Vector2( x, y );

	};

	// File:src/extras/curves/ArcCurve.js

	/**************************************************************
	 *	Arc curve
	 **************************************************************/

	THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

	};

	THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
	THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

	// File:src/extras/curves/LineCurve3.js

	/**************************************************************
	 *	Line3D
	 **************************************************************/

	THREE.LineCurve3 = THREE.Curve.create(

		function ( v1, v2 ) {

			this.v1 = v1;
			this.v2 = v2;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );

			return vector;

		}

	);

	// File:src/extras/curves/QuadraticBezierCurve3.js

	/**************************************************************
	 *	Quadratic Bezier 3D curve
	 **************************************************************/

	THREE.QuadraticBezierCurve3 = THREE.Curve.create(

		function ( v0, v1, v2 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
			vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
			vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

			return vector;

		}

	);

	// File:src/extras/curves/CubicBezierCurve3.js

	/**************************************************************
	 *	Cubic Bezier 3D curve
	 **************************************************************/

	THREE.CubicBezierCurve3 = THREE.Curve.create(

		function ( v0, v1, v2, v3 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
			vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
			vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

			return vector;

		}

	);

	// File:src/extras/curves/SplineCurve3.js

	/**************************************************************
	 *	Spline 3D curve
	 **************************************************************/


	THREE.SplineCurve3 = THREE.Curve.create(

		function ( points /* array of Vector3 */ ) {

			console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
			this.points = ( points == undefined ) ? [] : points;

		},

		function ( t ) {

			var points = this.points;
			var point = ( points.length - 1 ) * t;

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

			var vector = new THREE.Vector3();

			vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
			vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
			vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

			return vector;

		}

	);

	// File:src/extras/curves/CatmullRomCurve3.js

	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */

	THREE.CatmullRomCurve3 = ( function() {

		var
			tmp = new THREE.Vector3(),
			px = new CubicPoly(),
			py = new CubicPoly(),
			pz = new CubicPoly();

		/*
		Based on an optimized c++ solution in
		 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
		 - http://ideone.com/NoEbVM

		This CubicPoly class could be used for reusing some variables and calculations,
		but for three.js curve use, it could be possible inlined and flatten into a single function call
		which can be placed in CurveUtils.
		*/

		function CubicPoly() {

		}

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

			this.c0 = x0;
			this.c1 = t0;
			this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

		};

		CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			// initCubicPoly
			this.init( x1, x2, t1, t2 );

		};

		// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
		CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

			this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		};

		CubicPoly.prototype.calc = function( t ) {

			var t2 = t * t;
			var t3 = t2 * t;
			return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

		};

		// Subclass Three.js curve
		return THREE.Curve.create(

			function ( p /* array of Vector3 */ ) {

				this.points = p || [];

			},

			function ( t ) {

				var points = this.points,
					point, intPoint, weight, l;

				l = points.length;

				if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

				point = ( l - 1 ) * t;
				intPoint = Math.floor( point );
				weight = point - intPoint;

				if ( weight === 0 && intPoint === l - 1 ) {

					intPoint = l - 2;
					weight = 1;

				}

				var p0, p1, p2, p3;

				if ( intPoint === 0 ) {

					// extrapolate first point
					tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
					p0 = tmp;

				} else {

					p0 = points[ intPoint - 1 ];

				}

				p1 = points[ intPoint ];
				p2 = points[ intPoint + 1 ];

				if ( intPoint + 2 < l ) {

					p3 = points[ intPoint + 2 ]

				} else {

					// extrapolate last point
					tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
					p3 = tmp;

				}

				if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

					// init Centripetal / Chordal Catmull-Rom
					var pow = this.type === 'chordal' ? 0.5 : 0.25;
					var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
					var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
					var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

					// safety check for repeated points
					if ( dt1 < 1e-4 ) dt1 = 1.0;
					if ( dt0 < 1e-4 ) dt0 = dt1;
					if ( dt2 < 1e-4 ) dt2 = dt1;

					px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
					py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
					pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

				} else if ( this.type === 'catmullrom' ) {

					var tension = this.tension !== undefined ? this.tension : 0.5;
					px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
					py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
					pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

				}

				var v = new THREE.Vector3(
					px.calc( weight ),
					py.calc( weight ),
					pz.calc( weight )
				);

				return v;

			}

		);

	} )();

	// File:src/extras/curves/ClosedSplineCurve3.js

	/**************************************************************
	 *	Closed Spline 3D curve
	 **************************************************************/


	THREE.ClosedSplineCurve3 = THREE.Curve.create(

		function ( points /* array of Vector3 */ ) {

			this.points = ( points == undefined ) ? [] : points;

		},

		function ( t ) {

			var points = this.points;
			var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

			var point0 = points[ ( intPoint - 1 ) % points.length ];
			var point1 = points[ ( intPoint     ) % points.length ];
			var point2 = points[ ( intPoint + 1 ) % points.length ];
			var point3 = points[ ( intPoint + 2 ) % points.length ];

			var vector = new THREE.Vector3();

			vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
			vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
			vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

			return vector;

		}

	);

	// File:src/extras/animation/AnimationHandler.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 */

	THREE.AnimationHandler = {

		LINEAR: 0,
		CATMULLROM: 1,
		CATMULLROM_FORWARD: 2,

		//

		add: function () {

			console.warn( 'THREE.AnimationHandler.add() has been deprecated.' );

		},
		get: function () {

			console.warn( 'THREE.AnimationHandler.get() has been deprecated.' );

		},
		remove: function () {

			console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' );

		},

		//

		animations: [],

		init: function ( data ) {

			if ( data.initialized === true ) return data;

			// loop through all keys

			for ( var h = 0; h < data.hierarchy.length; h ++ ) {

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					// remove minus times

					if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

						 data.hierarchy[ h ].keys[ k ].time = 0;

					}

					// create quaternions

					if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
					  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

						var quat = data.hierarchy[ h ].keys[ k ].rot;
						data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

					}

				}

				// prepare morph target keys

				if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

					// get all used

					var usedMorphTargets = {};

					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
							usedMorphTargets[ morphTargetName ] = - 1;

						}

					}

					data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


					// set all used on all frames

					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

						var influences = {};

						for ( var morphTargetName in usedMorphTargets ) {

							for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

								if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

									influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
									break;

								}

							}

							if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

								influences[ morphTargetName ] = 0;

							}

						}

						data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

					}

				}


				// remove all keys that are on the same time

				for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

					if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

						data.hierarchy[ h ].keys.splice( k, 1 );
						k --;

					}

				}


				// set index

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					data.hierarchy[ h ].keys[ k ].index = k;

				}

			}

			data.initialized = true;

			return data;

		},

		parse: function ( root ) {

			var parseRecurseHierarchy = function ( root, hierarchy ) {

				hierarchy.push( root );

				for ( var c = 0; c < root.children.length; c ++ )
					parseRecurseHierarchy( root.children[ c ], hierarchy );

			};

			// setup hierarchy

			var hierarchy = [];

			if ( root instanceof THREE.SkinnedMesh ) {

				for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {

					hierarchy.push( root.skeleton.bones[ b ] );

				}

			} else {

				parseRecurseHierarchy( root, hierarchy );

			}

			return hierarchy;

		},

		play: function ( animation ) {

			if ( this.animations.indexOf( animation ) === - 1 ) {

				this.animations.push( animation );

			}

		},

		stop: function ( animation ) {

			var index = this.animations.indexOf( animation );

			if ( index !== - 1 ) {

				this.animations.splice( index, 1 );

			}

		},

		update: function ( deltaTimeMS ) {

			for ( var i = 0; i < this.animations.length; i ++ ) {

				this.animations[ i ].resetBlendWeights();

			}

			for ( var i = 0; i < this.animations.length; i ++ ) {

				this.animations[ i ].update( deltaTimeMS );

			}

		}

	};

	// File:src/extras/animation/Animation.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Animation = function ( root, data ) {

		this.root = root;
		this.data = THREE.AnimationHandler.init( data );
		this.hierarchy = THREE.AnimationHandler.parse( root );

		this.currentTime = 0;
		this.timeScale = 1;

		this.isPlaying = false;
		this.loop = true;
		this.weight = 0;

		this.interpolationType = THREE.AnimationHandler.LINEAR;

	};

	THREE.Animation.prototype = {

		constructor: THREE.Animation,

		keyTypes:  [ "pos", "rot", "scl" ],

		play: function ( startTime, weight ) {

			this.currentTime = startTime !== undefined ? startTime : 0;
			this.weight = weight !== undefined ? weight : 1;

			this.isPlaying = true;

			this.reset();

			THREE.AnimationHandler.play( this );

		},

		stop: function() {

			this.isPlaying = false;

			THREE.AnimationHandler.stop( this );

		},

		reset: function () {

			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

				var object = this.hierarchy[ h ];

				if ( object.animationCache === undefined ) {

					object.animationCache = {
						animations: {},
						blending: {
							positionWeight: 0.0,
							quaternionWeight: 0.0,
							scaleWeight: 0.0
						}
					};

				}

				var name = this.data.name;
				var animations = object.animationCache.animations;
				var animationCache = animations[ name ];

				if ( animationCache === undefined ) {

					animationCache = {
						prevKey: { pos: 0, rot: 0, scl: 0 },
						nextKey: { pos: 0, rot: 0, scl: 0 },
						originalMatrix: object.matrix
					};

					animations[ name ] = animationCache;

				}

				// Get keys to match our current time

				for ( var t = 0; t < 3; t ++ ) {

					var type = this.keyTypes[ t ];

					var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
					var nextKey = this.getNextKeyWith( type, h, 1 );

					while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

						prevKey = nextKey;
						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

					}

					animationCache.prevKey[ type ] = prevKey;
					animationCache.nextKey[ type ] = nextKey;

				}

			}

		},

		resetBlendWeights: function () {

			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

				var object = this.hierarchy[ h ];
				var animationCache = object.animationCache;

				if ( animationCache !== undefined ) {

					var blending = animationCache.blending;

					blending.positionWeight = 0.0;
					blending.quaternionWeight = 0.0;
					blending.scaleWeight = 0.0;

				}

			}

		},

		update: ( function() {

			var points = [];
			var target = new THREE.Vector3();
			var newVector = new THREE.Vector3();
			var newQuat = new THREE.Quaternion();

			// Catmull-Rom spline

			var interpolateCatmullRom = function ( points, scale ) {

				var c = [], v3 = [],
				point, intPoint, weight, w2, w3,
				pa, pb, pc, pd;

				point = ( points.length - 1 ) * scale;
				intPoint = Math.floor( point );
				weight = point - intPoint;

				c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
				c[ 1 ] = intPoint;
				c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
				c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

				pa = points[ c[ 0 ] ];
				pb = points[ c[ 1 ] ];
				pc = points[ c[ 2 ] ];
				pd = points[ c[ 3 ] ];

				w2 = weight * weight;
				w3 = weight * w2;

				v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
				v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
				v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

				return v3;

			};

			var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

				var v0 = ( p2 - p0 ) * 0.5,
					v1 = ( p3 - p1 ) * 0.5;

				return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

			};

			return function ( delta ) {

				if ( this.isPlaying === false ) return;

				this.currentTime += delta * this.timeScale;

				if ( this.weight === 0 )
					return;

				//

				var duration = this.data.length;

				if ( this.currentTime > duration || this.currentTime < 0 ) {

					if ( this.loop ) {

						this.currentTime %= duration;

						if ( this.currentTime < 0 )
							this.currentTime += duration;

						this.reset();

					} else {

						this.stop();

					}

				}

				for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

					var object = this.hierarchy[ h ];
					var animationCache = object.animationCache.animations[ this.data.name ];
					var blending = object.animationCache.blending;

					// loop through pos/rot/scl

					for ( var t = 0; t < 3; t ++ ) {

						// get keys

						var type    = this.keyTypes[ t ];
						var prevKey = animationCache.prevKey[ type ];
						var nextKey = animationCache.nextKey[ type ];

						if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
							( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

							prevKey = this.data.hierarchy[ h ].keys[ 0 ];
							nextKey = this.getNextKeyWith( type, h, 1 );

							while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

								prevKey = nextKey;
								nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

							}

							animationCache.prevKey[ type ] = prevKey;
							animationCache.nextKey[ type ] = nextKey;

						}

						var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

						var prevXYZ = prevKey[ type ];
						var nextXYZ = nextKey[ type ];

						if ( scale < 0 ) scale = 0;
						if ( scale > 1 ) scale = 1;

						// interpolate

						if ( type === "pos" ) {

							if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

								newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
								newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
								newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

								// blend
								var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
								object.position.lerp( newVector, proportionalWeight );
								blending.positionWeight += this.weight;

							} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
										this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

								points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
								points[ 1 ] = prevXYZ;
								points[ 2 ] = nextXYZ;
								points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

								scale = scale * 0.33 + 0.33;

								var currentPoint = interpolateCatmullRom( points, scale );
								var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
								blending.positionWeight += this.weight;

								// blend

								var vector = object.position;

								vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
								vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
								vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

								if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

									var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

									target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
									target.sub( vector );
									target.y = 0;
									target.normalize();

									var angle = Math.atan2( target.x, target.z );
									object.rotation.set( 0, angle, 0 );

								}

							}

						} else if ( type === "rot" ) {

							THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

							// Avoid paying the cost of an additional slerp if we don't have to
							if ( blending.quaternionWeight === 0 ) {

								object.quaternion.copy( newQuat );
								blending.quaternionWeight = this.weight;

							} else {

								var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
								THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
								blending.quaternionWeight += this.weight;

							}

						} else if ( type === "scl" ) {

							newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
							newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
							newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

							var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
							object.scale.lerp( newVector, proportionalWeight );
							blending.scaleWeight += this.weight;

						}

					}

				}

				return true;

			};

		} )(),

		getNextKeyWith: function ( type, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;

			if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
				 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

				key = key < keys.length - 1 ? key : keys.length - 1;

			} else {

				key = key % keys.length;

			}

			for ( ; key < keys.length; key ++ ) {

				if ( keys[ key ][ type ] !== undefined ) {

					return keys[ key ];

				}

			}

			return this.data.hierarchy[ h ].keys[ 0 ];

		},

		getPrevKeyWith: function ( type, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;

			if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
				this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

				key = key > 0 ? key : 0;

			} else {

				key = key >= 0 ? key : key + keys.length;

			}


			for ( ; key >= 0; key -- ) {

				if ( keys[ key ][ type ] !== undefined ) {

					return keys[ key ];

				}

			}

			return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

		}

	};

	// File:src/extras/animation/KeyFrameAnimation.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author khang duong
	 * @author erik kitson
	 */

	THREE.KeyFrameAnimation = function ( data ) {

		this.root = data.node;
		this.data = THREE.AnimationHandler.init( data );
		this.hierarchy = THREE.AnimationHandler.parse( this.root );
		this.currentTime = 0;
		this.timeScale = 0.001;
		this.isPlaying = false;
		this.isPaused = true;
		this.loop = true;

		// initialize to first keyframes

		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

			var keys = this.data.hierarchy[ h ].keys,
				sids = this.data.hierarchy[ h ].sids,
				obj = this.hierarchy[ h ];

			if ( keys.length && sids ) {

				for ( var s = 0; s < sids.length; s ++ ) {

					var sid = sids[ s ],
						next = this.getNextKeyWith( sid, h, 0 );

					if ( next ) {

						next.apply( sid );

					}

				}

				obj.matrixAutoUpdate = false;
				this.data.hierarchy[ h ].node.updateMatrix();
				obj.matrixWorldNeedsUpdate = true;

			}

		}

	};

	THREE.KeyFrameAnimation.prototype = {

		constructor: THREE.KeyFrameAnimation,

		play: function ( startTime ) {

			this.currentTime = startTime !== undefined ? startTime : 0;

			if ( this.isPlaying === false ) {

				this.isPlaying = true;

				// reset key cache

				var h, hl = this.hierarchy.length,
					object,
					node;

				for ( h = 0; h < hl; h ++ ) {

					object = this.hierarchy[ h ];
					node = this.data.hierarchy[ h ];

					if ( node.animationCache === undefined ) {

						node.animationCache = {};
						node.animationCache.prevKey = null;
						node.animationCache.nextKey = null;
						node.animationCache.originalMatrix = object.matrix;

					}

					var keys = this.data.hierarchy[ h ].keys;

					if ( keys.length ) {

						node.animationCache.prevKey = keys[ 0 ];
						node.animationCache.nextKey = keys[ 1 ];

						this.startTime = Math.min( keys[ 0 ].time, this.startTime );
						this.endTime = Math.max( keys[ keys.length - 1 ].time, this.endTime );

					}

				}

				this.update( 0 );

			}

			this.isPaused = false;

			THREE.AnimationHandler.play( this );

		},

		stop: function () {

			this.isPlaying = false;
			this.isPaused  = false;

			THREE.AnimationHandler.stop( this );

			// reset JIT matrix and remove cache

			for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {

				var obj = this.hierarchy[ h ];
				var node = this.data.hierarchy[ h ];

				if ( node.animationCache !== undefined ) {

					var original = node.animationCache.originalMatrix;

					original.copy( obj.matrix );
					obj.matrix = original;

					delete node.animationCache;

				}

			}

		},

		update: function ( delta ) {

			if ( this.isPlaying === false ) return;

			this.currentTime += delta * this.timeScale;

			//

			var duration = this.data.length;

			if ( this.loop === true && this.currentTime > duration ) {

				this.currentTime %= duration;

			}

			this.currentTime = Math.min( this.currentTime, duration );

			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

				var object = this.hierarchy[ h ];
				var node = this.data.hierarchy[ h ];

				var keys = node.keys,
					animationCache = node.animationCache;


				if ( keys.length ) {

					var prevKey = animationCache.prevKey;
					var nextKey = animationCache.nextKey;

					if ( nextKey.time <= this.currentTime ) {

						while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

							prevKey = nextKey;
							nextKey = keys[ prevKey.index + 1 ];

						}

						animationCache.prevKey = prevKey;
						animationCache.nextKey = nextKey;

					}

					if ( nextKey.time >= this.currentTime ) {

						prevKey.interpolate( nextKey, this.currentTime );

					} else {

						prevKey.interpolate( nextKey, nextKey.time );

					}

					this.data.hierarchy[ h ].node.updateMatrix();
					object.matrixWorldNeedsUpdate = true;

				}

			}

		},

		getNextKeyWith: function ( sid, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;
			key = key % keys.length;

			for ( ; key < keys.length; key ++ ) {

				if ( keys[ key ].hasTarget( sid ) ) {

					return keys[ key ];

				}

			}

			return keys[ 0 ];

		},

		getPrevKeyWith: function ( sid, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;
			key = key >= 0 ? key : key + keys.length;

			for ( ; key >= 0; key -- ) {

				if ( keys[ key ].hasTarget( sid ) ) {

					return keys[ key ];

				}

			}

			return keys[ keys.length - 1 ];

		}

	};

	// File:src/extras/animation/MorphAnimation.js

	/**
	 * @author mrdoob / http://mrdoob.com
	 * @author willy-vvu / http://willy-vvu.github.io
	 */

	THREE.MorphAnimation = function ( mesh ) {

		this.mesh = mesh;
		this.frames = mesh.morphTargetInfluences.length;
		this.currentTime = 0;
		this.duration = 1000;
		this.loop = true;
		this.lastFrame = 0;
		this.currentFrame = 0;

		this.isPlaying = false;

	};

	THREE.MorphAnimation.prototype = {

		constructor: THREE.MorphAnimation,

		play: function () {

			this.isPlaying = true;

		},

		pause: function () {

			this.isPlaying = false;

		},

		update: function ( delta ) {

			if ( this.isPlaying === false ) return;

			this.currentTime += delta;

			if ( this.loop === true && this.currentTime > this.duration ) {

				this.currentTime %= this.duration;

			}

			this.currentTime = Math.min( this.currentTime, this.duration );

			var frameTime = this.duration / this.frames;
			var frame = Math.floor( this.currentTime / frameTime );

			var influences = this.mesh.morphTargetInfluences;

			if ( frame !== this.currentFrame ) {

				influences[ this.lastFrame ] = 0;
				influences[ this.currentFrame ] = 1;
				influences[ frame ] = 0;

				this.lastFrame = this.currentFrame;
				this.currentFrame = frame;

			}

			var mix = ( this.currentTime % frameTime ) / frameTime;

			influences[ frame ] = mix;
			influences[ this.lastFrame ] = 1 - mix;

		}

	};

	// File:src/extras/geometries/BoxGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */

	THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		THREE.Geometry.call( this );

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.widthSegments = widthSegments || 1;
		this.heightSegments = heightSegments || 1;
		this.depthSegments = depthSegments || 1;

		var scope = this;

		var width_half = width / 2;
		var height_half = height / 2;
		var depth_half = depth / 2;

		buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
		buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
		buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
		buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
		buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
		buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

		function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

			var w, ix, iy,
			gridX = scope.widthSegments,
			gridY = scope.heightSegments,
			width_half = width / 2,
			height_half = height / 2,
			offset = scope.vertices.length;

			if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

				w = 'z';

			} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

				w = 'y';
				gridY = scope.depthSegments;

			} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

				w = 'x';
				gridX = scope.depthSegments;

			}

			var gridX1 = gridX + 1,
			gridY1 = gridY + 1,
			segment_width = width / gridX,
			segment_height = height / gridY,
			normal = new THREE.Vector3();

			normal[ w ] = depth > 0 ? 1 : - 1;

			for ( iy = 0; iy < gridY1; iy ++ ) {

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var vector = new THREE.Vector3();
					vector[ u ] = ( ix * segment_width - width_half ) * udir;
					vector[ v ] = ( iy * segment_height - height_half ) * vdir;
					vector[ w ] = depth;

					scope.vertices.push( vector );

				}

			}

			for ( iy = 0; iy < gridY; iy ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;

					var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
					var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
					var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
					var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

					var face = new THREE.Face3( a + offset, b + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;

					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

					face = new THREE.Face3( b + offset, c + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;

					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

				}

			}

		}

		this.mergeVertices();

	};

	THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

	THREE.BoxGeometry.prototype.clone = function () {

		var geometry = new THREE.BoxGeometry(
			this.parameters.width,
			this.parameters.height,
			this.parameters.depth,
			this.parameters.widthSegments,
			this.parameters.heightSegments,
			this.parameters.depthSegments
		);

		return geometry;

	};

	THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

	// File:src/extras/geometries/CircleGeometry.js

	/**
	 * @author hughes
	 */

	THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 50;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		var i, uvs = [],
		center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

		this.vertices.push( center );
		uvs.push( centerUV );

		for ( i = 0; i <= segments; i ++ ) {

			var vertex = new THREE.Vector3();
			var segment = thetaStart + i / segments * thetaLength;

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

		}

		var n = new THREE.Vector3( 0, 0, 1 );

		for ( i = 1; i <= segments; i ++ ) {

			this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

		}

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

	THREE.CircleGeometry.prototype.clone = function () {

		var geometry = new THREE.CircleGeometry(
			this.parameters.radius,
			this.parameters.segments,
			this.parameters.thetaStart,
			this.parameters.thetaLength
		);

		return geometry;

	};

	// File:src/extras/geometries/CircleBufferGeometry.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {

		THREE.BufferGeometry.call( this );

		this.type = 'CircleBufferGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 50;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		var vertices = segments + 2;

		var positions = new Float32Array( vertices * 3 );
		var normals = new Float32Array( vertices * 3 );
		var uvs = new Float32Array( vertices * 2 );

		// center data is already zero, but need to set a few extras
		normals[ 3 ] = 1.0;
		uvs[ 0 ] = 0.5;
		uvs[ 1 ] = 0.5;

		for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

			var segment = thetaStart + s / segments * thetaLength;

			positions[ i ] = radius * Math.cos( segment );
			positions[ i + 1 ] = radius * Math.sin( segment );

			normals[ i + 2 ] = 1; // normal z

			uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
			uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

		}

		var indices = [];

		for ( var i = 1; i <= segments; i ++ ) {

			indices.push( i );
			indices.push( i + 1 );
			indices.push( 0 );

		}

		this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

	THREE.CircleBufferGeometry.prototype.clone = function () {

		var geometry = new THREE.CircleBufferGeometry(
			this.parameters.radius,
			this.parameters.segments,
			this.parameters.thetaStart,
			this.parameters.thetaLength
		);

		geometry.copy( this );

		return geometry;

	};

	// File:src/extras/geometries/CylinderGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radiusTop = radiusTop !== undefined ? radiusTop : 20;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
		height = height !== undefined ? height : 100;

		radialSegments = radialSegments || 8;
		heightSegments = heightSegments || 1;

		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

		var heightHalf = height / 2;

		var x, y, vertices = [], uvs = [];

		for ( y = 0; y <= heightSegments; y ++ ) {

			var verticesRow = [];
			var uvsRow = [];

			var v = y / heightSegments;
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;

				var vertex = new THREE.Vector3();
				vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
				vertex.y = - v * height + heightHalf;
				vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

				this.vertices.push( vertex );

				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );

			}

			vertices.push( verticesRow );
			uvs.push( uvsRow );

		}

		var tanTheta = ( radiusBottom - radiusTop ) / height;
		var na, nb;

		for ( x = 0; x < radialSegments; x ++ ) {

			if ( radiusTop !== 0 ) {

				na = this.vertices[ vertices[ 0 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

			} else {

				na = this.vertices[ vertices[ 1 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

			}

			na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
			nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

			for ( y = 0; y < heightSegments; y ++ ) {

				var v1 = vertices[ y ][ x ];
				var v2 = vertices[ y + 1 ][ x ];
				var v3 = vertices[ y + 1 ][ x + 1 ];
				var v4 = vertices[ y ][ x + 1 ];

				var n1 = na.clone();
				var n2 = na.clone();
				var n3 = nb.clone();
				var n4 = nb.clone();

				var uv1 = uvs[ y ][ x ].clone();
				var uv2 = uvs[ y + 1 ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
				var uv4 = uvs[ y ][ x + 1 ].clone();

				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

			}

		}

		// top cap

		if ( openEnded === false && radiusTop > 0 ) {

			this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

			for ( x = 0; x < radialSegments; x ++ ) {

				var v1 = vertices[ 0 ][ x ];
				var v2 = vertices[ 0 ][ x + 1 ];
				var v3 = this.vertices.length - 1;

				var n1 = new THREE.Vector3( 0, 1, 0 );
				var n2 = new THREE.Vector3( 0, 1, 0 );
				var n3 = new THREE.Vector3( 0, 1, 0 );

				var uv1 = uvs[ 0 ][ x ].clone();
				var uv2 = uvs[ 0 ][ x + 1 ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 0 );

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			}

		}

		// bottom cap

		if ( openEnded === false && radiusBottom > 0 ) {

			this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

			for ( x = 0; x < radialSegments; x ++ ) {

				var v1 = vertices[ heightSegments ][ x + 1 ];
				var v2 = vertices[ heightSegments ][ x ];
				var v3 = this.vertices.length - 1;

				var n1 = new THREE.Vector3( 0, - 1, 0 );
				var n2 = new THREE.Vector3( 0, - 1, 0 );
				var n3 = new THREE.Vector3( 0, - 1, 0 );

				var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
				var uv2 = uvs[ heightSegments ][ x ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 1 );

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			}

		}

		this.computeFaceNormals();

	};

	THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

	THREE.CylinderGeometry.prototype.clone = function () {

		var geometry = new THREE.CylinderGeometry(
			this.parameters.radiusTop,
			this.parameters.radiusBottom,
			this.parameters.height,
			this.parameters.radialSegments,
			this.parameters.heightSegments,
			this.parameters.openEnded,
			this.parameters.thetaStart,
			this.parameters.thetaLength
		);

		return geometry;

	};

	// File:src/extras/geometries/EdgesGeometry.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {

		THREE.BufferGeometry.call( this );

		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

		var edge = [ 0, 0 ], hash = {};
		var sortFunction = function ( a, b ) {

			return a - b;

		};

		var keys = [ 'a', 'b', 'c' ];

		var geometry2;

		if ( geometry instanceof THREE.BufferGeometry ) {

			geometry2 = new THREE.Geometry();
			geometry2.fromBufferGeometry( geometry );

		} else {

			geometry2 = geometry.clone();

		}

		geometry2.mergeVertices();
		geometry2.computeFaceNormals();

		var vertices = geometry2.vertices;
		var faces = geometry2.faces;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

				} else {

					hash[ key ].face2 = i;

				}

			}

		}

		var coords = [];

		for ( var key in hash ) {

			var h = hash[ key ];

			if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

				var vertex = vertices[ h.vert1 ];
				coords.push( vertex.x );
				coords.push( vertex.y );
				coords.push( vertex.z );

				vertex = vertices[ h.vert2 ];
				coords.push( vertex.x );
				coords.push( vertex.y );
				coords.push( vertex.z );

			}

		}

		this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

	};

	THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

	// File:src/extras/geometries/ExtrudeGeometry.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
	 *
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/

	THREE.ExtrudeGeometry = function ( shapes, options ) {

		if ( typeof( shapes ) === "undefined" ) {

			shapes = [];
			return;

		}

		THREE.Geometry.call( this );

		this.type = 'ExtrudeGeometry';

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		this.addShapeList( shapes, options );

		this.computeFaceNormals();

		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides

		//this.computeVertexNormals();

		//console.log( "took", ( Date.now() - startTime ) );

	};

	THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

	THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

		var sl = shapes.length;

		for ( var s = 0; s < sl; s ++ ) {

			var shape = shapes[ s ];
			this.addShape( shape, options );

		}

	};

	THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

		var amount = options.amount !== undefined ? options.amount : 100;

		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var steps = options.steps !== undefined ? options.steps : 1;

		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;

		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {

			extrudePts = extrudePath.getSpacedPoints( steps );

			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion

			// SETUP TNB variables

			// Reuse TNB from TubeGeomtry for now.
			// TODO1 - have a .isClosed in spline?

			splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );

			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

			binormal = new THREE.Vector3();
			normal = new THREE.Vector3();
			position2 = new THREE.Vector3();

		}

		// Safeguards if bevels are not enabled

		if ( ! bevelEnabled ) {

			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;

		}

		// Variables initialization

		var ahole, h, hl; // looping of holes
		var scope = this;

		var shapesOffset = this.vertices.length;

		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe ...

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

					holes[ h ] = ahole.reverse();

				}

			}

			reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

		}


		var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

		/* Vertices */

		var contour = vertices; // vertices has all points but contour has only points of circumference

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			vertices = vertices.concat( ahole );

		}


		function scalePt2 ( pt, vec, size ) {

			if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

			return vec.clone().multiplyScalar( size ).add( pt );

		}

		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;


		// Find directions for point movement


		function getBevelVec( inPt, inPrev, inNext ) {

			var EPSILON = 0.0000000001;

			// computes for inPt the corresponding point inPt' on a new contour
			//   shifted by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.

			var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html

			var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

			// check for collinear edges
			var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

			if ( Math.abs( collinear0 ) > EPSILON ) {

				// not collinear

				// length of vectors for normalizing

				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

				// shift adjacent points by unit vectors to the left

				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

				// scaling factor for v_prev to intersection point

				var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
						  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				// vector from inPt to intersection point

				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
				if ( v_trans_lensq <= 2 ) {

					return	new THREE.Vector2( v_trans_x, v_trans_y );

				} else {

					shrink_by = Math.sqrt( v_trans_lensq / 2 );

				}

			} else {

				// handle special case of collinear edges

				var direction_eq = false;		// assumes: opposite
				if ( v_prev_x > EPSILON ) {

					if ( v_next_x > EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( v_prev_x < - EPSILON ) {

						if ( v_next_x < - EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

							direction_eq = true;

						}

					}

				}

				if ( direction_eq ) {

					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y =  v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );

				} else {

					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );

				}

			}

			return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

		}


		var contourMovements = [];

		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)

			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

		}

		var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			oneHoleMovements = [];

			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

			}

			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );

		}


		// Loop bevelSegments, 1 for the front, 1 for the back

		for ( b = 0; b < bevelSegments; b ++ ) {

			//for ( b = bevelSegments; b > 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );

			//z = bevelThickness * t;
			bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
			//bs = bevelSize * t; // linear

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					v( vert.x, vert.y,  - z );

				}

			}

		}

		bs = bevelSize;

		// Back facing vertices

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, 0 );

			} else {

				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

				normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

		// Add stepped vertices...
		// Including front facing vertices

		var s;

		for ( s = 1; s <= steps; s ++ ) {

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, amount / steps * s );

				} else {

					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

					normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

		}


		// Add bevel segments planes

		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
			//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
			bs = bevelSize * Math.sin ( t * Math.PI / 2 );

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y,  amount + z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y,  amount + z );

					} else {

						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

					}

				}

			}

		}

		/* Faces */

		// Top and bottom faces

		buildLidFaces();

		// Sides faces

		buildSideFaces();


		/////  Internal functions

		function buildLidFaces() {

			if ( bevelEnabled ) {

				var layer = 0; // steps + 1
				var offset = vlen * layer;

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

				}

				layer = steps + bevelSegments * 2;
				offset = vlen * layer;

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

				}

			} else {

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );

				}

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

				}

			}

		}

		// Create faces for the z-sides of the shape

		function buildSideFaces() {

			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );

				//, true
				layeroffset += ahole.length;

			}

		}

		function sidewalls( contour, layeroffset ) {

			var j, k;
			i = contour.length;

			while ( -- i >= 0 ) {

				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;

				//console.log('b', i,j, i-1, k,vertices.length);

				var s = 0, sl = steps  + bevelSegments * 2;

				for ( s = 0; s < sl; s ++ ) {

					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );

					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;

					f4( a, b, c, d, contour, s, sl, j, k );

				}

			}

		}


		function v( x, y, z ) {

			scope.vertices.push( new THREE.Vector3( x, y, z ) );

		}

		function f3( a, b, c ) {

			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;

			scope.faces.push( new THREE.Face3( a, b, c ) );

			var uvs = uvgen.generateTopUV( scope, a, b, c );

			scope.faceVertexUvs[ 0 ].push( uvs );

		}

		function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
			d += shapesOffset;

			scope.faces.push( new THREE.Face3( a, b, d ) );
			scope.faces.push( new THREE.Face3( b, c, d ) );

			var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

			scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

		}

	};

	THREE.ExtrudeGeometry.WorldUVGenerator = {

		generateTopUV: function ( geometry, indexA, indexB, indexC ) {

			var vertices = geometry.vertices;

			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];

			return [
				new THREE.Vector2( a.x, a.y ),
				new THREE.Vector2( b.x, b.y ),
				new THREE.Vector2( c.x, c.y )
			];

		},

		generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

			var vertices = geometry.vertices;

			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
			var d = vertices[ indexD ];

			if ( Math.abs( a.y - b.y ) < 0.01 ) {

				return [
					new THREE.Vector2( a.x, 1 - a.z ),
					new THREE.Vector2( b.x, 1 - b.z ),
					new THREE.Vector2( c.x, 1 - c.z ),
					new THREE.Vector2( d.x, 1 - d.z )
				];

			} else {

				return [
					new THREE.Vector2( a.y, 1 - a.z ),
					new THREE.Vector2( b.y, 1 - b.z ),
					new THREE.Vector2( c.y, 1 - c.z ),
					new THREE.Vector2( d.y, 1 - d.z )
				];

			}

		}
	};

	// File:src/extras/geometries/ShapeGeometry.js

	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *	material: <int> // material index for front and back faces
	 *	uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/

	THREE.ShapeGeometry = function ( shapes, options ) {

		THREE.Geometry.call( this );

		this.type = 'ShapeGeometry';

		if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

		this.addShapeList( shapes, options );

		this.computeFaceNormals();

	};

	THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

	/**
	 * Add an array of shapes to THREE.ShapeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

			this.addShape( shapes[ i ], options );

		}

		return this;

	};

	/**
	 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

		if ( options === undefined ) options = {};
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var material = options.material;
		var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

		//

		var i, l, hole;

		var shapesOffset = this.vertices.length;
		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe...

			for ( i = 0, l = holes.length; i < l; i ++ ) {

				hole = holes[ i ];

				if ( THREE.Shape.Utils.isClockWise( hole ) ) {

					holes[ i ] = hole.reverse();

				}

			}

			reverse = false;

		}

		var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

		// Vertices

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];
			vertices = vertices.concat( hole );

		}

		//

		var vert, vlen = vertices.length;
		var face, flen = faces.length;

		for ( i = 0; i < vlen; i ++ ) {

			vert = vertices[ i ];

			this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

		}

		for ( i = 0; i < flen; i ++ ) {

			face = faces[ i ];

			var a = face[ 0 ] + shapesOffset;
			var b = face[ 1 ] + shapesOffset;
			var c = face[ 2 ] + shapesOffset;

			this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
			this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

		}

	};

	// File:src/extras/geometries/LatheGeometry.js

	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 */

	// points - to create a closed torus, one must use a set of points 
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2*PI) range of the lathed section
	//    2*pi is a closed lathe, less than 2PI is a portion.

	THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

		THREE.Geometry.call( this );

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = segments || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || 2 * Math.PI;

		var inversePointLength = 1.0 / ( points.length - 1 );
		var inverseSegments = 1.0 / segments;

		for ( var i = 0, il = segments; i <= il; i ++ ) {

			var phi = phiStart + i * inverseSegments * phiLength;

			var c = Math.cos( phi ),
				s = Math.sin( phi );

			for ( var j = 0, jl = points.length; j < jl; j ++ ) {

				var pt = points[ j ];

				var vertex = new THREE.Vector3();

				vertex.x = c * pt.x - s * pt.y;
				vertex.y = s * pt.x + c * pt.y;
				vertex.z = pt.z;

				this.vertices.push( vertex );

			}

		}

		var np = points.length;

		for ( var i = 0, il = segments; i < il; i ++ ) {

			for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

				var base = j + np * i;
				var a = base;
				var b = base + np;
				var c = base + 1 + np;
				var d = base + 1;

				var u0 = i * inverseSegments;
				var v0 = j * inversePointLength;
				var u1 = u0 + inverseSegments;
				var v1 = v0 + inversePointLength;

				this.faces.push( new THREE.Face3( a, b, d ) );

				this.faceVertexUvs[ 0 ].push( [

					new THREE.Vector2( u0, v0 ),
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u0, v1 )

				] );

				this.faces.push( new THREE.Face3( b, c, d ) );

				this.faceVertexUvs[ 0 ].push( [

					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u1, v1 ),
					new THREE.Vector2( u0, v1 )

				] );


			}

		}

		this.mergeVertices();
		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

	// File:src/extras/geometries/PlaneGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

		THREE.Geometry.call( this );

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

	};

	THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

	THREE.PlaneGeometry.prototype.clone = function () {

		var geometry = new THREE.PlaneGeometry(
			this.parameters.width,
			this.parameters.height,
			this.parameters.widthSegments,
			this.parameters.heightSegments
		);

		return geometry;

	};

	// File:src/extras/geometries/PlaneBufferGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

		THREE.BufferGeometry.call( this );

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		var width_half = width / 2;
		var height_half = height / 2;

		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var segment_width = width / gridX;
		var segment_height = height / gridY;

		var vertices = new Float32Array( gridX1 * gridY1 * 3 );
		var normals = new Float32Array( gridX1 * gridY1 * 3 );
		var uvs = new Float32Array( gridX1 * gridY1 * 2 );

		var offset = 0;
		var offset2 = 0;

		for ( var iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segment_height - height_half;

			for ( var ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segment_width - width_half;

				vertices[ offset ] = x;
				vertices[ offset + 1 ] = - y;

				normals[ offset + 2 ] = 1;

				uvs[ offset2 ] = ix / gridX;
				uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

				offset += 3;
				offset2 += 2;

			}

		}

		offset = 0;

		var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

		for ( var iy = 0; iy < gridY; iy ++ ) {

			for ( var ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				indices[ offset ] = a;
				indices[ offset + 1 ] = b;
				indices[ offset + 2 ] = d;

				indices[ offset + 3 ] = b;
				indices[ offset + 4 ] = c;
				indices[ offset + 5 ] = d;

				offset += 6;

			}

		}

		this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	};

	THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

	THREE.PlaneBufferGeometry.prototype.clone = function () {

		var geometry = new THREE.PlaneBufferGeometry(
			this.parameters.width,
			this.parameters.height,
			this.parameters.widthSegments,
			this.parameters.heightSegments
		);

		geometry.copy( this );

		return geometry;

	};

	// File:src/extras/geometries/RingGeometry.js

	/**
	 * @author Kaleb Murphy
	 */

	THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		innerRadius = innerRadius || 0;
		outerRadius = outerRadius || 50;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

		var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

		for ( i = 0; i < phiSegments + 1; i ++ ) {

			// concentric circles inside ring

			for ( o = 0; o < thetaSegments + 1; o ++ ) {

				// number of segments per circle

				var vertex = new THREE.Vector3();
				var segment = thetaStart + o / thetaSegments * thetaLength;
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				this.vertices.push( vertex );
				uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );

			}

			radius += radiusStep;

		}

		var n = new THREE.Vector3( 0, 0, 1 );

		for ( i = 0; i < phiSegments; i ++ ) {

			// concentric circles inside ring

			var thetaSegment = i * ( thetaSegments + 1 );

			for ( o = 0; o < thetaSegments ; o ++ ) {

				// number of segments per circle

				var segment = o + thetaSegment;

				var v1 = segment;
				var v2 = segment + thetaSegments + 1;
				var v3 = segment + thetaSegments + 2;

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

				v1 = segment;
				v2 = segment + thetaSegments + 2;
				v3 = segment + 1;

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

			}

		}

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

	THREE.RingGeometry.prototype.clone = function () {

		var geometry = new THREE.RingGeometry(
			this.parameters.innerRadius,
			this.parameters.outerRadius,
			this.parameters.thetaSegments,
			this.parameters.phiSegments,
			this.parameters.thetaStart,
			this.parameters.thetaLength
		);

		return geometry;

	};

	// File:src/extras/geometries/SphereGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

	};

	THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

	THREE.SphereGeometry.prototype.clone = function () {

		var geometry = new THREE.SphereGeometry(
			this.parameters.radius,
			this.parameters.widthSegments,
			this.parameters.heightSegments,
			this.parameters.phiStart,
			this.parameters.phiLength,
			this.parameters.thetaStart,
			this.parameters.thetaLength
		);

		return geometry;

	};

	// File:src/extras/geometries/SphereBufferGeometry.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * based on THREE.SphereGeometry
	 */

	THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		THREE.BufferGeometry.call( this );

		this.type = 'SphereBufferGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 50;

		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		var thetaEnd = thetaStart + thetaLength;

		var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

		var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

		var index = 0, vertices = [], normal = new THREE.Vector3();

		for ( var y = 0; y <= heightSegments; y ++ ) {

			var verticesRow = [];

			var v = y / heightSegments;

			for ( var x = 0; x <= widthSegments; x ++ ) {

				var u = x / widthSegments;

				var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				var py = radius * Math.cos( thetaStart + v * thetaLength );
				var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				normal.set( px, py, pz ).normalize();

				positions.setXYZ( index, px, py, pz );
				normals.setXYZ( index, normal.x, normal.y, normal.z );
				uvs.setXY( index, u, 1 - v );

				verticesRow.push( index );

				index ++;

			}

			vertices.push( verticesRow );

		}

		var indices = [];

		for ( var y = 0; y < heightSegments; y ++ ) {

			for ( var x = 0; x < widthSegments; x ++ ) {

				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = vertices[ y + 1 ][ x ];
				var v4 = vertices[ y + 1 ][ x + 1 ];

				if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
				if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

			}

		}

		this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
		this.addAttribute( 'position', positions );
		this.addAttribute( 'normal', normals );
		this.addAttribute( 'uv', uvs );

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

	THREE.SphereBufferGeometry.prototype.clone = function () {

		var geometry = new THREE.SphereBufferGeometry(
			this.parameters.radius,
			this.parameters.widthSegments,
			this.parameters.heightSegments,
			this.parameters.phiStart,
			this.parameters.phiLength,
			this.parameters.thetaStart,
			this.parameters.thetaLength
		);

		geometry.copy( this );

		return geometry;

	};

	// File:src/extras/geometries/TextGeometry.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For creating 3D text geometry in three.js
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  size: 			<float>, 	// size of the text
	 *  height: 		<float>, 	// thickness to extrude text
	 *  curveSegments: 	<int>,		// number of points on the curves
	 *
	 *  font: 			<string>,		// font name
	 *  weight: 		<string>,		// font weight (normal, bold)
	 *  style: 			<string>,		// font style  (normal, italics)
	 *
	 *  bevelEnabled:	<bool>,			// turn on bevel
	 *  bevelThickness: <float>, 		// how deep into text bevel goes
	 *  bevelSize:		<float>, 		// how far from text outline is bevel
	 *  }
	 *
	 */

	/*	Usage Examples

		// TextGeometry wrapper

		var text3d = new TextGeometry( text, options );

		// Complete manner

		var textShapes = THREE.FontUtils.generateShapes( text, options );
		var text3d = new ExtrudeGeometry( textShapes, options );

	*/


	THREE.TextGeometry = function ( text, parameters ) {

		parameters = parameters || {};

		var textShapes = THREE.FontUtils.generateShapes( text, parameters );

		// translate parameters to ExtrudeGeometry API

		parameters.amount = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		THREE.ExtrudeGeometry.call( this, textShapes, parameters );

		this.type = 'TextGeometry';

	};

	THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
	THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;

	// File:src/extras/geometries/TorusGeometry.js

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */

	THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

		THREE.Geometry.call( this );

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 8;
		tubularSegments = tubularSegments || 6;
		arc = arc || Math.PI * 2;

		var center = new THREE.Vector3(), uvs = [], normals = [];

		for ( var j = 0; j <= radialSegments; j ++ ) {

			for ( var i = 0; i <= tubularSegments; i ++ ) {

				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );

				var vertex = new THREE.Vector3();
				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				this.vertices.push( vertex );

				uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
				normals.push( vertex.clone().sub( center ).normalize() );

			}

		}

		for ( var j = 1; j <= radialSegments; j ++ ) {

			for ( var i = 1; i <= tubularSegments; i ++ ) {

				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;

				var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

				face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

			}

		}

		this.computeFaceNormals();

	};

	THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

	THREE.TorusGeometry.prototype.clone = function () {

		var geometry = new THREE.TorusGeometry(
			this.parameters.radius,
			this.parameters.tube,
			this.parameters.radialSegments,
			this.parameters.tubularSegments,
			this.parameters.arc
		);

		return geometry;

	};

	// File:src/extras/geometries/TorusKnotGeometry.js

	/**
	 * @author oosmoxiecode
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
	 */

	THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

		THREE.Geometry.call( this );

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			p: p,
			q: q,
			heightScale: heightScale
		};

		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 64;
		tubularSegments = tubularSegments || 8;
		p = p || 2;
		q = q || 3;
		heightScale = heightScale || 1;

		var grid = new Array( radialSegments );
		var tang = new THREE.Vector3();
		var n = new THREE.Vector3();
		var bitan = new THREE.Vector3();

		for ( var i = 0; i < radialSegments; ++ i ) {

			grid[ i ] = new Array( tubularSegments );
			var u = i / radialSegments * 2 * p * Math.PI;
			var p1 = getPos( u, q, p, radius, heightScale );
			var p2 = getPos( u + 0.01, q, p, radius, heightScale );
			tang.subVectors( p2, p1 );
			n.addVectors( p2, p1 );

			bitan.crossVectors( tang, n );
			n.crossVectors( bitan, tang );
			bitan.normalize();
			n.normalize();

			for ( var j = 0; j < tubularSegments; ++ j ) {

				var v = j / tubularSegments * 2 * Math.PI;
				var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				var cy = tube * Math.sin( v );

				var pos = new THREE.Vector3();
				pos.x = p1.x + cx * n.x + cy * bitan.x;
				pos.y = p1.y + cx * n.y + cy * bitan.y;
				pos.z = p1.z + cx * n.z + cy * bitan.z;

				grid[ i ][ j ] = this.vertices.push( pos ) - 1;

			}

		}

		for ( var i = 0; i < radialSegments; ++ i ) {

			for ( var j = 0; j < tubularSegments; ++ j ) {

				var ip = ( i + 1 ) % radialSegments;
				var jp = ( j + 1 ) % tubularSegments;

				var a = grid[ i ][ j ];
				var b = grid[ ip ][ j ];
				var c = grid[ ip ][ jp ];
				var d = grid[ i ][ jp ];

				var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
				var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
				var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
				var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

		this.computeFaceNormals();
		this.computeVertexNormals();

		function getPos( u, in_q, in_p, radius, heightScale ) {

			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = in_q / in_p * u;
			var cs = Math.cos( quOverP );

			var tx = radius * ( 2 + cs ) * 0.5 * cu;
			var ty = radius * ( 2 + cs ) * su * 0.5;
			var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

			return new THREE.Vector3( tx, ty, tz );

		}

	};

	THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

	THREE.TorusKnotGeometry.prototype.clone = function () {

		var geometry = new THREE.TorusKnotGeometry(
			this.parameters.radius,
			this.parameters.tube,
			this.parameters.radialSegments,
			this.parameters.tubularSegments,
			this.parameters.p,
			this.parameters.q,
			this.parameters.heightScale
		);

		return geometry;

	};

	// File:src/extras/geometries/TubeGeometry.js

	/**
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 *
	 * Modified from the TorusKnotGeometry by @oosmoxiecode
	 *
	 * Creates a tube which extrudes along a 3d spline
	 *
	 * Uses parallel transport frames as described in
	 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	 */

	THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

		THREE.Geometry.call( this );

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			segments: segments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		segments = segments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;
		taper = taper || THREE.TubeGeometry.NoTaper;

		var grid = [];

		var scope = this,

			tangent,
			normal,
			binormal,

			numpoints = segments + 1,

			u, v, r,

			cx, cy,
			pos, pos2 = new THREE.Vector3(),
			i, j,
			ip, jp,
			a, b, c, d,
			uva, uvb, uvc, uvd;

		var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
			tangents = frames.tangents,
			normals = frames.normals,
			binormals = frames.binormals;

		// proxy internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;

		function vert( x, y, z ) {

			return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

		}

		// construct the grid

		for ( i = 0; i < numpoints; i ++ ) {

			grid[ i ] = [];

			u = i / ( numpoints - 1 );

			pos = path.getPointAt( u );

			tangent = tangents[ i ];
			normal = normals[ i ];
			binormal = binormals[ i ];

			r = radius * taper( u );

			for ( j = 0; j < radialSegments; j ++ ) {

				v = j / radialSegments * 2 * Math.PI;

				cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				cy = r * Math.sin( v );

				pos2.copy( pos );
				pos2.x += cx * normal.x + cy * binormal.x;
				pos2.y += cx * normal.y + cy * binormal.y;
				pos2.z += cx * normal.z + cy * binormal.z;

				grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

			}

		}


		// construct the mesh

		for ( i = 0; i < segments; i ++ ) {

			for ( j = 0; j < radialSegments; j ++ ) {

				ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
				jp = ( j + 1 ) % radialSegments;

				a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
				b = grid[ ip ][ j ];
				c = grid[ ip ][ jp ];
				d = grid[ i ][ jp ];

				uva = new THREE.Vector2( i / segments, j / radialSegments );
				uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
				uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
				uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

	THREE.TubeGeometry.NoTaper = function ( u ) {

		return 1;

	};

	THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

		return Math.sin( Math.PI * u );

	};

	// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
	THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

		var	normal = new THREE.Vector3(),

			tangents = [],
			normals = [],
			binormals = [],

			vec = new THREE.Vector3(),
			mat = new THREE.Matrix4(),

			numpoints = segments + 1,
			theta,
			epsilon = 0.0001,
			smallest,

			tx, ty, tz,
			i, u;


		// expose internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;

		// compute the tangent vectors for each segment on the path

		for ( i = 0; i < numpoints; i ++ ) {

			u = i / ( numpoints - 1 );

			tangents[ i ] = path.getTangentAt( u );
			tangents[ i ].normalize();

		}

		initialNormal3();

		/*
		function initialNormal1(lastBinormal) {
			// fixed start binormal. Has dangers of 0 vectors
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
			normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
		}

		function initialNormal2() {

			// This uses the Frenet-Serret formula for deriving binormal
			var t2 = path.getTangentAt( epsilon );

			normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
			binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

			normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

		}
		*/

		function initialNormal3() {

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the smallest tangent xyz component

			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			smallest = Number.MAX_VALUE;
			tx = Math.abs( tangents[ 0 ].x );
			ty = Math.abs( tangents[ 0 ].y );
			tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= smallest ) {

				smallest = tx;
				normal.set( 1, 0, 0 );

			}

			if ( ty <= smallest ) {

				smallest = ty;
				normal.set( 0, 1, 0 );

			}

			if ( tz <= smallest ) {

				normal.set( 0, 0, 1 );

			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

		}


		// compute the slowly-varying normal and binormal vectors for each segment on the path

		for ( i = 1; i < numpoints; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > epsilon ) {

				vec.normalize();

				theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}


		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed ) {

			theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
			theta /= ( numpoints - 1 );

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( i = 1; i < numpoints; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

	};

	// File:src/extras/geometries/PolyhedronGeometry.js

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

		THREE.Geometry.call( this );

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		radius = radius || 1;
		detail = detail || 0;

		var that = this;

		for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

			prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

		}

		var p = this.vertices;

		var faces = [];

		for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

			var v1 = p[ indices[ i ] ];
			var v2 = p[ indices[ i + 1 ] ];
			var v3 = p[ indices[ i + 2 ] ];

			faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );

		}

		var centroid = new THREE.Vector3();

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			subdivide( faces[ i ], detail );

		}


		// Handle case when face straddles the seam

		for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

			var uvs = this.faceVertexUvs[ 0 ][ i ];

			var x0 = uvs[ 0 ].x;
			var x1 = uvs[ 1 ].x;
			var x2 = uvs[ 2 ].x;

			var max = Math.max( x0, Math.max( x1, x2 ) );
			var min = Math.min( x0, Math.min( x1, x2 ) );

			if ( max > 0.9 && min < 0.1 ) {

				// 0.9 is somewhat arbitrary

				if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
				if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
				if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

			}

		}


		// Apply radius

		for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

			this.vertices[ i ].multiplyScalar( radius );

		}


		// Merge vertices

		this.mergeVertices();

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


		// Project vector onto sphere's surface

		function prepare( vector ) {

			var vertex = vector.normalize().clone();
			vertex.index = that.vertices.push( vertex ) - 1;

			// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

			var u = azimuth( vector ) / 2 / Math.PI + 0.5;
			var v = inclination( vector ) / Math.PI + 0.5;
			vertex.uv = new THREE.Vector2( u, 1 - v );

			return vertex;

		}


		// Approximate a curved face with recursively sub-divided triangles.

		function make( v1, v2, v3, materialIndex ) {

			var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
			that.faces.push( face );

			centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

			var azi = azimuth( centroid );

			that.faceVertexUvs[ 0 ].push( [
				correctUV( v1.uv, v1, azi ),
				correctUV( v2.uv, v2, azi ),
				correctUV( v3.uv, v3, azi )
			] );

		}


		// Analytically subdivide a face to the required detail level.

		function subdivide( face, detail ) {

			var cols = Math.pow( 2, detail );
			var a = prepare( that.vertices[ face.a ] );
			var b = prepare( that.vertices[ face.b ] );
			var c = prepare( that.vertices[ face.c ] );
			var v = [];

			var materialIndex = face.materialIndex;

			// Construct all of the vertices for this subdivision.

			for ( var i = 0 ; i <= cols; i ++ ) {

				v[ i ] = [];

				var aj = prepare( a.clone().lerp( c, i / cols ) );
				var bj = prepare( b.clone().lerp( c, i / cols ) );
				var rows = cols - i;

				for ( var j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

					}

				}

			}

			// Construct all of the faces.

			for ( var i = 0; i < cols ; i ++ ) {

				for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					var k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						make(
							v[ i ][ k + 1 ],
							v[ i + 1 ][ k ],
							v[ i ][ k ],
							materialIndex
						);

					} else {

						make(
							v[ i ][ k + 1 ],
							v[ i + 1 ][ k + 1 ],
							v[ i + 1 ][ k ],
							materialIndex
						);

					}

				}

			}

		}


		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}


		// Texture fixing helper. Spheres have some odd behaviours.

		function correctUV( uv, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
			return uv.clone();

		}


	};

	THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

	THREE.PolyhedronGeometry.prototype.clone = function () {

		var geometry = new THREE.PolyhedronGeometry(
			this.parameters.vertices,
			this.parameters.indices,
			this.parameters.radius,
			this.parameters.detail
		);

		return geometry.copy( this );

	};

	THREE.PolyhedronGeometry.prototype.copy = function ( source ) {

		THREE.Geometry.prototype.copy.call( this, source );
		return this;

	};

	// File:src/extras/geometries/DodecahedronGeometry.js

	/**
	 * @author Abe Pazos / https://hamoid.com
	 */

	THREE.DodecahedronGeometry = function ( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;

		var vertices = [

			// (±1, ±1, ±1)
			- 1, - 1, - 1,    - 1, - 1,  1,
			- 1,  1, - 1,    - 1,  1,  1,
			 1, - 1, - 1,     1, - 1,  1,
			 1,  1, - 1,     1,  1,  1,

			// (0, ±1/φ, ±φ)
			 0, - r, - t,     0, - r,  t,
			 0,  r, - t,     0,  r,  t,

			// (±1/φ, ±φ, 0)
			- r, - t,  0,    - r,  t,  0,
			 r, - t,  0,     r,  t,  0,

			// (±φ, 0, ±1/φ)
			- t,  0, - r,     t,  0, - r,
			- t,  0,  r,     t,  0,  r
		];

		var indices = [
			 3, 11,  7,      3,  7, 15,      3, 15, 13,
			 7, 19, 17,      7, 17,  6,      7,  6, 15,
			17,  4,  8,     17,  8, 10,     17, 10,  6,
			 8,  0, 16,      8, 16,  2,      8,  2, 10,
			 0, 12,  1,      0,  1, 18,      0, 18, 16,
			 6, 10,  2,      6,  2, 13,      6, 13, 15,
			 2, 16, 18,      2, 18,  3,      2,  3, 13,
			18,  1,  9,     18,  9, 11,     18, 11,  3,
			 4, 14, 12,      4, 12,  0,      4,  0,  8,
			11,  9,  5,     11,  5, 19,     11, 19,  7,
			19,  5, 14,     19, 14,  4,     19,  4, 17,
			 1, 12, 14,      1, 14,  5,      1,  5,  9
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

	THREE.DodecahedronGeometry.prototype.clone = function () {

		var geometry = new THREE.DodecahedronGeometry(
			this.parameters.radius,
			this.parameters.detail
		);

		geometry.copy( this );

		return geometry;

	};

	// File:src/extras/geometries/IcosahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.IcosahedronGeometry = function ( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;

		var vertices = [
			- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
			 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
			 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
		];

		var indices = [
			 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
			 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
			 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
			 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

	THREE.IcosahedronGeometry.prototype.clone = function () {

		var geometry = new THREE.IcosahedronGeometry(
			this.parameters.radius,
			this.parameters.detail
		);

		geometry.copy( this );

		return geometry;

	};

	// File:src/extras/geometries/OctahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.OctahedronGeometry = function ( radius, detail ) {

		var vertices = [
			1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
		];

		var indices = [
			0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

	THREE.OctahedronGeometry.prototype.clone = function () {

		var geometry = new THREE.OctahedronGeometry(
			this.parameters.radius,
			this.parameters.detail
		);

		geometry.copy( this );

		return geometry;

	};

	// File:src/extras/geometries/TetrahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.TetrahedronGeometry = function ( radius, detail ) {

		var vertices = [
			 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
		];

		var indices = [
			 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

	THREE.TetrahedronGeometry.prototype.clone = function () {

		var geometry = new THREE.TetrahedronGeometry(
			this.parameters.radius,
			this.parameters.detail
		);

		geometry.copy( this );

		return geometry;

	};

	// File:src/extras/geometries/ParametricGeometry.js

	/**
	 * @author zz85 / https://github.com/zz85
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 *
	 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
	 *
	 */

	THREE.ParametricGeometry = function ( func, slices, stacks ) {

		THREE.Geometry.call( this );

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		var verts = this.vertices;
		var faces = this.faces;
		var uvs = this.faceVertexUvs[ 0 ];

		var i, j, p;
		var u, v;

		var sliceCount = slices + 1;

		for ( i = 0; i <= stacks; i ++ ) {

			v = i / stacks;

			for ( j = 0; j <= slices; j ++ ) {

				u = j / slices;

				p = func( u, v );
				verts.push( p );

			}

		}

		var a, b, c, d;
		var uva, uvb, uvc, uvd;

		for ( i = 0; i < stacks; i ++ ) {

			for ( j = 0; j < slices; j ++ ) {

				a = i * sliceCount + j;
				b = i * sliceCount + j + 1;
				c = ( i + 1 ) * sliceCount + j + 1;
				d = ( i + 1 ) * sliceCount + j;

				uva = new THREE.Vector2( j / slices, i / stacks );
				uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
				uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
				uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

				faces.push( new THREE.Face3( a, b, d ) );
				uvs.push( [ uva, uvb, uvd ] );

				faces.push( new THREE.Face3( b, c, d ) );
				uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

		// console.log(this);

		// magic bullet
		// var diff = this.mergeVertices();
		// console.log('removed ', diff, ' vertices by merging');

		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

	// File:src/extras/geometries/WireframeGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WireframeGeometry = function ( geometry ) {

		THREE.BufferGeometry.call( this );

		var edge = [ 0, 0 ], hash = {};
		var sortFunction = function ( a, b ) {

			return a - b;

		};

		var keys = [ 'a', 'b', 'c' ];

		if ( geometry instanceof THREE.Geometry ) {

			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var numEdges = 0;

			// allocate maximal size
			var edges = new Uint32Array( 6 * faces.length );

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0; j < 3; j ++ ) {

					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );

					var key = edge.toString();

					if ( hash[ key ] === undefined ) {

						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var vertex = vertices[ edges [ 2 * i + j ] ];

					var index = 6 * i + 3 * j;
					coords[ index + 0 ] = vertex.x;
					coords[ index + 1 ] = vertex.y;
					coords[ index + 2 ] = vertex.z;

				}

			}

			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		} else if ( geometry instanceof THREE.BufferGeometry ) {

			if ( geometry.index !== null ) {

				// Indexed BufferGeometry

				var indices = geometry.index.array;
				var vertices = geometry.attributes.position;
				var drawcalls = geometry.drawcalls;
				var numEdges = 0;

				if ( drawcalls.length === 0 ) {

					geometry.addDrawCall( 0, indices.length );

				}

				// allocate maximal size
				var edges = new Uint32Array( 2 * indices.length );

				for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

					var drawcall = drawcalls[ o ];

					var start = drawcall.start;
					var count = drawcall.count;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						for ( var j = 0; j < 3; j ++ ) {

							edge[ 0 ] = indices[ i + j ];
							edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
							edge.sort( sortFunction );

							var key = edge.toString();

							if ( hash[ key ] === undefined ) {

								edges[ 2 * numEdges ] = edge[ 0 ];
								edges[ 2 * numEdges + 1 ] = edge[ 1 ];
								hash[ key ] = true;
								numEdges ++;

							}

						}

					}

				}

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numEdges; i < l; i ++ ) {

					for ( var j = 0; j < 2; j ++ ) {

						var index = 6 * i + 3 * j;
						var index2 = edges[ 2 * i + j ];

						coords[ index + 0 ] = vertices.getX( index2 );
						coords[ index + 1 ] = vertices.getY( index2 );
						coords[ index + 2 ] = vertices.getZ( index2 );

					}

				}

				this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

			} else {

				// non-indexed BufferGeometry

				var vertices = geometry.attributes.position.array;
				var numEdges = vertices.length / 3;
				var numTris = numEdges / 3;

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numTris; i < l; i ++ ) {

					for ( var j = 0; j < 3; j ++ ) {

						var index = 18 * i + 6 * j;

						var index1 = 9 * i + 3 * j;
						coords[ index + 0 ] = vertices[ index1 ];
						coords[ index + 1 ] = vertices[ index1 + 1 ];
						coords[ index + 2 ] = vertices[ index1 + 2 ];

						var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
						coords[ index + 3 ] = vertices[ index2 ];
						coords[ index + 4 ] = vertices[ index2 + 1 ];
						coords[ index + 5 ] = vertices[ index2 + 2 ];

					}

				}

				this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

			}

		}

	};

	THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

	// File:src/extras/helpers/AxisHelper.js

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AxisHelper = function ( size ) {

		size = size || 1;

		var vertices = new Float32Array( [
			0, 0, 0,  size, 0, 0,
			0, 0, 0,  0, size, 0,
			0, 0, 0,  0, 0, size
		] );

		var colors = new Float32Array( [
			1, 0, 0,  1, 0.6, 0,
			0, 1, 0,  0.6, 1, 0,
			0, 0, 1,  0, 0.6, 1
		] );

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

		THREE.LineSegments.call( this, geometry, material );

	};

	THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

	// File:src/extras/helpers/ArrowHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */

	THREE.ArrowHelper = ( function () {

		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

		var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.translate( 0, - 0.5, 0 );

		return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

			// dir is assumed to be normalized

			THREE.Object3D.call( this );

			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;

			this.position.copy( origin );
			
			if ( headLength < length ) {
				this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
				this.line.matrixAutoUpdate = false;
				this.add( this.line );
			}

			this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );

			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );

		}

	}() );

	THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

	THREE.ArrowHelper.prototype.setDirection = ( function () {

		var axis = new THREE.Vector3();
		var radians;

		return function setDirection( dir ) {

			// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

				this.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

				this.quaternion.set( 1, 0, 0, 0 );

			} else {

				axis.set( dir.z, 0, - dir.x ).normalize();

				radians = Math.acos( dir.y );

				this.quaternion.setFromAxisAngle( axis, radians );

			}

		};

	}() );

	THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		if ( headLength < length ){
			this.line.scale.set( 1, length - headLength, 1 );
			this.line.updateMatrix();
		}

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	};

	THREE.ArrowHelper.prototype.setColor = function ( color ) {

		if ( this.line !== undefined ) this.line.material.color.set( color );
		this.cone.material.color.set( color );

	};

	// File:src/extras/helpers/BoxHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BoxHelper = function ( object ) {

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );

		var geometry = new THREE.BufferGeometry();
		geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );

		if ( object !== undefined ) {

			this.update( object );

		}

	};

	THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

	THREE.BoxHelper.prototype.update = ( function () {

		var box = new THREE.Box3();

		return function ( object ) {

			box.setFromObject( object );

			if ( box.empty() ) return;

			var min = box.min;
			var max = box.max;

			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			var position = this.geometry.attributes.position;
			var array = position.array;

			array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
			array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
			array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
			array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

			position.needsUpdate = true;

			this.geometry.computeBoundingSphere();

		}

	} )();

	// File:src/extras/helpers/BoundingBoxHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	// a helper to show the world-axis-aligned bounding box for an object

	THREE.BoundingBoxHelper = function ( object, hex ) {

		var color = ( hex !== undefined ) ? hex : 0x888888;

		this.object = object;

		this.box = new THREE.Box3();

		THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

	};

	THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

	THREE.BoundingBoxHelper.prototype.update = function () {

		this.box.setFromObject( this.object );

		this.box.size( this.scale );

		this.box.center( this.position );

	};

	// File:src/extras/helpers/CameraHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	THREE.CameraHelper = function ( camera ) {

		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

		var pointMap = {};

		// colors

		var hexFrustum = 0xffaa00;
		var hexCone = 0xff0000;
		var hexUp = 0x00aaff;
		var hexTarget = 0xffffff;
		var hexCross = 0x333333;

		// near

		addLine( "n1", "n2", hexFrustum );
		addLine( "n2", "n4", hexFrustum );
		addLine( "n4", "n3", hexFrustum );
		addLine( "n3", "n1", hexFrustum );

		// far

		addLine( "f1", "f2", hexFrustum );
		addLine( "f2", "f4", hexFrustum );
		addLine( "f4", "f3", hexFrustum );
		addLine( "f3", "f1", hexFrustum );

		// sides

		addLine( "n1", "f1", hexFrustum );
		addLine( "n2", "f2", hexFrustum );
		addLine( "n3", "f3", hexFrustum );
		addLine( "n4", "f4", hexFrustum );

		// cone

		addLine( "p", "n1", hexCone );
		addLine( "p", "n2", hexCone );
		addLine( "p", "n3", hexCone );
		addLine( "p", "n4", hexCone );

		// up

		addLine( "u1", "u2", hexUp );
		addLine( "u2", "u3", hexUp );
		addLine( "u3", "u1", hexUp );

		// target

		addLine( "c", "t", hexTarget );
		addLine( "p", "c", hexCross );

		// cross

		addLine( "cn1", "cn2", hexCross );
		addLine( "cn3", "cn4", hexCross );

		addLine( "cf1", "cf2", hexCross );
		addLine( "cf3", "cf4", hexCross );

		function addLine( a, b, hex ) {

			addPoint( a, hex );
			addPoint( b, hex );

		}

		function addPoint( id, hex ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( hex ) );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( geometry.vertices.length - 1 );

		}

		THREE.LineSegments.call( this, geometry, material );

		this.camera = camera;
		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	};

	THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

	THREE.CameraHelper.prototype.update = function () {

		var geometry, pointMap;

		var vector = new THREE.Vector3();
		var camera = new THREE.Camera();

		var setPoint = function ( point, x, y, z ) {

			vector.set( x, y, z ).unproject( camera );

			var points = pointMap[ point ];

			if ( points !== undefined ) {

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					geometry.vertices[ points[ i ] ].copy( vector );

				}

			}

		};

		return function () {

			geometry = this.geometry;
			pointMap = this.pointMap;

			var w = 1, h = 1;

			// we need just camera projection matrix
			// world matrix must be identity

			camera.projectionMatrix.copy( this.camera.projectionMatrix );

			// center / target

			setPoint( "c", 0, 0, - 1 );
			setPoint( "t", 0, 0,  1 );

			// near

			setPoint( "n1", - w, - h, - 1 );
			setPoint( "n2",   w, - h, - 1 );
			setPoint( "n3", - w,   h, - 1 );
			setPoint( "n4",   w,   h, - 1 );

			// far

			setPoint( "f1", - w, - h, 1 );
			setPoint( "f2",   w, - h, 1 );
			setPoint( "f3", - w,   h, 1 );
			setPoint( "f4",   w,   h, 1 );

			// up

			setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
			setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
			setPoint( "u3",         0, h * 2,   - 1 );

			// cross

			setPoint( "cf1", - w,   0, 1 );
			setPoint( "cf2",   w,   0, 1 );
			setPoint( "cf3",   0, - h, 1 );
			setPoint( "cf4",   0,   h, 1 );

			setPoint( "cn1", - w,   0, - 1 );
			setPoint( "cn2",   w,   0, - 1 );
			setPoint( "cn3",   0, - h, - 1 );
			setPoint( "cn4",   0,   h, - 1 );

			geometry.verticesNeedUpdate = true;

		};

	}();

	// File:src/extras/helpers/DirectionalLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.DirectionalLightHelper = function ( light, size ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		size = size || 1;

		var geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3( - size,   size, 0 ),
			new THREE.Vector3(   size,   size, 0 ),
			new THREE.Vector3(   size, - size, 0 ),
			new THREE.Vector3( - size, - size, 0 ),
			new THREE.Vector3( - size,   size, 0 )
		);

		var material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.lightPlane = new THREE.Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3(),
			new THREE.Vector3()
		);

		material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine = new THREE.Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	};

	THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

	THREE.DirectionalLightHelper.prototype.dispose = function () {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	};

	THREE.DirectionalLightHelper.prototype.update = function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var v3 = new THREE.Vector3();

		return function () {

			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );

			this.lightPlane.lookAt( v3 );
			this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			this.targetLine.geometry.vertices[ 1 ].copy( v3 );
			this.targetLine.geometry.verticesNeedUpdate = true;
			this.targetLine.material.color.copy( this.lightPlane.material.color );

		};

	}();

	// File:src/extras/helpers/EdgesHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @param object THREE.Mesh whose geometry will be used
	 * @param hex line color
	 * @param thresholdAngle the minimum angle (in degrees),
	 * between the face normals of adjacent faces,
	 * that is required to render an edge. A value of 10 means
	 * an edge is only rendered if the angle is at least 10 degrees.
	 */

	THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

		var color = ( hex !== undefined ) ? hex : 0xffffff;

		THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

	// File:src/extras/helpers/FaceNormalsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

		// FaceNormalsHelper only supports THREE.Geometry

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry instanceof THREE.Geometry ) {

			nNormals = objGeometry.faces.length;

		} else {

			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

		}

		//

		var geometry = new THREE.BufferGeometry();

		var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;
		this.update();

	};

	THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

	THREE.FaceNormalsHelper.prototype.update = ( function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();

		return function update() {

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var normal = face.normal;

				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );

				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

			position.needsUpdate = true;

			return this;

		}

	}() );

	// File:src/extras/helpers/GridHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.GridHelper = function ( size, step ) {

		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

		this.color1 = new THREE.Color( 0x444444 );
		this.color2 = new THREE.Color( 0x888888 );

		for ( var i = - size; i <= size; i += step ) {

			geometry.vertices.push(
				new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
				new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
			);

			var color = i === 0 ? this.color1 : this.color2;

			geometry.colors.push( color, color, color, color );

		}

		THREE.LineSegments.call( this, geometry, material );

	};

	THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.GridHelper.prototype.constructor = THREE.GridHelper;

	THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

		this.color1.set( colorCenterLine );
		this.color2.set( colorGrid );

		this.geometry.colorsNeedUpdate = true;

	};

	// File:src/extras/helpers/HemisphereLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.HemisphereLightHelper = function ( light, sphereSize ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.colors = [ new THREE.Color(), new THREE.Color() ];

		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		geometry.rotateX( - Math.PI / 2 );

		for ( var i = 0, il = 8; i < il; i ++ ) {

			geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

		}

		var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

		this.lightSphere = new THREE.Mesh( geometry, material );
		this.add( this.lightSphere );

		this.update();

	};

	THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

	THREE.HemisphereLightHelper.prototype.dispose = function () {

		this.lightSphere.geometry.dispose();
		this.lightSphere.material.dispose();

	};

	THREE.HemisphereLightHelper.prototype.update = function () {

		var vector = new THREE.Vector3();

		return function () {

			this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
			this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

			this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
			this.lightSphere.geometry.colorsNeedUpdate = true;

		}

	}();

	// File:src/extras/helpers/PointLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.PointLightHelper = function ( light, sphereSize ) {

		this.light = light;
		this.light.updateMatrixWorld();

		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		THREE.Mesh.call( this, geometry, material );

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

	};

	THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

	THREE.PointLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();

	};

	THREE.PointLightHelper.prototype.update = function () {

		this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	};

	// File:src/extras/helpers/SkeletonHelper.js

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.SkeletonHelper = function ( object ) {

		this.bones = this.getBoneList( object );

		var geometry = new THREE.Geometry();

		for ( var i = 0; i < this.bones.length; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.parent instanceof THREE.Bone ) {

				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );
				geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
				geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

			}

		}

		geometry.dynamic = true;

		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

		THREE.LineSegments.call( this, geometry, material );

		this.root = object;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();

	};


	THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

	THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

		var boneList = [];

		if ( object instanceof THREE.Bone ) {

			boneList.push( object );

		}

		for ( var i = 0; i < object.children.length; i ++ ) {

			boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

		}

		return boneList;

	};

	THREE.SkeletonHelper.prototype.update = function () {

		var geometry = this.geometry;

		var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

		var boneMatrix = new THREE.Matrix4();

		var j = 0;

		for ( var i = 0; i < this.bones.length; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.parent instanceof THREE.Bone ) {

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

				j += 2;

			}

		}

		geometry.verticesNeedUpdate = true;

		geometry.computeBoundingSphere();

	};

	// File:src/extras/helpers/SpotLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.SpotLightHelper = function ( light ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

		geometry.translate( 0, - 0.5, 0 );
		geometry.rotateX( - Math.PI / 2 );

		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

		this.cone = new THREE.Mesh( geometry, material );
		this.add( this.cone );

		this.update();

	};

	THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

	THREE.SpotLightHelper.prototype.dispose = function () {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	};

	THREE.SpotLightHelper.prototype.update = function () {

		var vector = new THREE.Vector3();
		var vector2 = new THREE.Vector3();

		return function () {

			var coneLength = this.light.distance ? this.light.distance : 10000;
			var coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( vector2.sub( vector ) );

			this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		};

	}();

	// File:src/extras/helpers/VertexNormalsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xff0000;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry instanceof THREE.Geometry ) {

			nNormals = objGeometry.faces.length * 3;

		} else if ( objGeometry instanceof THREE.BufferGeometry ) {

			nNormals = objGeometry.attributes.normal.count

		}

		//

		var geometry = new THREE.BufferGeometry();

		var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;

		this.update();

	};

	THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

	THREE.VertexNormalsHelper.prototype.update = ( function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();

		return function update() {

			var keys = [ 'a', 'b', 'c' ];

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			if ( objGeometry instanceof THREE.Geometry ) {

				var vertices = objGeometry.vertices;

				var faces = objGeometry.faces;

				var idx = 0;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

						var vertex = vertices[ face[ keys[ j ] ] ];

						var normal = face.vertexNormals[ j ];

						v1.copy( vertex ).applyMatrix4( matrixWorld );

						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

						position.setXYZ( idx, v1.x, v1.y, v1.z );

						idx = idx + 1;

						position.setXYZ( idx, v2.x, v2.y, v2.z );

						idx = idx + 1;

					}

				}

			} else if ( objGeometry instanceof THREE.BufferGeometry ) {

				var objPos = objGeometry.attributes.position;

				var objNorm = objGeometry.attributes.normal;

				var idx = 0;

				// for simplicity, ignore index and drawcalls, and render every normal

				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

			position.needsUpdate = true;

			return this;

		}

	}() );

	// File:src/extras/helpers/WireframeHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WireframeHelper = function ( object, hex ) {

		var color = ( hex !== undefined ) ? hex : 0xffffff;

		THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

	// File:src/extras/objects/ImmediateRenderObject.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.ImmediateRenderObject = function () {

		THREE.Object3D.call( this );

		this.render = function ( renderCallback ) {};

	};

	THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

	// File:src/extras/objects/MorphBlendMesh.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.MorphBlendMesh = function( geometry, material ) {

		THREE.Mesh.call( this, geometry, material );

		this.animationsMap = {};
		this.animationsList = [];

		// prepare default animation
		// (all frames played together in 1 second)

		var numFrames = this.geometry.morphTargets.length;

		var name = "__default";

		var startFrame = 0;
		var endFrame = numFrames - 1;

		var fps = numFrames / 1;

		this.createAnimation( name, startFrame, endFrame, fps );
		this.setAnimationWeight( name, 1 );

	};

	THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

	THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

		var animation = {

			start: start,
			end: end,

			length: end - start + 1,

			fps: fps,
			duration: ( end - start ) / fps,

			lastFrame: 0,
			currentFrame: 0,

			active: false,

			time: 0,
			direction: 1,
			weight: 1,

			directionBackwards: false,
			mirroredLoop: false

		};

		this.animationsMap[ name ] = animation;
		this.animationsList.push( animation );

	};

	THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

		var pattern = /([a-z]+)_?(\d+)/;

		var firstAnimation, frameRanges = {};

		var geometry = this.geometry;

		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

			var morph = geometry.morphTargets[ i ];
			var chunks = morph.name.match( pattern );

			if ( chunks && chunks.length > 1 ) {

				var name = chunks[ 1 ];

				if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

				var range = frameRanges[ name ];

				if ( i < range.start ) range.start = i;
				if ( i > range.end ) range.end = i;

				if ( ! firstAnimation ) firstAnimation = name;

			}

		}

		for ( var name in frameRanges ) {

			var range = frameRanges[ name ];
			this.createAnimation( name, range.start, range.end, fps );

		}

		this.firstAnimation = firstAnimation;

	};

	THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.direction = 1;
			animation.directionBackwards = false;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.direction = - 1;
			animation.directionBackwards = true;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.fps = fps;
			animation.duration = ( animation.end - animation.start ) / animation.fps;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.duration = duration;
			animation.fps = ( animation.end - animation.start ) / animation.duration;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.weight = weight;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.time = time;

		}

	};

	THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

		var time = 0;

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			time = animation.time;

		}

		return time;

	};

	THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

		var duration = - 1;

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			duration = animation.duration;

		}

		return duration;

	};

	THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.time = 0;
			animation.active = true;

		} else {

			console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

		}

	};

	THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.active = false;

		}

	};

	THREE.MorphBlendMesh.prototype.update = function ( delta ) {

		for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

			var animation = this.animationsList[ i ];

			if ( ! animation.active ) continue;

			var frameTime = animation.duration / animation.length;

			animation.time += animation.direction * delta;

			if ( animation.mirroredLoop ) {

				if ( animation.time > animation.duration || animation.time < 0 ) {

					animation.direction *= - 1;

					if ( animation.time > animation.duration ) {

						animation.time = animation.duration;
						animation.directionBackwards = true;

					}

					if ( animation.time < 0 ) {

						animation.time = 0;
						animation.directionBackwards = false;

					}

				}

			} else {

				animation.time = animation.time % animation.duration;

				if ( animation.time < 0 ) animation.time += animation.duration;

			}

			var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
			var weight = animation.weight;

			if ( keyframe !== animation.currentFrame ) {

				this.morphTargetInfluences[ animation.lastFrame ] = 0;
				this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

				this.morphTargetInfluences[ keyframe ] = 0;

				animation.lastFrame = animation.currentFrame;
				animation.currentFrame = keyframe;

			}

			var mix = ( animation.time % frameTime ) / frameTime;

			if ( animation.directionBackwards ) mix = 1 - mix;

			if ( animation.currentFrame !== animation.lastFrame ) {

				this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
				this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

			} else {

				this.morphTargetInfluences[ animation.currentFrame ] = weight;

			}

		}

	};



/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = {
		"a3": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a3/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a3/body-area.json",
				"previews": [
					"a3/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"a3/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a3/fbumper.json",
					"a3/fbumper-rs.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a3/fbumper-area.json",
				"previews": [
					"a3/fbumper-preview.png",
					"a3/fbumper-rs-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"a3/glass.json"
				],
				"material": "glass",
				"area": "a3/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a3/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a3/hood-area.json",
				"previews": [
					"a3/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"a3/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"a3/lens.json"
				],
				"material": "glass",
				"area": "a3/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a3/rbumper.json",
					"a3/rbumper-rs.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a3/rbumper-area.json",
				"previews": [
					"a3/rbumper-preview.png",
					"a3/rbumper-rs-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a3/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a3/reflector-area.json",
				"previews": [
					"a3/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a3/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a3/roof-area.json",
				"previews": [
					"a3/roof-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a3/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a3/trunk-area.json",
				"previews": [
					"a3/trunk-preview.png"
				]
			}
		},
		"a4": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a4/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a4/body-area.json",
				"previews": [
					"a4/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"a4/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a4/fbumper.json",
					"a4/fbumper-rieger.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a4/fbumper-area.json",
				"previews": [
					"a4/fbumper-preview.png",
					"a4/fbumper-rieger-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"a4/glass.json"
				],
				"material": "glass",
				"area": "a4/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a4/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a4/hood-area.json",
				"previews": [
					"a4/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"a4/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"a4/lens.json"
				],
				"material": "glass",
				"area": "a4/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a4/rbumper.json",
					"a4/rbumper-rieger.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a4/rbumper-area.json",
				"previews": [
					"a4/rbumper-preview.png",
					"a4/rbumper-rieger-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a4/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a4/reflector-area.json",
				"previews": [
					"a4/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a4/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a4/roof-area.json",
				"previews": [
					"a4/roof-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a4/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a4/trunk-area.json",
				"previews": [
					"a4/trunk-preview.png"
				]
			}
		},
		"a5": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a5/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a5/body-area.json",
				"previews": [
					"a5/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"a5/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a5/fbumper.json",
					"a5/fbumper-rs.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a5/fbumper-area.json",
				"previews": [
					"a5/fbumper-preview.png",
					"a5/fbumper-rs-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"a5/glass.json"
				],
				"material": "glass",
				"area": "a5/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a5/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a5/hood-area.json",
				"previews": [
					"a5/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"a5/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"a5/lens.json"
				],
				"material": "glass",
				"area": "a5/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a5/rbumper.json",
					"a5/rbumper-rs.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a5/rbumper-area.json",
				"previews": [
					"a5/rbumper-preview.png",
					"a5/rbumper-rs-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a5/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a5/reflector-area.json",
				"previews": [
					"a5/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a5/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a5/roof-area.json",
				"previews": [
					"a5/roof-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"a5/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "a5/trunk-area.json",
				"previews": [
					"a5/trunk-preview.png"
				]
			}
		},
		"atenza": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"atenza/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "atenza/body-area.json",
				"previews": [
					"atenza/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"atenza/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"atenza/fbumper.json",
					"atenza/fbumper-sema.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "atenza/fbumper-area.json",
				"previews": [
					"atenza/fbumper-preview.png",
					"atenza/fbumper-sema-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"atenza/glass.json"
				],
				"material": "glass",
				"area": "atenza/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"atenza/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "atenza/hood-area.json",
				"previews": [
					"atenza/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"atenza/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"atenza/lens.json"
				],
				"material": "glass",
				"area": "atenza/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"atenza/rbumper.json",
					"atenza/rbumper-sema.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "atenza/rbumper-area.json",
				"previews": [
					"atenza/rbumper-preview.png",
					"atenza/rbumper-sema-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"atenza/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "atenza/reflector-area.json",
				"previews": [
					"atenza/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"atenza/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "atenza/roof-area.json",
				"previews": [
					"atenza/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"atenza/sideskirt.json",
					"atenza/sideskirt-sema.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "atenza/sideskirt-area.json",
				"previews": [
					"atenza/sideskirt-preview.png",
					"atenza/sideskirt-sema-preview.png"
				]
			},
			"spoiler": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"atenza/spoiler.json",
					"atenza/spoiler-sema.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "atenza/spoiler-area.json",
				"previews": [
					"atenza/spoiler-preview.png",
					"atenza/spoiler-sema-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"atenza/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "atenza/trunk-area.json",
				"previews": [
					"atenza/trunk-preview.png"
				]
			}
		},
		"ats": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ats/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ats/body-area.json",
				"previews": [
					"ats/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"ats/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ats/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ats/fbumper-area.json",
				"previews": [
					"ats/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"ats/glass.json"
				],
				"material": "glass",
				"area": "ats/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ats/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ats/hood-area.json",
				"previews": [
					"ats/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"ats/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"ats/lens.json"
				],
				"material": "glass",
				"area": "ats/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ats/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ats/rbumper-area.json",
				"previews": [
					"ats/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ats/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ats/reflector-area.json",
				"previews": [
					"ats/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ats/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ats/roof-area.json",
				"previews": [
					"ats/roof-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ats/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ats/trunk-area.json",
				"previews": [
					"ats/trunk-preview.png"
				]
			}
		},
		"beetle": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"beetle/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "beetle/body-area.json",
				"previews": [
					"beetle/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"beetle/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"beetle/fbumper.json",
					"beetle/fbumper-r.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "beetle/fbumper-area.json",
				"previews": [
					"beetle/fbumper-preview.png",
					"beetle/fbumper-r-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"beetle/glass.json"
				],
				"material": "glass",
				"area": "beetle/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"beetle/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "beetle/hood-area.json",
				"previews": [
					"beetle/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"beetle/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"beetle/lens.json"
				],
				"material": "glass",
				"area": "beetle/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"beetle/rbumper.json",
					"beetle/rbumper-r.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "beetle/rbumper-area.json",
				"previews": [
					"beetle/rbumper-preview.png",
					"beetle/rbumper-r-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"beetle/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "beetle/reflector-area.json",
				"previews": [
					"beetle/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"beetle/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "beetle/roof-area.json",
				"previews": [
					"beetle/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"beetle/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "beetle/sideskirt-area.json",
				"previews": [
					"beetle/sideskirt-preview.png"
				]
			},
			"spoiler": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"beetle/spoiler.json",
					"beetle/spoiler-r.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "beetle/spoiler-area.json",
				"previews": [
					"beetle/spoiler-preview.png",
					"beetle/spoiler-r-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"beetle/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "beetle/trunk-area.json",
				"previews": [
					"beetle/trunk-preview.png"
				]
			}
		},
		"bmw3": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw3/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw3/body-area.json",
				"previews": [
					"bmw3/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"bmw3/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw3/fbumper.json",
					"bmw3/fbumper-m.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw3/fbumper-area.json",
				"previews": [
					"bmw3/fbumper-preview.png",
					"bmw3/fbumper-m-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"bmw3/glass.json"
				],
				"material": "glass",
				"area": "bmw3/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw3/hood.json",
					"bmw3/hood-m.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw3/hood-area.json",
				"previews": [
					"bmw3/hood-preview.png",
					"bmw3/hood-m-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"bmw3/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"bmw3/lens.json"
				],
				"material": "glass",
				"area": "bmw3/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw3/rbumper.json",
					"bmw3/rbumper-m.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw3/rbumper-area.json",
				"previews": [
					"bmw3/rbumper-preview.png",
					"bmw3/rbumper-m-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw3/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw3/reflector-area.json",
				"previews": [
					"bmw3/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw3/roof.json",
					"bmw3/roof-m.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw3/roof-area.json",
				"previews": [
					"bmw3/roof-preview.png",
					"bmw3/roof-m-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw3/sideskirt.json",
					"bmw3/sideskirt-m.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw3/sideskirt-area.json",
				"previews": [
					"bmw3/sideskirt-preview.png",
					"bmw3/sideskirt-m-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw3/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw3/trunk-area.json",
				"previews": [
					"bmw3/trunk-preview.png"
				]
			}
		},
		"bmw5": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw5/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw5/body-area.json",
				"previews": [
					"bmw5/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"bmw5/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw5/fbumper.json",
					"bmw5/fbumper-m.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw5/fbumper-area.json",
				"previews": [
					"bmw5/fbumper-preview.png",
					"bmw5/fbumper-m-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"bmw5/glass.json"
				],
				"material": "glass",
				"area": "bmw5/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw5/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw5/hood-area.json",
				"previews": [
					"bmw5/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"bmw5/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"bmw5/lens.json"
				],
				"material": "glass",
				"area": "bmw5/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw5/rbumper.json",
					"bmw5/rbumper-m.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw5/rbumper-area.json",
				"previews": [
					"bmw5/rbumper-preview.png",
					"bmw5/rbumper-m-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw5/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw5/reflector-area.json",
				"previews": [
					"bmw5/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw5/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw5/roof-area.json",
				"previews": [
					"bmw5/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw5/sideskirt.json",
					"bmw5/sideskirt-m.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw5/sideskirt-area.json",
				"previews": [
					"bmw5/sideskirt-preview.png",
					"bmw5/sideskirt-m-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"bmw5/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "bmw5/trunk-area.json",
				"previews": [
					"bmw5/trunk-preview.png"
				]
			}
		},
		"c": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"c/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "c/body-area.json",
				"previews": [
					"c/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"c/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"c/fbumper.json",
					"c/fbumper-amg.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "c/fbumper-area.json",
				"previews": [
					"c/fbumper-preview.png",
					"c/fbumper-amg-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"c/glass.json"
				],
				"material": "glass",
				"area": "c/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"c/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "c/hood-area.json",
				"previews": [
					"c/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"c/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"c/lens.json"
				],
				"material": "glass",
				"area": "c/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"c/rbumper.json",
					"c/rbumper-amg.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "c/rbumper-area.json",
				"previews": [
					"c/rbumper-preview.png",
					"c/rbumper-amg-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"c/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "c/reflector-area.json",
				"previews": [
					"c/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"c/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "c/roof-area.json",
				"previews": [
					"c/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"c/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "c/sideskirt-area.json",
				"previews": [
					"c/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"c/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "c/trunk-area.json",
				"previews": [
					"c/trunk-preview.png"
				]
			}
		},
		"camry": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"camry/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "camry/body-area.json",
				"previews": [
					"camry/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"camry/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"camry/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "camry/fbumper-area.json",
				"previews": [
					"camry/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"camry/glass.json"
				],
				"material": "glass",
				"area": "camry/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"camry/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "camry/hood-area.json",
				"previews": [
					"camry/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"camry/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"camry/lens.json"
				],
				"material": "glass",
				"area": "camry/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"camry/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "camry/rbumper-area.json",
				"previews": [
					"camry/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"camry/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "camry/reflector-area.json",
				"previews": [
					"camry/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"camry/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "camry/roof-area.json",
				"previews": [
					"camry/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"camry/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "camry/sideskirt-area.json",
				"previews": [
					"camry/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"camry/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "camry/trunk-area.json",
				"previews": [
					"camry/trunk-preview.png"
				]
			}
		},
		"cayenne": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne/body-area.json",
				"previews": [
					"cayenne/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"cayenne/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne/fbumper.json",
					"cayenne/fbumper-hamann.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne/fbumper-area.json",
				"previews": [
					"cayenne/fbumper-preview.png",
					"cayenne/fbumper-hamann-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"cayenne/glass.json"
				],
				"material": "glass",
				"area": "cayenne/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne/hood-area.json",
				"previews": [
					"cayenne/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"cayenne/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"cayenne/lens.json"
				],
				"material": "glass",
				"area": "cayenne/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne/rbumper.json",
					"cayenne/rbumper-hamann.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne/rbumper-area.json",
				"previews": [
					"cayenne/rbumper-preview.png",
					"cayenne/rbumper-hamann-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne/reflector-area.json",
				"previews": [
					"cayenne/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne/roof-area.json",
				"previews": [
					"cayenne/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne/sideskirt-area.json",
				"previews": [
					"cayenne/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne/trunk-area.json",
				"previews": [
					"cayenne/trunk-preview.png"
				]
			}
		},
		"cayenne2015": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne2015/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne2015/body-area.json",
				"previews": [
					"cayenne2015/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"cayenne2015/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne2015/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne2015/fbumper-area.json",
				"previews": [
					"cayenne2015/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"cayenne2015/glass.json"
				],
				"material": "glass",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne2015/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne2015/hood-area.json",
				"previews": [
					"cayenne2015/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"cayenne2015/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"cayenne2015/lens.json"
				],
				"material": "glass",
				"area": "cayenne2015/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne2015/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne2015/rbumper-area.json",
				"previews": [
					"cayenne2015/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne2015/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne2015/reflector-area.json",
				"previews": [
					"cayenne2015/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne2015/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne2015/roof-area.json",
				"previews": [
					"cayenne2015/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne2015/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne2015/sideskirt-area.json",
				"previews": [
					"cayenne2015/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cayenne2015/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cayenne2015/trunk-area.json",
				"previews": [
					"cayenne2015/trunk-preview.png"
				]
			}
		},
		"cc": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cc/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cc/body-area.json",
				"previews": [
					"cc/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"cc/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cc/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cc/fbumper-area.json",
				"previews": [
					"cc/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"cc/glass.json"
				],
				"material": "glass",
				"area": "cc/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cc/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cc/hood-area.json",
				"previews": [
					"cc/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"cc/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"cc/lens.json"
				],
				"material": "glass",
				"area": "cc/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cc/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cc/rbumper-area.json",
				"previews": [
					"cc/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cc/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cc/reflector-area.json",
				"previews": [
					"cc/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cc/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cc/roof-area.json",
				"previews": [
					"cc/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cc/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cc/sideskirt-area.json",
				"previews": [
					"cc/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cc/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cc/trunk-area.json",
				"previews": [
					"cc/trunk-preview.png"
				]
			}
		},
		"civic": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"civic/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "civic/body-area.json",
				"previews": [
					"civic/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"civic/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"civic/fbumper.json",
					"civic/fbumper-si.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "civic/fbumper-area.json",
				"previews": [
					"civic/fbumper-preview.png",
					"civic/fbumper-si-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"civic/glass.json"
				],
				"material": "glass",
				"area": "civic/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"civic/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "civic/hood-area.json",
				"previews": [
					"civic/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"civic/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"civic/lens.json"
				],
				"material": "glass",
				"area": "civic/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"civic/rbumper.json",
					"civic/rbumper-si.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "civic/rbumper-area.json",
				"previews": [
					"civic/rbumper-preview.png",
					"civic/rbumper-si-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"civic/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "civic/reflector-area.json",
				"previews": [
					"civic/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"civic/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "civic/roof-area.json",
				"previews": [
					"civic/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"civic/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "civic/sideskirt-area.json",
				"previews": [
					"civic/sideskirt-preview.png"
				]
			},
			"spoiler": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"civic/spoiler-si.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "civic/spoiler-area.json",
				"previews": [
					"civic/spoiler-si-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"civic/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "civic/trunk-area.json",
				"previews": [
					"civic/trunk-preview.png"
				]
			}
		},
		"cla": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cla/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cla/body-area.json",
				"previews": [
					"cla/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"cla/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cla/fbumper.json",
					"cla/fbumper-amg.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cla/fbumper-area.json",
				"previews": [
					"cla/fbumper-preview.png",
					"cla/fbumper-amg-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"cla/glass.json"
				],
				"material": "glass",
				"area": "cla/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cla/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cla/hood-area.json",
				"previews": [
					"cla/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"cla/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"cla/lens.json"
				],
				"material": "glass",
				"area": "cla/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cla/rbumper.json",
					"cla/rbumper-amg.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cla/rbumper-area.json",
				"previews": [
					"cla/rbumper-preview.png",
					"cla/rbumper-amg-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cla/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cla/reflector-area.json",
				"previews": [
					"cla/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cla/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cla/roof-area.json",
				"previews": [
					"cla/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cla/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cla/sideskirt-area.json",
				"previews": [
					"cla/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cla/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cla/trunk-area.json",
				"previews": [
					"cla/trunk-preview.png"
				]
			}
		},
		"cooper": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cooper/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cooper/body-area.json",
				"previews": [
					"cooper/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"cooper/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cooper/fbumper.json",
					"cooper/fbumper-jcw.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cooper/fbumper-area.json",
				"previews": [
					"cooper/fbumper-preview.png",
					"cooper/fbumper-jcw-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"cooper/glass.json"
				],
				"material": "glass",
				"area": "cooper/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cooper/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cooper/hood-area.json",
				"previews": [
					"cooper/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"cooper/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"cooper/lens.json"
				],
				"material": "glass",
				"area": "cooper/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cooper/rbumper.json",
					"cooper/rbumper-jcw.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cooper/rbumper-area.json",
				"previews": [
					"cooper/rbumper-preview.png",
					"cooper/rbumper-jcw-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cooper/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cooper/reflector-area.json",
				"previews": [
					"cooper/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cooper/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cooper/roof-area.json",
				"previews": [
					"cooper/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cooper/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"previews": [
					"cooper/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cooper/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cooper/trunk-area.json",
				"previews": [
					"cooper/trunk-preview.png"
				]
			}
		},
		"countryman": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"countryman/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "countryman/body-area.json",
				"previews": [
					"countryman/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"countryman/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"countryman/fbumper.json",
					"countryman/fbumper-jcw.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "countryman/fbumper-area.json",
				"previews": [
					"countryman/fbumper-preview.png",
					"countryman/fbumper-jcw-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"countryman/glass.json"
				],
				"material": "glass",
				"area": "countryman/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"countryman/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "countryman/hood-area.json",
				"previews": [
					"countryman/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"countryman/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"countryman/lens.json"
				],
				"material": "glass",
				"area": "countryman/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"countryman/rbumper.json",
					"countryman/rbumper-jcw.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "countryman/rbumper-area.json",
				"previews": [
					"countryman/rbumper-preview.png",
					"countryman/rbumper-jcw-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"countryman/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "countryman/reflector-area.json",
				"previews": [
					"countryman/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"countryman/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "countryman/roof-area.json",
				"previews": [
					"countryman/roof-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"countryman/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "countryman/trunk-area.json",
				"previews": [
					"countryman/trunk-preview.png"
				]
			}
		},
		"coupe": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"coupe/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "coupe/body-area.json",
				"previews": [
					"coupe/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"coupe/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"coupe/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "coupe/fbumper-area.json",
				"previews": [
					"coupe/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"coupe/glass.json"
				],
				"material": "glass",
				"area": "coupe/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"coupe/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "coupe/hood-area.json",
				"previews": [
					"coupe/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"coupe/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"coupe/lens.json"
				],
				"material": "glass",
				"area": "coupe/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"coupe/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "coupe/rbumper-area.json",
				"previews": [
					"coupe/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"coupe/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "coupe/reflector-area.json",
				"previews": [
					"coupe/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"coupe/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "coupe/roof-area.json",
				"previews": [
					"coupe/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"coupe/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "coupe/sideskirt-area.json",
				"previews": [
					"coupe/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"coupe/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "coupe/trunk-area.json",
				"previews": [
					"coupe/trunk-preview.png"
				]
			}
		},
		"cruze": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cruze/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cruze/body-area.json",
				"previews": [
					"cruze/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"cruze/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cruze/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cruze/fbumper-area.json",
				"previews": [
					"cruze/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"cruze/glass.json"
				],
				"material": "glass",
				"area": "cruze/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cruze/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cruze/hood-area.json",
				"previews": [
					"cruze/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"cruze/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"cruze/lens.json"
				],
				"material": "glass",
				"area": "cruze/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cruze/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cruze/rbumper-area.json",
				"previews": [
					"cruze/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cruze/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cruze/reflector-area.json",
				"previews": [
					"cruze/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cruze/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cruze/roof-area.json",
				"previews": [
					"cruze/roof-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cruze/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cruze/trunk-area.json",
				"previews": [
					"cruze/trunk-preview.png"
				]
			}
		},
		"ct": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ct/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ct/body-area.json",
				"previews": [
					"ct/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"ct/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ct/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ct/fbumper-area.json",
				"previews": [
					"ct/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"ct/glass.json"
				],
				"material": "glass",
				"area": "ct/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ct/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ct/hood-area.json",
				"previews": [
					"ct/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"ct/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"ct/lens.json"
				],
				"material": "glass",
				"area": "ct/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ct/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ct/rbumper-area.json",
				"previews": [
					"ct/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ct/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ct/reflector-area.json",
				"previews": [
					"ct/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ct/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ct/roof-area.json",
				"previews": [
					"ct/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ct/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ct/sideskirt-area.json",
				"previews": [
					"ct/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ct/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ct/trunk-area.json",
				"previews": [
					"ct/trunk-preview.png"
				]
			}
		},
		"cts": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cts/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cts/body-area.json",
				"previews": [
					"cts/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"cts/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cts/fbumper.json",
					"cts/fbumper-v.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cts/fbumper-area.json",
				"previews": [
					"cts/fbumper-preview.png",
					"cts/fbumper-v-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"cts/glass.json"
				],
				"material": "glass",
				"area": "cts/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cts/hood.json",
					"cts/hood-v.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cts/hood-area.json",
				"previews": [
					"cts/hood-preview.png",
					"cts/hood-v-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"cts/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"cts/lens.json"
				],
				"material": "glass",
				"area": "cts/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cts/rbumper.json",
					"cts/rbumper-v.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cts/rbumper-area.json",
				"previews": [
					"cts/rbumper-preview.png",
					"cts/rbumper-v-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cts/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cts/reflector-area.json",
				"previews": [
					"cts/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cts/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cts/roof-area.json",
				"previews": [
					"cts/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cts/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cts/sideskirt-area.json",
				"previews": [
					"cts/sideskirt-preview.png"
				]
			},
			"spoiler": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cts/spoiler-v.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cts/spoiler-area.json",
				"previews": [
					"cts/spoiler-v-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"cts/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "cts/trunk-area.json",
				"previews": [
					"cts/trunk-preview.png"
				]
			}
		},
		"e": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"e/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "e/body-area.json",
				"previews": [
					"e/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"e/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"e/fbumper.json",
					"e/fbumper-amg.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "e/fbumper-area.json",
				"previews": [
					"e/fbumper-preview.png",
					"e/fbumper-amg-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"e/glass.json"
				],
				"material": "glass",
				"area": "e/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"e/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "e/hood-area.json",
				"previews": [
					"e/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"e/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"e/lens.json"
				],
				"material": "glass",
				"area": "e/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"e/rbumper.json",
					"e/rbumper-amg.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "e/rbumper-area.json",
				"previews": [
					"e/rbumper-preview.png",
					"e/rbumper-amg-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"e/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "e/reflector-area.json",
				"previews": [
					"e/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"e/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "e/roof-area.json",
				"previews": [
					"e/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"e/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "e/sideskirt-area.json",
				"previews": [
					"e/sideskirt-preview.png"
				]
			},
			"spoiler": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"e/spoiler-amg.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "e/spoiler-area.json",
				"previews": [
					"e/spoiler-amg-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"e/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "e/trunk-area.json",
				"previews": [
					"e/trunk-preview.png"
				]
			}
		},
		"evoque": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"evoque/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "evoque/body-area.json",
				"previews": [
					"evoque/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"evoque/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"evoque/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "evoque/fbumper-area.json",
				"previews": [
					"evoque/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"evoque/glass.json"
				],
				"material": "glass",
				"area": "evoque/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"evoque/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "evoque/hood-area.json",
				"previews": [
					"evoque/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"evoque/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"evoque/lens.json"
				],
				"material": "glass",
				"area": "evoque/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"evoque/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "evoque/rbumper-area.json",
				"previews": [
					"evoque/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"evoque/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "evoque/reflector-area.json",
				"previews": [
					"evoque/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"evoque/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "evoque/roof-area.json",
				"previews": [
					"evoque/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"evoque/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "evoque/sideskirt-area.json",
				"previews": [
					"evoque/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"evoque/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "evoque/trunk-area.json",
				"previews": [
					"evoque/trunk-preview.png"
				]
			}
		},
		"focus": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"focus/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "focus/body-area.json",
				"previews": [
					"focus/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"focus/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"focus/fbumper.json",
					"focus/fbumper-rs.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "focus/fbumper-area.json",
				"previews": [
					"focus/fbumper-preview.png",
					"focus/fbumper-rs-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"focus/glass.json"
				],
				"material": "glass",
				"area": "focus/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"focus/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "focus/hood-area.json",
				"previews": [
					"focus/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"focus/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"focus/lens.json"
				],
				"material": "glass",
				"area": "focus/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"focus/rbumper.json",
					"focus/rbumper-rs.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "focus/rbumper-area.json",
				"previews": [
					"focus/rbumper-preview.png",
					"focus/rbumper-rs-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"focus/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "focus/reflector-area.json",
				"previews": [
					"focus/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"focus/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "focus/roof-area.json",
				"previews": [
					"focus/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"focus/sideskirt-rs.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "focus/sideskirt-area.json",
				"previews": [
					"focus/sideskirt-rs-preview.png"
				]
			},
			"spoiler": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"focus/spoiler.json",
					"focus/spoiler-rs.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "focus/spoiler-area.json",
				"previews": [
					"focus/spoiler-preview.png",
					"focus/spoiler-rs-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"focus/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "focus/trunk-area.json",
				"previews": [
					"focus/trunk-preview.png"
				]
			}
		},
		"ghibili": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ghibili/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ghibili/body-area.json",
				"previews": [
					"ghibili/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"ghibili/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ghibili/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ghibili/fbumper-area.json",
				"previews": [
					"ghibili/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"ghibili/glass.json"
				],
				"material": "glass",
				"area": "ghibili/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ghibili/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ghibili/hood-area.json",
				"previews": [
					"ghibili/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"ghibili/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"ghibili/lens.json"
				],
				"material": "glass",
				"area": "ghibili/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ghibili/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ghibili/rbumper-area.json",
				"previews": [
					"ghibili/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ghibili/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ghibili/reflector-area.json",
				"previews": [
					"ghibili/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ghibili/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ghibili/roof-area.json",
				"previews": [
					"ghibili/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ghibili/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ghibili/sideskirt-area.json",
				"previews": [
					"ghibili/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"ghibili/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "ghibili/trunk-area.json",
				"previews": [
					"ghibili/trunk-preview.png"
				]
			}
		},
		"golf": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"golf/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "golf/body-area.json",
				"previews": [
					"golf/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"golf/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"golf/fbumper.json",
					"golf/fbumper-r.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "golf/fbumper-area.json",
				"previews": [
					"golf/fbumper-preview.png",
					"golf/fbumper-r-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"golf/glass.json"
				],
				"material": "glass",
				"area": "golf/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"golf/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "golf/hood-area.json",
				"previews": [
					"golf/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"golf/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"golf/lens.json"
				],
				"material": "glass",
				"area": "golf/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"golf/rbumper.json",
					"golf/rbumper-r.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "golf/rbumper-area.json",
				"previews": [
					"golf/rbumper-preview.png",
					"golf/rbumper-r-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"golf/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "golf/reflector-area.json",
				"previews": [
					"golf/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"golf/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "golf/roof-area.json",
				"previews": [
					"golf/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"golf/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "golf/sideskirt-area.json",
				"previews": [
					"golf/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"golf/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "golf/trunk-area.json",
				"previews": [
					"golf/trunk-preview.png"
				]
			}
		},
		"gtr": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"gtr/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "gtr/body-area.json",
				"previews": [
					"gtr/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"gtr/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"gtr/fbumper.json",
					"gtr/fbumper-nismo.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "gtr/fbumper-area.json",
				"previews": [
					"gtr/fbumper-preview.png",
					"gtr/fbumper-nismo-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"gtr/glass.json"
				],
				"material": "glass",
				"area": "gtr/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"gtr/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "gtr/hood-area.json",
				"previews": [
					"gtr/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"gtr/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"gtr/lens.json"
				],
				"material": "glass",
				"area": "gtr/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"gtr/rbumper.json",
					"gtr/rbumper-nismo.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "gtr/rbumper-area.json",
				"previews": [
					"gtr/rbumper-preview.png",
					"gtr/rbumper-nismo-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"gtr/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "gtr/reflector-area.json",
				"previews": [
					"gtr/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"gtr/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "gtr/roof-area.json",
				"previews": [
					"gtr/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"gtr/sideskirt.json",
					"gtr/sideskirt-nismo.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "gtr/sideskirt-area.json",
				"previews": [
					"gtr/sideskirt-preview.png",
					"gtr/sideskirt-nismo-preview.png"
				]
			},
			"spoiler": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"gtr/spoiler.json",
					"gtr/spoiler-nismo.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "gtr/spoiler-area.json",
				"previews": [
					"gtr/spoiler-preview.png",
					"gtr/spoiler-nismo-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"gtr/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "gtr/trunk-area.json",
				"previews": [
					"gtr/trunk-preview.png"
				]
			}
		},
		"is": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"is/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "is/body-area.json",
				"previews": [
					"is/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"is/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"is/fbumper.json",
					"is/fbumper-sport.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "is/fbumper-area.json",
				"previews": [
					"is/fbumper-preview.png",
					"is/fbumper-sport-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"is/glass.json"
				],
				"material": "glass",
				"area": "is/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"is/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "is/hood-area.json",
				"previews": [
					"is/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"is/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"is/lens.json"
				],
				"material": "glass",
				"area": "is/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"is/rbumper.json",
					"is/rbumper-sport.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "is/rbumper-area.json",
				"previews": [
					"is/rbumper-preview.png",
					"is/rbumper-sport-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"is/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "is/reflector-area.json",
				"previews": [
					"is/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"is/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "is/roof-area.json",
				"previews": [
					"is/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"is/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "is/sideskirt-area.json",
				"previews": [
					"is/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"is/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "is/trunk-area.json",
				"previews": [
					"is/trunk-preview.png"
				]
			}
		},
		"k5": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"k5/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "k5/body-area.json",
				"previews": [
					"k5/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"k5/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"k5/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "k5/fbumper-area.json",
				"previews": [
					"k5/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"k5/glass.json"
				],
				"material": "glass",
				"area": "k5/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"k5/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "k5/hood-area.json",
				"previews": [
					"k5/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"k5/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"k5/lens.json"
				],
				"material": "glass",
				"area": "k5/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"k5/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "k5/rbumper-area.json",
				"previews": [
					"k5/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"k5/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "k5/reflector-area.json",
				"previews": [
					"k5/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"k5/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "k5/roof-area.json",
				"previews": [
					"k5/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"k5/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "k5/sideskirt-area.json",
				"previews": [
					"k5/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"k5/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "k5/trunk-area.json",
				"previews": [
					"k5/trunk-preview.png"
				]
			}
		},
		"lancer": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"lancer/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "lancer/body-area.json",
				"previews": [
					"lancer/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"lancer/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"lancer/fbumper.json",
					"lancer/fbumper-evo.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "lancer/fbumper-area.json",
				"previews": [
					"lancer/fbumper-preview.png",
					"lancer/fbumper-evo-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"lancer/glass.json"
				],
				"material": "glass",
				"area": "lancer/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"lancer/hood.json",
					"lancer/hood-evo.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "lancer/hood-area.json",
				"previews": [
					"lancer/hood-preview.png",
					"lancer/hood-evo-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"lancer/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"lancer/lens.json"
				],
				"material": "glass",
				"area": "lancer/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"lancer/rbumper.json",
					"lancer/rbumper-evo.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "lancer/rbumper-area.json",
				"previews": [
					"lancer/rbumper-preview.png",
					"lancer/rbumper-evo-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"lancer/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "lancer/reflector-area.json",
				"previews": [
					"lancer/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"lancer/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "lancer/roof-area.json",
				"previews": [
					"lancer/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"lancer/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "lancer/sideskirt-area.json",
				"previews": [
					"lancer/sideskirt-preview.png"
				]
			},
			"spoiler": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"lancer/spoiler-evo.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "lancer/spoiler-area.json",
				"previews": [
					"lancer/spoiler-evo-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"lancer/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "lancer/trunk-area.json",
				"previews": [
					"lancer/trunk-preview.png"
				]
			}
		},
		"macan": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"macan/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "macan/body-area.json",
				"previews": [
					"macan/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"macan/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"macan/fbumper.json",
					"macan/fbumper-hamann.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "macan/fbumper-area.json",
				"previews": [
					"macan/fbumper-preview.png",
					"macan/fbumper-hamann-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"macan/glass.json"
				],
				"material": "glass",
				"area": "macan/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"macan/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "macan/hood-area.json",
				"previews": [
					"macan/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"macan/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"macan/lens.json"
				],
				"material": "glass",
				"area": "macan/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"macan/rbumper.json",
					"macan/rbumper-hamann.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "macan/rbumper-area.json",
				"previews": [
					"macan/rbumper-preview.png",
					"macan/rbumper-hamann-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"macan/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "macan/reflector-area.json",
				"previews": [
					"macan/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"macan/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "macan/roof-area.json",
				"previews": [
					"macan/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"macan/sideskirt.json",
					"macan/sideskirt-hamann.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "macan/sideskirt-area.json",
				"previews": [
					"macan/sideskirt-preview.png",
					"macan/sideskirt-hamann-preview.png"
				]
			},
			"spoiler": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"macan/spoiler.json",
					"macan/spoiler-hamann.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "macan/spoiler-area.json",
				"previews": [
					"macan/spoiler-hamann-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"macan/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "macan/trunk-area.json",
				"previews": [
					"macan/trunk-preview.png"
				]
			}
		},
		"malibu": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"malibu/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "malibu/body-area.json",
				"previews": [
					"malibu/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"malibu/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"malibu/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "malibu/fbumper-area.json",
				"previews": [
					"malibu/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"malibu/glass.json"
				],
				"material": "glass",
				"area": "malibu/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"malibu/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "malibu/hood-area.json",
				"previews": [
					"malibu/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"malibu/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"malibu/lens.json"
				],
				"material": "glass",
				"area": "malibu/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"malibu/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "malibu/rbumper-area.json",
				"previews": [
					"malibu/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"malibu/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "malibu/reflector-area.json",
				"previews": [
					"malibu/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"malibu/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "malibu/roof-area.json",
				"previews": [
					"malibu/roof-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"malibu/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "malibu/trunk-area.json",
				"previews": [
					"malibu/trunk-preview.png"
				]
			}
		},
		"mazda6": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mazda6/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mazda6/body-area.json",
				"previews": [
					"mazda6/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"mazda6/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mazda6/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mazda6/fbumper-area.json",
				"previews": [
					"mazda6/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"mazda6/glass.json"
				],
				"material": "glass",
				"area": "mazda6/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mazda6/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mazda6/hood-area.json",
				"previews": [
					"mazda6/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"mazda6/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"mazda6/lens.json"
				],
				"material": "glass",
				"area": "mazda6/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mazda6/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mazda6/rbumper-area.json",
				"previews": [
					"mazda6/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mazda6/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mazda6/reflector-area.json",
				"previews": [
					"mazda6/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mazda6/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mazda6/roof-area.json",
				"previews": [
					"mazda6/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mazda6/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mazda6/sideskirt-area.json",
				"previews": [
					"mazda6/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mazda6/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mazda6/trunk-area.json",
				"previews": [
					"mazda6/trunk-preview.png"
				]
			}
		},
		"mondeo": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mondeo/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mondeo/body-area.json",
				"previews": [
					"mondeo/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"mondeo/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mondeo/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mondeo/fbumper-area.json",
				"previews": [
					"mondeo/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"mondeo/glass.json"
				],
				"material": "glass",
				"area": "mondeo/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mondeo/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mondeo/hood-area.json",
				"previews": [
					"mondeo/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"mondeo/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"mondeo/lens.json"
				],
				"material": "glass",
				"area": "mondeo/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mondeo/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mondeo/rbumper-area.json",
				"previews": [
					"mondeo/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mondeo/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mondeo/reflector-area.json",
				"previews": [
					"mondeo/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mondeo/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mondeo/roof-area.json",
				"previews": [
					"mondeo/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mondeo/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mondeo/sideskirt-area.json",
				"previews": [
					"mondeo/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"mondeo/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "mondeo/trunk-area.json",
				"previews": [
					"mondeo/trunk-preview.png"
				]
			}
		},
		"panamera": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"panamera/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "panamera/body-area.json",
				"previews": [
					"panamera/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"panamera/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"panamera/fbumper.json",
					"panamera/fbumper-hamann.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "panamera/fbumper-area.json",
				"previews": [
					"panamera/fbumper-preview.png",
					"panamera/fbumper-hamann-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"panamera/glass.json"
				],
				"material": "glass",
				"area": "panamera/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"panamera/hood.json",
					"panamera/hood-hamann.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "panamera/hood-area.json",
				"previews": [
					"panamera/hood-preview.png",
					"panamera/hood-hamann-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"panamera/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"panamera/lens.json"
				],
				"material": "glass",
				"area": "panamera/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"panamera/rbumper.json",
					"panamera/rbumper-hamann.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "panamera/rbumper-area.json",
				"previews": [
					"panamera/rbumper-preview.png",
					"panamera/rbumper-hamann-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"panamera/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "panamera/reflector-area.json",
				"previews": [
					"panamera/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"panamera/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "panamera/roof-area.json",
				"previews": [
					"panamera/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"panamera/sideskirt.json",
					"panamera/sideskirt-hamann.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "panamera/sideskirt-area.json",
				"previews": [
					"panamera/sideskirt-preview.png",
					"panamera/sideskirt-hamann-preview.png"
				]
			},
			"spoiler": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"panamera/spoiler-hamann.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "panamera/spoiler-area.json",
				"previews": [
					"panamera/spoiler-hamann-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"panamera/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "panamera/trunk-area.json",
				"previews": [
					"panamera/trunk-preview.png"
				]
			}
		},
		"q50l": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"q50l/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "q50l/body-area.json",
				"previews": [
					"q50l/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"q50l/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"q50l/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "q50l/fbumper-area.json",
				"previews": [
					"q50l/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"q50l/glass.json"
				],
				"material": "glass",
				"area": "q50l/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"q50l/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "q50l/hood-area.json",
				"previews": [
					"q50l/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"q50l/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"q50l/lens.json"
				],
				"material": "glass",
				"area": "q50l/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"q50l/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "q50l/rbumper-area.json",
				"previews": [
					"q50l/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"q50l/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "q50l/reflector-area.json",
				"previews": [
					"q50l/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"q50l/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "q50l/roof-area.json",
				"previews": [
					"q50l/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"q50l/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "q50l/sideskirt-area.json",
				"previews": [
					"q50l/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"q50l/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "q50l/trunk-area.json",
				"previews": [
					"q50l/trunk-preview.png"
				]
			}
		},
		"regal": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"regal/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "regal/body-area.json",
				"previews": [
					"regal/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"regal/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"regal/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "regal/fbumper-area.json",
				"previews": [
					"regal/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"regal/glass.json"
				],
				"material": "glass",
				"area": "regal/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"regal/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "regal/hood-area.json",
				"previews": [
					"regal/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"regal/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"regal/lens.json"
				],
				"material": "glass",
				"area": "regal/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"regal/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "regal/rbumper-area.json",
				"previews": [
					"regal/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"regal/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "regal/reflector-area.json",
				"previews": [
					"regal/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"regal/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "regal/roof-area.json",
				"previews": [
					"regal/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"regal/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "regal/sideskirt-area.json",
				"previews": [
					"regal/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"regal/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "regal/trunk-area.json",
				"previews": [
					"regal/trunk-preview.png"
				]
			}
		},
		"reiz": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"reiz/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "reiz/body-area.json",
				"previews": [
					"reiz/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"reiz/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"reiz/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "reiz/fbumper-area.json",
				"previews": [
					"reiz/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"reiz/glass.json"
				],
				"material": "glass",
				"area": "reiz/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"reiz/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "reiz/hood-area.json",
				"previews": [
					"reiz/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"reiz/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"reiz/lens.json"
				],
				"material": "glass",
				"area": "reiz/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"reiz/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "reiz/rbumper-area.json",
				"previews": [
					"reiz/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"reiz/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "reiz/reflector-area.json",
				"previews": [
					"reiz/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"reiz/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "reiz/roof-area.json",
				"previews": [
					"reiz/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"reiz/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "reiz/sideskirt-area.json",
				"previews": [
					"reiz/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"reiz/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "reiz/trunk-area.json",
				"previews": [
					"reiz/trunk-preview.png"
				]
			}
		},
		"scirocco": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"scirocco/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "scirocco/body-area.json",
				"previews": [
					"scirocco/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"scirocco/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"scirocco/fbumper.json",
					"scirocco/fbumper-r.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "scirocco/fbumper-area.json",
				"previews": [
					"scirocco/fbumper-preview.png",
					"scirocco/fbumper-r-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"scirocco/glass.json"
				],
				"material": "glass",
				"area": "scirocco/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"scirocco/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "scirocco/hood-area.json",
				"previews": [
					"scirocco/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"scirocco/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"scirocco/lens.json"
				],
				"material": "glass",
				"area": "scirocco/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"scirocco/rbumper.json",
					"scirocco/rbumper-r.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "scirocco/rbumper-area.json",
				"previews": [
					"scirocco/rbumper-preview.png",
					"scirocco/rbumper-r-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"scirocco/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "scirocco/reflector-area.json",
				"previews": [
					"scirocco/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"scirocco/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "scirocco/roof-area.json",
				"previews": [
					"scirocco/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"scirocco/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "scirocco/sideskirt-area.json",
				"previews": [
					"scirocco/sideskirt-preview.png"
				]
			},
			"spoiler": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"scirocco/spoiler.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"previews": false
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"scirocco/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "scirocco/trunk-area.json",
				"previews": [
					"scirocco/trunk-preview.png"
				]
			}
		},
		"smart": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"smart/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "smart/body-area.json",
				"previews": [
					"smart/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"smart/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"smart/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "smart/fbumper-area.json",
				"previews": [
					"smart/fbumper-preview.png"
				]
			},
			"frame": {
				"color": "#ffffff",
				"choices": [
					"smart/frame.json"
				],
				"area": "smart/frame-area.json",
				"previews": [
					"smart/frame-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"smart/glass.json"
				],
				"material": "glass",
				"area": "smart/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"smart/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "smart/hood-area.json",
				"previews": [
					"smart/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"smart/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"smart/lens.json"
				],
				"material": "glass",
				"area": "smart/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"smart/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "smart/rbumper-area.json",
				"previews": [
					"smart/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"smart/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "smart/reflector-area.json",
				"previews": [
					"smart/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"smart/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "smart/roof-area.json",
				"previews": [
					"smart/roof-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"smart/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "smart/trunk-area.json",
				"previews": [
					"smart/trunk-preview.png"
				]
			}
		},
		"sonata": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"sonata/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "sonata/body-area.json",
				"previews": [
					"sonata/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"sonata/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"sonata/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "sonata/fbumper-area.json",
				"previews": [
					"sonata/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"sonata/glass.json"
				],
				"material": "glass",
				"area": "sonata/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"sonata/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "sonata/hood-area.json",
				"previews": [
					"sonata/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"sonata/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"sonata/lens.json"
				],
				"material": "glass",
				"area": "sonata/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"sonata/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "sonata/rbumper-area.json",
				"previews": [
					"sonata/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"sonata/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "sonata/reflector-area.json",
				"previews": [
					"sonata/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"sonata/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "sonata/roof-area.json",
				"previews": [
					"sonata/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"sonata/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "sonata/sideskirt-area.json",
				"previews": [
					"sonata/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"sonata/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "sonata/trunk-area.json",
				"previews": [
					"sonata/trunk-preview.png"
				]
			}
		},
		"spirior": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"spirior/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "spirior/body-area.json",
				"previews": [
					"spirior/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"spirior/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"spirior/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "spirior/fbumper-area.json",
				"previews": [
					"spirior/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"spirior/glass.json"
				],
				"material": "glass",
				"area": "spirior/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"spirior/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "spirior/hood-area.json",
				"previews": [
					"spirior/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"spirior/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"spirior/lens.json"
				],
				"material": "glass",
				"area": "spirior/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"spirior/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "spirior/rbumper-area.json",
				"previews": [
					"spirior/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"spirior/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "spirior/reflector-area.json",
				"previews": [
					"spirior/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"spirior/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "spirior/roof-area.json",
				"previews": [
					"spirior/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"spirior/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "spirior/sideskirt-area.json",
				"previews": [
					"spirior/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"spirior/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "spirior/trunk-area.json",
				"previews": [
					"spirior/trunk-preview.png"
				]
			}
		},
		"tt": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"tt/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "tt/body-area.json",
				"previews": [
					"tt/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"tt/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"tt/fbumper.json",
					"tt/fbumper-rs.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "tt/fbumper-area.json",
				"previews": [
					"tt/fbumper-preview.png",
					"tt/fbumper-rs-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"tt/glass.json"
				],
				"material": "glass",
				"area": "tt/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"tt/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "tt/hood-area.json",
				"previews": [
					"tt/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"tt/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"tt/lens.json"
				],
				"material": "glass",
				"area": "tt/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"tt/rbumper.json",
					"tt/rbumper-rs.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "tt/rbumper-area.json",
				"previews": [
					"tt/rbumper-preview.png",
					"tt/rbumper-rs-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"tt/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "tt/reflector-area.json",
				"previews": [
					"tt/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"tt/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "tt/roof-area.json",
				"previews": [
					"tt/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"tt/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "tt/sideskirt-area.json",
				"previews": [
					"tt/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"tt/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "tt/trunk-area.json",
				"previews": [
					"tt/trunk-preview.png"
				]
			}
		},
		"xf": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xf/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xf/body-area.json",
				"previews": [
					"xf/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"xf/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xf/fbumper.json",
					"xf/fbumper-rs.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xf/fbumper-area.json",
				"previews": [
					"xf/fbumper-preview.png",
					"xf/fbumper-rs-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"xf/glass.json"
				],
				"material": "glass",
				"area": "xf/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xf/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xf/hood-area.json",
				"previews": [
					"xf/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"xf/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"xf/lens.json"
				],
				"material": "glass",
				"area": "xf/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xf/rbumper.json",
					"xf/rbumper-rs.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xf/rbumper-area.json",
				"previews": [
					"xf/rbumper-preview.png",
					"xf/rbumper-rs-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xf/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xf/reflector-area.json",
				"previews": [
					"xf/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xf/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xf/roof-area.json",
				"previews": [
					"xf/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xf/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xf/sideskirt-area.json",
				"previews": [
					"xf/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xf/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xf/trunk-area.json",
				"previews": [
					"xf/trunk-preview.png"
				]
			}
		},
		"xj": {
			"body": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xj/body.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xj/body-area.json",
				"previews": [
					"xj/body-preview.png"
				]
			},
			"chassis": {
				"color": "#ffffff",
				"choices": [
					"xj/chassis.json"
				],
				"previews": false
			},
			"fbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xj/fbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xj/fbumper-area.json",
				"previews": [
					"xj/fbumper-preview.png"
				]
			},
			"glass": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"xj/glass.json"
				],
				"material": "glass",
				"area": "xj/glass-area.json",
				"previews": false
			},
			"hood": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xj/hood.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xj/hood-area.json",
				"previews": [
					"xj/hood-preview.png"
				]
			},
			"interior": {
				"color": "#ffffff",
				"choices": [
					"xj/interior.json"
				],
				"previews": false
			},
			"lens": {
				"reflectivity": 1,
				"color": "#ffffff",
				"choices": [
					"xj/lens.json"
				],
				"material": "glass",
				"area": "xj/lens-area.json",
				"previews": false
			},
			"rbumper": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xj/rbumper.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xj/rbumper-area.json",
				"previews": [
					"xj/rbumper-preview.png"
				]
			},
			"reflector": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xj/reflector.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xj/reflector-area.json",
				"previews": [
					"xj/reflector-preview.png"
				]
			},
			"roof": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xj/roof.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xj/roof-area.json",
				"previews": [
					"xj/roof-preview.png"
				]
			},
			"sideskirt": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xj/sideskirt.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xj/sideskirt-area.json",
				"previews": [
					"xj/sideskirt-preview.png"
				]
			},
			"trunk": {
				"all": true,
				"set": true,
				"color": "#ffffff",
				"choices": [
					"xj/trunk.json"
				],
				"material": "normal",
				"materials": [
					"carbon",
					"discolor",
					"drawbench",
					"electroplate",
					"matte",
					"matting",
					"normal"
				],
				"area": "xj/trunk-area.json",
				"previews": [
					"xj/trunk-preview.png"
				]
			}
		}
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = {
		"14": {
			"tyre": {
				"choices": [
					"14/tyre14.json"
				],
				"area": "tyre/tyre14.json",
				"previews": false
			},
			"rim": {
				"choices": [
					"14/MSW-14.json",
					"14/MSW-19.json",
					"14/MSW-20-4.json",
					"14/MSW-22.json",
					"14/MSW-77.json",
					"14/MSW-85.json",
					"14/Sparco-Pista.json"
				],
				"color": "#ffffff",
				"material": "steel",
				"materials": [
					"discolor",
					"electroplate",
					"matte"
				],
				"previews": [
					"14/MSW-14-preview.png",
					"14/MSW-19-preview.png",
					"14/MSW-20-4-preview.png",
					"14/MSW-22-preview.png",
					"14/MSW-77-preview.png",
					"14/MSW-85-preview.png",
					"14/Sparco-Pista-preview.png"
				],
				"area": "rim/14.json",
				"set": true
			},
			"caliper": {
				"choices": [
					"14/caliper.json"
				],
				"material": "steel",
				"set": true,
				"previews": false
			}
		},
		"15": {
			"tyre": {
				"choices": [
					"15/tyre15.json"
				],
				"area": "tyre/tyre15.json",
				"previews": false
			},
			"rim": {
				"choices": [
					"15/MSW-11.json",
					"15/MSW-14.json",
					"15/MSW-19.json",
					"15/MSW-20-4.json",
					"15/MSW-22.json",
					"15/MSW-23.json",
					"15/MSW-24.json",
					"15/MSW-77.json",
					"15/MSW-85.json",
					"15/MSW-86.json",
					"15/Sparco-Drift.json",
					"15/Sparco-RTT.json",
					"15/Sparco-Assettogara.json",
					"15/Sparco-Pista.json"
				],
				"color": "#ffffff",
				"material": "steel",
				"materials": [
					"discolor",
					"electroplate",
					"matte"
				],
				"previews": [
					"15/MSW-11-preview.png",
					"15/MSW-14-preview.png",
					"15/MSW-19-preview.png",
					"15/MSW-20-4-preview.png",
					"15/MSW-22-preview.png",
					"15/MSW-23-preview.png",
					"15/MSW-24-preview.png",
					"15/MSW-77-preview.png",
					"15/MSW-85-preview.png",
					"15/MSW-86-preview.png",
					"15/Sparco-Drift-preview.png",
					"15/Sparco-RTT-preview.png",
					"15/Sparco-Assettogara-preview.png",
					"15/Sparco-Pista-preview.png"
				],
				"area": "rim/15.json",
				"set": true
			},
			"caliper": {
				"choices": [
					"15/caliper.json"
				],
				"material": "steel",
				"set": true,
				"previews": false
			}
		},
		"16": {
			"tyre": {
				"choices": [
					"16/tyre16.json"
				],
				"area": "tyre/tyre16.json",
				"previews": false
			},
			"rim": {
				"choices": [
					"16/BBS-SR.json",
					"16/MSW-11.json",
					"16/MSW-14.json",
					"16/MSW-19.json",
					"16/MSW-20-4.json",
					"16/MSW-22.json",
					"16/MSW-23.json",
					"16/MSW-25.json",
					"16/MSW-26.json",
					"16/MSW-77.json",
					"16/AEZ-Valencia.json",
					"16/MSW-20-5.json",
					"16/MSW-24.json",
					"16/MSW-85.json",
					"16/MSW-86.json",
					"16/MSW-Crossover.json",
					"16/Sparco-Assettogara.json",
					"16/Sparco-Drift.json",
					"16/Sparco-Pista.json",
					"16/Sparco-RTT.json",
					"16/Sparco-Terra.json"
				],
				"color": "#ffffff",
				"material": "steel",
				"materials": [
					"discolor",
					"electroplate",
					"matte"
				],
				"previews": [
					"16/BBS-SR-preview.png",
					"16/MSW-11-preview.png",
					"16/MSW-14-preview.png",
					"16/MSW-19-preview.png",
					"16/MSW-20-4-preview.png",
					"16/MSW-22-preview.png",
					"16/MSW-23-preview.png",
					"16/MSW-25-preview.png",
					"16/MSW-26-preview.png",
					"16/MSW-77-preview.png",
					"16/AEZ-Valencia-preview.png",
					"16/MSW-20-5-preview.png",
					"16/MSW-24-preview.png",
					"16/MSW-85-preview.png",
					"16/MSW-86-preview.png",
					"16/MSW-Crossover-preview.png",
					"16/Sparco-Assettogara-preview.png",
					"16/Sparco-Drift-preview.png",
					"16/Sparco-Pista-preview.png",
					"16/Sparco-RTT-preview.png",
					"16/Sparco-Terra-preview.png"
				],
				"area": "rim/16.json",
				"set": true
			},
			"caliper": {
				"choices": [
					"16/caliper.json"
				],
				"material": "steel",
				"set": true,
				"previews": false
			}
		},
		"17": {
			"tyre": {
				"choices": [
					"17/tyre17.json"
				],
				"area": "tyre/tyre17.json",
				"previews": false
			},
			"rim": {
				"choices": [
					"17/AEZ-Cliff.json",
					"17/AEZ-Genua.json",
					"17/AEZ-Raise.json",
					"17/AEZ-Reef.json",
					"17/AEZ-Straight.json",
					"17/AEZ-Valencia.json",
					"17/AEZ-Yacht.json",
					"17/BBS-CS.json",
					"17/BBS-LM.json",
					"17/BBS-SR.json",
					"17/BBS-SX.json",
					"17/MSW-11.json",
					"17/MSW-14.json",
					"17/MSW-19.json",
					"17/MSW-20-4.json",
					"17/MSW-20-5.json",
					"17/MSW-22.json",
					"17/MSW-23.json",
					"17/MSW-24.json",
					"17/MSW-25.json",
					"17/MSW-26.json",
					"17/MSW-27.json",
					"17/MSW-45.json",
					"17/MSW-46.json",
					"17/MSW-47.json",
					"17/MSW-55.json",
					"17/MSW-77.json",
					"17/MSW-85.json",
					"17/MSW-86.json",
					"17/MSW-Crossover.json",
					"17/Sparco-Assettogara.json",
					"17/Sparco-Drift.json",
					"17/Sparco-Pista.json",
					"17/Sparco-Pro-Corsa.json",
					"17/Sparco-RTT.json",
					"17/Sparco-Tarmac.json",
					"17/Sparco-Terra.json"
				],
				"color": "#ffffff",
				"material": "steel",
				"materials": [
					"discolor",
					"electroplate",
					"matte"
				],
				"previews": [
					"17/AEZ-Cliff-preview.png",
					"17/AEZ-Genua-preview.png",
					"17/AEZ-Raise-preview.png",
					"17/AEZ-Reef-preview.png",
					"17/AEZ-Straight-preview.png",
					"17/AEZ-Valencia-preview.png",
					"17/AEZ-Yacht-preview.png",
					"17/BBS-CS-preview.png",
					"17/BBS-LM-preview.png",
					"17/BBS-SR-preview.png",
					"17/BBS-SX-preview.png",
					"17/MSW-11-preview.png",
					"17/MSW-14-preview.png",
					"17/MSW-19-preview.png",
					"17/MSW-20-4-preview.png",
					"17/MSW-20-5-preview.png",
					"17/MSW-22-preview.png",
					"17/MSW-23-preview.png",
					"17/MSW-24-preview.png",
					"17/MSW-25-preview.png",
					"17/MSW-26-preview.png",
					"17/MSW-27-preview.png",
					"17/MSW-45-preview.png",
					"17/MSW-46-preview.png",
					"17/MSW-47-preview.png",
					"17/MSW-55-preview.png",
					"17/MSW-77-preview.png",
					"17/MSW-85-preview.png",
					"17/MSW-86-preview.png",
					"17/MSW-Crossover-preview.png",
					"17/Sparco-Assettogara-preview.png",
					"17/Sparco-Drift-preview.png",
					"17/Sparco-Pista-preview.png",
					"17/Sparco-Pro-Corsa-preview.png",
					"17/Sparco-RTT-preview.png",
					"17/Sparco-Tarmac-preview.png",
					"17/Sparco-Terra-preview.png"
				],
				"area": "rim/17.json",
				"set": true
			},
			"caliper": {
				"choices": [
					"17/caliper.json"
				],
				"material": "steel",
				"set": true,
				"previews": false
			}
		},
		"18": {
			"tyre": {
				"choices": [
					"18/tyre18.json"
				],
				"area": "tyre/tyre18.json",
				"previews": false
			},
			"rim": {
				"choices": [
					"18/AEZ-Antigua.json",
					"18/AEZ-Cliff.json",
					"18/AEZ-Genua.json",
					"18/AEZ-Raise.json",
					"18/AEZ-Reef.json",
					"18/AEZ-Straight.json",
					"18/AEZ-Strike.json",
					"18/AEZ-Valencia.json",
					"18/AEZ-Yacht.json",
					"18/BBS-CH-R.json",
					"18/BBS-CS.json",
					"18/BBS-LM.json",
					"18/BBS-SR.json",
					"18/BBS-SX.json",
					"18/BBS-XA.json",
					"18/MSW-11.json",
					"18/MSW-14.json",
					"18/MSW-19.json",
					"18/MSW-20-5.json",
					"18/MSW-23.json",
					"18/MSW-24.json",
					"18/MSW-25.json",
					"18/MSW-26.json",
					"18/MSW-27.json",
					"18/MSW-45.json",
					"18/MSW-47.json",
					"18/MSW-55.json",
					"18/MSW-86.json",
					"18/MSW-Crossover.json",
					"18/Sparco-Assettogara.json",
					"18/Sparco-Pista.json",
					"18/Sparco-Pro-Corsa.json",
					"18/Sparco-RTT.json",
					"18/Sparco-Tarmac.json",
					"18/Sparco-Terra.json"
				],
				"color": "#ffffff",
				"material": "steel",
				"materials": [
					"discolor",
					"electroplate",
					"matte"
				],
				"previews": [
					"18/AEZ-Antigua-preview.png",
					"18/AEZ-Cliff-preview.png",
					"18/AEZ-Genua-preview.png",
					"18/AEZ-Raise-preview.png",
					"18/AEZ-Reef-preview.png",
					"18/AEZ-Straight-preview.png",
					"18/AEZ-Strike-preview.png",
					"18/AEZ-Valencia-preview.png",
					"18/AEZ-Yacht-preview.png",
					"18/BBS-CH-R-preview.png",
					"18/BBS-CS-preview.png",
					"18/BBS-LM-preview.png",
					"18/BBS-SR-preview.png",
					"18/BBS-SX-preview.png",
					"18/BBS-XA-preview.png",
					"18/MSW-11-preview.png",
					"18/MSW-14-preview.png",
					"18/MSW-19-preview.png",
					"18/MSW-20-5-preview.png",
					"18/MSW-23-preview.png",
					"18/MSW-24-preview.png",
					"18/MSW-25-preview.png",
					"18/MSW-26-preview.png",
					"18/MSW-27-preview.png",
					"18/MSW-45-preview.png",
					"18/MSW-47-preview.png",
					"18/MSW-55-preview.png",
					"18/MSW-86-preview.png",
					"18/MSW-Crossover-preview.png",
					"18/Sparco-Assettogara-preview.png",
					"18/Sparco-Pista-preview.png",
					"18/Sparco-Pro-Corsa-preview.png",
					"18/Sparco-RTT-preview.png",
					"18/Sparco-Tarmac-preview.png",
					"18/Sparco-Terra-preview.png"
				],
				"area": "rim/18.json",
				"set": true
			},
			"caliper": {
				"choices": [
					"18/caliper.json"
				],
				"material": "steel",
				"set": true,
				"previews": false
			}
		},
		"19": {
			"tyre": {
				"choices": [
					"19/tyre19.json"
				],
				"area": "tyre/tyre19.json",
				"previews": false
			},
			"rim": {
				"choices": [
					"19/AEZ-Antigua.json",
					"19/AEZ-Cliff.json",
					"19/AEZ-Genua.json",
					"19/AEZ-Raise.json",
					"19/AEZ-Reef.json",
					"19/AEZ-Straight.json",
					"19/AEZ-Strike.json",
					"19/AEZ-Sydney.json",
					"19/AEZ-Valencia.json",
					"19/AEZ-Yacht.json",
					"19/Antera-501.json",
					"19/Antera-505.json",
					"19/Antera-509.json",
					"19/BBS-CH-R.json",
					"19/BBS-CS.json",
					"19/BBS-CX-R.json",
					"19/BBS-FI.json",
					"19/BBS-LM.json",
					"19/BBS-RX.json",
					"19/BBS-SR.json",
					"19/BBS-Super-RS.json",
					"19/BBS-SV.json",
					"19/BBS-SX.json",
					"19/BBS-XA.json",
					"19/MSW-20-5.json",
					"19/MSW-24.json",
					"19/MSW-25.json",
					"19/MSW-26.json",
					"19/MSW-47.json",
					"19/MSW-55.json",
					"19/MSW-Crossover.json"
				],
				"color": "#ffffff",
				"material": "steel",
				"materials": [
					"discolor",
					"electroplate",
					"matte"
				],
				"previews": [
					"19/AEZ-Antigua-preview.png",
					"19/AEZ-Cliff-preview.png",
					"19/AEZ-Genua-preview.png",
					"19/AEZ-Raise-preview.png",
					"19/AEZ-Reef-preview.png",
					"19/AEZ-Straight-preview.png",
					"19/AEZ-Strike-preview.png",
					"19/AEZ-Sydney-preview.png",
					"19/AEZ-Valencia-preview.png",
					"19/AEZ-Yacht-preview.png",
					"19/Antera-501-preview.png",
					"19/Antera-505-preview.png",
					"19/Antera-509-preview.png",
					"19/BBS-CH-R-preview.png",
					"19/BBS-CS-preview.png",
					"19/BBS-CX-R-preview.png",
					"19/BBS-FI-preview.png",
					"19/BBS-LM-preview.png",
					"19/BBS-RX-preview.png",
					"19/BBS-SR-preview.png",
					"19/BBS-Super-RS-preview.png",
					"19/BBS-SV-preview.png",
					"19/BBS-SX-preview.png",
					"19/BBS-XA-preview.png",
					"19/MSW-20-5-preview.png",
					"19/MSW-24-preview.png",
					"19/MSW-25-preview.png",
					"19/MSW-26-preview.png",
					"19/MSW-47-preview.png",
					"19/MSW-55-preview.png",
					"19/MSW-Crossover-preview.png"
				],
				"area": "rim/19.json",
				"set": true
			},
			"caliper": {
				"choices": [
					"19/caliper.json"
				],
				"material": "steel",
				"set": true,
				"previews": false
			}
		},
		"20": {
			"tyre": {
				"choices": [
					"20/tyre20.json"
				],
				"area": "tyre/tyre20.json",
				"previews": false
			},
			"rim": {
				"choices": [
					"20/AEZ-Antigua.json",
					"20/AEZ-Cliff.json",
					"20/AEZ-Reef.json",
					"20/AEZ-Straight.json",
					"20/AEZ-Strike.json",
					"20/AEZ-Yacht.json",
					"20/Antera-365.json",
					"20/Antera-389.json",
					"20/Antera-503.json",
					"20/BBS-CH-R.json",
					"20/BBS-CI-R.json",
					"20/BBS-CX-R.json",
					"20/BBS-FI.json",
					"20/BBS-LM.json",
					"20/BBS-RX.json",
					"20/BBS-Super-RS.json",
					"20/BBS-SV.json",
					"20/BBS-XA.json"
				],
				"color": "#ffffff",
				"material": "steel",
				"materials": [
					"discolor",
					"electroplate",
					"matte"
				],
				"previews": [
					"20/AEZ-Antigua-preview.png",
					"20/AEZ-Cliff-preview.png",
					"20/AEZ-Reef-preview.png",
					"20/AEZ-Straight-preview.png",
					"20/AEZ-Strike-preview.png",
					"20/AEZ-Yacht-preview.png",
					"20/Antera-365-preview.png",
					"20/Antera-389-preview.png",
					"20/Antera-503-preview.png",
					"20/BBS-CH-R-preview.png",
					"20/BBS-CI-R-preview.png",
					"20/BBS-CX-R-preview.png",
					"20/BBS-FI-preview.png",
					"20/BBS-LM-preview.png",
					"20/BBS-RX-preview.png",
					"20/BBS-Super-RS-preview.png",
					"20/BBS-SV-preview.png",
					"20/BBS-XA-preview.png"
				],
				"area": "rim/20.json",
				"set": true
			},
			"caliper": {
				"choices": [
					"20/caliper.json"
				],
				"material": "steel",
				"set": true,
				"previews": false
			}
		},
		"21": {
			"tyre": {
				"choices": [
					"21/tyre21.json"
				],
				"area": "tyre/tyre21.json",
				"previews": false
			},
			"rim": {
				"choices": [
					"21/Antera-389.json",
					"21/Antra-509.json",
					"21/BBS-CH-R.json",
					"21/BBS-SV.json"
				],
				"color": "#ffffff",
				"material": "steel",
				"materials": [
					"discolor",
					"electroplate",
					"matte"
				],
				"previews": [
					"21/Antera-389-preview.png",
					"21/Antra-509-preview.png",
					"21/BBS-CH-R-preview.png",
					"21/BBS-SV-preview.png"
				],
				"area": "rim/21.json",
				"set": true
			},
			"caliper": {
				"choices": [
					"21/caliper.json"
				],
				"material": "steel",
				"set": true,
				"previews": false
			}
		},
		"22": {
			"tyre": {
				"choices": [
					"22/tyre22.json"
				],
				"area": "tyre/tyre22.json",
				"previews": false
			},
			"rim": {
				"choices": [
					"22/Antera-389.json",
					"22/BBS-SV.json"
				],
				"color": "#ffffff",
				"material": "steel",
				"materials": [
					"discolor",
					"electroplate",
					"matte"
				],
				"previews": [
					"22/Antera-389-preview.png",
					"22/BBS-SV-preview.png"
				],
				"area": "rim/22.json",
				"set": true
			},
			"caliper": {
				"choices": [
					"22/caliper.json"
				],
				"material": "steel",
				"set": true,
				"previews": false
			}
		}
	};

/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = {
		"a3": {
			"wheels": [
				"736.422",
				"-1329.582",
				"331.817"
			]
		},
		"a4": {
			"wheels": [
				"730.418",
				"-1394.082",
				"336.3"
			]
		},
		"a5": {
			"wheels": [
				"816.873",
				"-1460.528",
				"350.249"
			]
		},
		"atenza": {
			"wheels": [
				"738.38",
				"-1431.059",
				"338.748"
			]
		},
		"ats": {
			"wheels": [
				"776.263",
				"-1432.452",
				"327.842"
			]
		},
		"beetle": {
			"wheels": [
				"766.508",
				"-1275.625",
				"356.254"
			]
		},
		"bmw3": {
			"wheels": [
				"775.12",
				"-1418.705",
				"327.243"
			]
		},
		"bmw5": {
			"wheels": [
				"831.989",
				"-1532.815",
				"342.989"
			]
		},
		"c": {
			"wheels": [
				"756.639",
				"-1400.461",
				"343.894"
			]
		},
		"camry": {
			"wheels": [
				"774.496",
				"-1388.851",
				"348.419"
			]
		},
		"cayenne": {
			"wheels": [
				"734",
				"-1324",
				"345.915"
			]
		},
		"cayenne2015": {
			"wheels": [
				"732",
				"-1350",
				"357.73"
			]
		},
		"cc": {
			"wheels": [
				"808.478",
				"-1420.004",
				"345.549"
			]
		},
		"civic": {
			"wheels": [
				"742.424",
				"-1332.752",
				"321.69"
			]
		},
		"cla": {
			"wheels": [
				"746.536",
				"-1354.614",
				"350.734"
			]
		},
		"cooper": {
			"wheels": [
				"673.694",
				"-1256.061",
				"305.805"
			]
		},
		"countryman": {
			"wheels": [
				"747.614",
				"-1329.641",
				"345.13"
			]
		},
		"coupe": {
			"wheels": [
				"773.216",
				"-1403.756",
				"327.123"
			]
		},
		"cruze": {
			"wheels": [
				"752",
				"-1330",
				"324.45"
			]
		},
		"ct": {
			"wheels": [
				"770.334",
				"-1326.263",
				"345.806"
			]
		},
		"cts": {
			"wheels": [
				"753",
				"-1416",
				"337.305"
			]
		},
		"e": {
			"wheels": [
				"759.196",
				"-1494.826",
				"347.319"
			]
		},
		"evoque": {
			"wheels": [
				"800.417",
				"-1344.44",
				"378.645"
			]
		},
		"focus": {
			"wheels": [
				"758.956",
				"-1317.675",
				"324.804"
			]
		},
		"ghibili": {
			"wheels": [
				"822.03",
				"-1509.246",
				"359.798"
			]
		},
		"golf": {
			"wheels": [
				"746",
				"-1332",
				"337.611"
			]
		},
		"gtr": {
			"wheels": [
				"815",
				"-1392",
				"356.141"
			]
		},
		"is": {
			"wheels": [
				"798.636",
				"-1411.637",
				"324.534"
			]
		},
		"k5": {
			"wheels": [
				"843.593",
				"-1465.63",
				"345.7"
			]
		},
		"lancer": {
			"wheels": [
				"785",
				"-1345",
				"336.065"
			]
		},
		"macan": {
			"wheels": [
				"772.291",
				"-1381.97",
				"352.19"
			]
		},
		"malibu": {
			"wheels": [
				"805.755",
				"-1394.667",
				"336.344"
			]
		},
		"mazda6": {
			"wheels": [
				"757.196",
				"-1322.401",
				"322.851"
			]
		},
		"mondeo": {
			"wheels": [
				"775",
				"-1450",
				"339.677"
			]
		},
		"panamera": {
			"wheels": [
				"802.701",
				"-1502.501",
				"343.811"
			]
		},
		"q50l": {
			"wheels": [
				"782.863",
				"-1431.933",
				"333.964"
			]
		},
		"regal": {
			"wheels": [
				"799.26",
				"-1381.623",
				"371.313"
			]
		},
		"reiz": {
			"wheels": [
				"811.963",
				"-1476.461",
				"339.088"
			]
		},
		"scirocco": {
			"wheels": [
				"764.973",
				"-1291.385",
				"333.317"
			]
		},
		"smart": {
			"wheels": [
				"725",
				"-980",
				"294.163"
			]
		},
		"sonata": {
			"wheels": [
				"792.394",
				"-1410.482",
				"340.437"
			]
		},
		"spirior": {
			"wheels": [
				"780",
				"-1390.44",
				"339.934"
			]
		},
		"tt": {
			"wheels": [
				"793.971",
				"-1230.739",
				"326.777"
			]
		},
		"xf": {
			"wheels": [
				"781.164",
				"-1496.983",
				"358.453"
			]
		},
		"xj": {
			"wheels": [
				"780",
				"-1433",
				"341.308"
			]
		}
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var THREE = window.THREE = __webpack_require__(26);
	__webpack_require__(31);

	var renderer = module.exports = new THREE.WebGLRenderer({
	  canvas: document.querySelector('#render'),
	  antialias: true
	});
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.soft = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;

	var setSize = function setSize() {
	  renderer.setSize(window.innerWidth, window.innerHeight);
	};
	window.addEventListener('resize', setSize);
	setSize();

	// const stats = require('./stats')
	var controller = __webpack_require__(37);
	var camera = __webpack_require__(44);
	var raycast = __webpack_require__(45);
	var scene = window.scene = __webpack_require__(52);

	var render = function render() {
	  // stats.begin()
	  controller.update();
	  raycast();
	  renderer.render(scene, camera);
	  // stats.end()
	  window.requestAnimationFrame(render);
	};
	window.requestAnimationFrame(render);

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _defineProperties = __webpack_require__(32);

	var _defineProperties2 = _interopRequireDefault(_defineProperties);

	var _create = __webpack_require__(35);

	var _create2 = _interopRequireDefault(_create);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * @author qiao / https://github.com/qiao
	 * @author mrdoob / http://mrdoob.com
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author erich666 / http://erichaines.com
	 */

	// jscs: disable

	var THREE = __webpack_require__(26);

	(function () {

	  function OrbitConstraint(object) {

	    this.object = object;

	    // "target" sets the location of focus, where the object orbits around
	    // and where it pans with respect to.
	    this.target = new THREE.Vector3();

	    // Limits to how far you can dolly in and out ( PerspectiveCamera only )
	    this.minDistance = 0;
	    this.maxDistance = Infinity;

	    // Limits to how far you can zoom in and out ( OrthographicCamera only )
	    this.minZoom = 0;
	    this.maxZoom = Infinity;

	    // How far you can orbit vertically, upper and lower limits.
	    // Range is 0 to Math.PI radians.
	    this.minPolarAngle = 0; // radians
	    this.maxPolarAngle = Math.PI; // radians

	    // How far you can orbit horizontally, upper and lower limits.
	    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	    this.minAzimuthAngle = -Infinity; // radians
	    this.maxAzimuthAngle = Infinity; // radians

	    // Set to true to enable damping (inertia)
	    // If damping is enabled, you must call controls.update() in your animation loop
	    this.enableDamping = false;
	    this.dampingFactor = 0.25;

	    ////////////
	    // internals

	    var scope = this;

	    var EPS = 0.000001;

	    // Current position in spherical coordinate system.
	    var theta;
	    var phi;

	    // Pending changes
	    var phiDelta = 0;
	    var thetaDelta = 0;
	    var scale = 1;
	    var panOffset = new THREE.Vector3();
	    var zoomChanged = false;

	    // API

	    this.getPolarAngle = function () {

	      return phi;
	    };

	    this.getAzimuthalAngle = function () {

	      return theta;
	    };

	    this.rotateLeft = function (angle) {

	      thetaDelta -= angle;
	    };

	    this.rotateUp = function (angle) {

	      phiDelta -= angle;
	    };

	    // pass in distance in world space to move left
	    this.panLeft = (function () {

	      var v = new THREE.Vector3();

	      return function panLeft(distance) {

	        var te = this.object.matrix.elements;

	        // get X column of matrix
	        v.set(te[0], te[1], te[2]);
	        v.multiplyScalar(-distance);

	        panOffset.add(v);
	      };
	    })();

	    // pass in distance in world space to move up
	    this.panUp = (function () {

	      var v = new THREE.Vector3();

	      return function panUp(distance) {

	        var te = this.object.matrix.elements;

	        // get Y column of matrix
	        v.set(te[4], te[5], te[6]);
	        v.multiplyScalar(distance);

	        panOffset.add(v);
	      };
	    })();

	    // pass in x,y of change desired in pixel space,
	    // right and down are positive
	    this.pan = function (deltaX, deltaY, screenWidth, screenHeight) {

	      if (scope.object instanceof THREE.PerspectiveCamera) {

	        // perspective
	        var position = scope.object.position;
	        var offset = position.clone().sub(scope.target);
	        var targetDistance = offset.length();

	        // half of the fov is center to top of screen
	        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);

	        // we actually don't use screenWidth, since perspective camera is fixed to screen height
	        scope.panLeft(2 * deltaX * targetDistance / screenHeight);
	        scope.panUp(2 * deltaY * targetDistance / screenHeight);
	      } else if (scope.object instanceof THREE.OrthographicCamera) {

	        // orthographic
	        scope.panLeft(deltaX * (scope.object.right - scope.object.left) / screenWidth);
	        scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / screenHeight);
	      } else {

	        // camera neither orthographic or perspective
	        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
	      }
	    };

	    this.dollyIn = function (dollyScale) {

	      if (scope.object instanceof THREE.PerspectiveCamera) {

	        scale /= dollyScale;
	      } else if (scope.object instanceof THREE.OrthographicCamera) {

	        scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale));
	        scope.object.updateProjectionMatrix();
	        zoomChanged = true;
	      } else {

	        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
	      }
	    };

	    this.dollyOut = function (dollyScale) {

	      if (scope.object instanceof THREE.PerspectiveCamera) {

	        scale *= dollyScale;
	      } else if (scope.object instanceof THREE.OrthographicCamera) {

	        scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale));
	        scope.object.updateProjectionMatrix();
	        zoomChanged = true;
	      } else {

	        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
	      }
	    };

	    this.update = (function () {

	      var offset = new THREE.Vector3();

	      // so camera.up is the orbit axis
	      var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
	      var quatInverse = quat.clone().inverse();

	      var lastPosition = new THREE.Vector3();
	      var lastQuaternion = new THREE.Quaternion();

	      return function () {

	        var position = this.object.position;

	        offset.copy(position).sub(this.target);

	        // rotate offset to "y-axis-is-up" space
	        offset.applyQuaternion(quat);

	        // angle from z-axis around y-axis

	        theta = Math.atan2(offset.x, offset.z);

	        // angle from y-axis

	        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);

	        theta += thetaDelta;
	        phi += phiDelta;

	        // restrict theta to be between desired limits
	        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));

	        // restrict phi to be between desired limits
	        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));

	        // restrict phi to be betwee EPS and PI-EPS
	        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));

	        var radius = offset.length() * scale;

	        // restrict radius to be between desired limits
	        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));

	        // move target to panned location
	        this.target.add(panOffset);

	        offset.x = radius * Math.sin(phi) * Math.sin(theta);
	        offset.y = radius * Math.cos(phi);
	        offset.z = radius * Math.sin(phi) * Math.cos(theta);

	        // rotate offset back to "camera-up-vector-is-up" space
	        offset.applyQuaternion(quatInverse);

	        position.copy(this.target).add(offset);

	        this.object.lookAt(this.target);

	        if (this.enableDamping === true) {

	          thetaDelta *= 1 - this.dampingFactor;
	          phiDelta *= 1 - this.dampingFactor;
	        } else {

	          thetaDelta = 0;
	          phiDelta = 0;
	        }

	        scale = 1;
	        panOffset.set(0, 0, 0);

	        // update condition is:
	        // min(camera displacement, camera rotation in radians)^2 > EPS
	        // using small-angle approximation cos(x/2) = 1 - x^2 / 8

	        if (zoomChanged || lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {

	          lastPosition.copy(this.object.position);
	          lastQuaternion.copy(this.object.quaternion);
	          zoomChanged = false;

	          return true;
	        }

	        return false;
	      };
	    })();
	  };

	  // This set of controls performs orbiting, dollying (zooming), and panning. It maintains
	  // the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
	  // supported.
	  //
	  //    Orbit - left mouse / touch: one finger move
	  //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
	  //    Pan - right mouse, or arrow keys / touch: three finter swipe

	  THREE.OrbitControls = function (object, domElement) {

	    var constraint = new OrbitConstraint(object);

	    this.domElement = domElement !== undefined ? domElement : document;

	    // API

	    Object.defineProperty(this, 'constraint', {

	      get: function get() {

	        return constraint;
	      }

	    });

	    this.getPolarAngle = function () {

	      return constraint.getPolarAngle();
	    };

	    this.getAzimuthalAngle = function () {

	      return constraint.getAzimuthalAngle();
	    };

	    // Set to false to disable this control
	    this.enabled = true;

	    // center is old, deprecated; use "target" instead
	    this.center = this.target;

	    // This option actually enables dollying in and out; left as "zoom" for
	    // backwards compatibility.
	    // Set to false to disable zooming
	    this.enableZoom = true;
	    this.zoomSpeed = 1.0;

	    // Set to false to disable rotating
	    this.enableRotate = true;
	    this.rotateSpeed = 1.0;

	    // Set to false to disable panning
	    this.enablePan = true;
	    this.keyPanSpeed = 7.0; // pixels moved per arrow key push

	    // Set to true to automatically rotate around the target
	    // If auto-rotate is enabled, you must call controls.update() in your animation loop
	    this.autoRotate = false;
	    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	    // Set to false to disable use of the keys
	    this.enableKeys = true;

	    // The four arrow keys
	    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

	    // Mouse buttons
	    this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

	    ////////////
	    // internals

	    var scope = this;

	    var rotateStart = new THREE.Vector2();
	    var rotateEnd = new THREE.Vector2();
	    var rotateDelta = new THREE.Vector2();

	    var panStart = new THREE.Vector2();
	    var panEnd = new THREE.Vector2();
	    var panDelta = new THREE.Vector2();

	    var dollyStart = new THREE.Vector2();
	    var dollyEnd = new THREE.Vector2();
	    var dollyDelta = new THREE.Vector2();

	    var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

	    var state = STATE.NONE;

	    // for reset

	    this.target0 = this.target.clone();
	    this.position0 = this.object.position.clone();
	    this.zoom0 = this.object.zoom;

	    // events

	    var changeEvent = { type: 'change' };
	    var startEvent = { type: 'start' };
	    var endEvent = { type: 'end' };

	    // pass in x,y of change desired in pixel space,
	    // right and down are positive
	    function pan(deltaX, deltaY) {

	      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

	      constraint.pan(deltaX, deltaY, element.clientWidth, element.clientHeight);
	    }

	    this.update = function () {

	      if (this.autoRotate && state === STATE.NONE) {

	        constraint.rotateLeft(getAutoRotationAngle());
	      }

	      if (constraint.update() === true) {

	        this.dispatchEvent(changeEvent);
	      }
	    };

	    this.reset = function () {

	      state = STATE.NONE;

	      this.target.copy(this.target0);
	      this.object.position.copy(this.position0);
	      this.object.zoom = this.zoom0;

	      this.object.updateProjectionMatrix();
	      this.dispatchEvent(changeEvent);

	      this.update();
	    };

	    function getAutoRotationAngle() {

	      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
	    }

	    function getZoomScale() {

	      return Math.pow(0.95, scope.zoomSpeed);
	    }

	    function onMouseDown(event) {

	      if (scope.enabled === false) return;

	      event.preventDefault();

	      if (event.button === scope.mouseButtons.ORBIT) {

	        if (scope.enableRotate === false) return;

	        state = STATE.ROTATE;

	        rotateStart.set(event.clientX, event.clientY);
	      } else if (event.button === scope.mouseButtons.ZOOM) {

	        if (scope.enableZoom === false) return;

	        state = STATE.DOLLY;

	        dollyStart.set(event.clientX, event.clientY);
	      } else if (event.button === scope.mouseButtons.PAN) {

	        if (scope.enablePan === false) return;

	        state = STATE.PAN;

	        panStart.set(event.clientX, event.clientY);
	      }

	      if (state !== STATE.NONE) {

	        document.addEventListener('mousemove', onMouseMove, false);
	        document.addEventListener('mouseup', onMouseUp, false);
	        scope.dispatchEvent(startEvent);
	      }
	    }

	    function onMouseMove(event) {

	      if (scope.enabled === false) return;

	      event.preventDefault();

	      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

	      if (state === STATE.ROTATE) {

	        if (scope.enableRotate === false) return;

	        rotateEnd.set(event.clientX, event.clientY);
	        rotateDelta.subVectors(rotateEnd, rotateStart);

	        // rotating across whole screen goes 360 degrees around
	        constraint.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

	        // rotating up and down along whole screen attempts to go 360, but limited to 180
	        constraint.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

	        rotateStart.copy(rotateEnd);
	      } else if (state === STATE.DOLLY) {

	        if (scope.enableZoom === false) return;

	        dollyEnd.set(event.clientX, event.clientY);
	        dollyDelta.subVectors(dollyEnd, dollyStart);

	        if (dollyDelta.y > 0) {

	          constraint.dollyIn(getZoomScale());
	        } else if (dollyDelta.y < 0) {

	          constraint.dollyOut(getZoomScale());
	        }

	        dollyStart.copy(dollyEnd);
	      } else if (state === STATE.PAN) {

	        if (scope.enablePan === false) return;

	        panEnd.set(event.clientX, event.clientY);
	        panDelta.subVectors(panEnd, panStart);

	        pan(panDelta.x, panDelta.y);

	        panStart.copy(panEnd);
	      }

	      if (state !== STATE.NONE) scope.update();
	    }

	    function onMouseUp() /* event */{

	      if (scope.enabled === false) return;

	      document.removeEventListener('mousemove', onMouseMove, false);
	      document.removeEventListener('mouseup', onMouseUp, false);
	      scope.dispatchEvent(endEvent);
	      state = STATE.NONE;
	    }

	    function onMouseWheel(event) {

	      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;

	      event.preventDefault();
	      event.stopPropagation();

	      var delta = 0;

	      if (event.wheelDelta !== undefined) {

	        // WebKit / Opera / Explorer 9

	        delta = event.wheelDelta;
	      } else if (event.detail !== undefined) {

	        // Firefox

	        delta = -event.detail;
	      }

	      if (delta > 0) {

	        constraint.dollyOut(getZoomScale());
	      } else if (delta < 0) {

	        constraint.dollyIn(getZoomScale());
	      }

	      scope.update();
	      scope.dispatchEvent(startEvent);
	      scope.dispatchEvent(endEvent);
	    }

	    function onKeyDown(event) {

	      if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;

	      switch (event.keyCode) {

	        case scope.keys.UP:
	          pan(0, scope.keyPanSpeed);
	          scope.update();
	          break;

	        case scope.keys.BOTTOM:
	          pan(0, -scope.keyPanSpeed);
	          scope.update();
	          break;

	        case scope.keys.LEFT:
	          pan(scope.keyPanSpeed, 0);
	          scope.update();
	          break;

	        case scope.keys.RIGHT:
	          pan(-scope.keyPanSpeed, 0);
	          scope.update();
	          break;

	      }
	    }

	    function touchstart(event) {

	      if (scope.enabled === false) return;

	      switch (event.touches.length) {

	        case 1:
	          // one-fingered touch: rotate

	          if (scope.enableRotate === false) return;

	          state = STATE.TOUCH_ROTATE;

	          rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
	          break;

	        case 2:
	          // two-fingered touch: dolly

	          if (scope.enableZoom === false) return;

	          state = STATE.TOUCH_DOLLY;

	          var dx = event.touches[0].pageX - event.touches[1].pageX;
	          var dy = event.touches[0].pageY - event.touches[1].pageY;
	          var distance = Math.sqrt(dx * dx + dy * dy);
	          dollyStart.set(0, distance);
	          break;

	        case 3:
	          // three-fingered touch: pan

	          if (scope.enablePan === false) return;

	          state = STATE.TOUCH_PAN;

	          panStart.set(event.touches[0].pageX, event.touches[0].pageY);
	          break;

	        default:

	          state = STATE.NONE;

	      }

	      if (state !== STATE.NONE) scope.dispatchEvent(startEvent);
	    }

	    function touchmove(event) {

	      if (scope.enabled === false) return;

	      event.preventDefault();
	      event.stopPropagation();

	      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

	      switch (event.touches.length) {

	        case 1:
	          // one-fingered touch: rotate

	          if (scope.enableRotate === false) return;
	          if (state !== STATE.TOUCH_ROTATE) return;

	          rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
	          rotateDelta.subVectors(rotateEnd, rotateStart);

	          // rotating across whole screen goes 360 degrees around
	          constraint.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
	          // rotating up and down along whole screen attempts to go 360, but limited to 180
	          constraint.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

	          rotateStart.copy(rotateEnd);

	          scope.update();
	          break;

	        case 2:
	          // two-fingered touch: dolly

	          if (scope.enableZoom === false) return;
	          if (state !== STATE.TOUCH_DOLLY) return;

	          var dx = event.touches[0].pageX - event.touches[1].pageX;
	          var dy = event.touches[0].pageY - event.touches[1].pageY;
	          var distance = Math.sqrt(dx * dx + dy * dy);

	          dollyEnd.set(0, distance);
	          dollyDelta.subVectors(dollyEnd, dollyStart);

	          if (dollyDelta.y > 0) {

	            constraint.dollyOut(getZoomScale());
	          } else if (dollyDelta.y < 0) {

	            constraint.dollyIn(getZoomScale());
	          }

	          dollyStart.copy(dollyEnd);

	          scope.update();
	          break;

	        case 3:
	          // three-fingered touch: pan

	          if (scope.enablePan === false) return;
	          if (state !== STATE.TOUCH_PAN) return;

	          panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
	          panDelta.subVectors(panEnd, panStart);

	          pan(panDelta.x, panDelta.y);

	          panStart.copy(panEnd);

	          scope.update();
	          break;

	        default:

	          state = STATE.NONE;

	      }
	    }

	    function touchend() /* event */{

	      if (scope.enabled === false) return;

	      scope.dispatchEvent(endEvent);
	      state = STATE.NONE;
	    }

	    function contextmenu(event) {

	      event.preventDefault();
	    }

	    this.dispose = function () {

	      this.domElement.removeEventListener('contextmenu', contextmenu, false);
	      this.domElement.removeEventListener('mousedown', onMouseDown, false);
	      this.domElement.removeEventListener('mousewheel', onMouseWheel, false);
	      this.domElement.removeEventListener('DOMMouseScroll', onMouseWheel, false); // firefox

	      this.domElement.removeEventListener('touchstart', touchstart, false);
	      this.domElement.removeEventListener('touchend', touchend, false);
	      this.domElement.removeEventListener('touchmove', touchmove, false);

	      document.removeEventListener('mousemove', onMouseMove, false);
	      document.removeEventListener('mouseup', onMouseUp, false);

	      window.removeEventListener('keydown', onKeyDown, false);
	    };

	    this.domElement.addEventListener('contextmenu', contextmenu, false);

	    this.domElement.addEventListener('mousedown', onMouseDown, false);
	    this.domElement.addEventListener('mousewheel', onMouseWheel, false);
	    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox

	    this.domElement.addEventListener('touchstart', touchstart, false);
	    this.domElement.addEventListener('touchend', touchend, false);
	    this.domElement.addEventListener('touchmove', touchmove, false);

	    window.addEventListener('keydown', onKeyDown, false);

	    // force an update at start
	    this.update();
	  };

	  THREE.OrbitControls.prototype = (0, _create2.default)(THREE.EventDispatcher.prototype);
	  THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

	  (0, _defineProperties2.default)(THREE.OrbitControls.prototype, {

	    object: {

	      get: function get() {

	        return this.constraint.object;
	      }

	    },

	    target: {

	      get: function get() {

	        return this.constraint.target;
	      },

	      set: function set(value) {

	        console.warn('THREE.OrbitControls: target is now immutable. Use target.set() instead.');
	        this.constraint.target.copy(value);
	      }

	    },

	    minDistance: {

	      get: function get() {

	        return this.constraint.minDistance;
	      },

	      set: function set(value) {

	        this.constraint.minDistance = value;
	      }

	    },

	    maxDistance: {

	      get: function get() {

	        return this.constraint.maxDistance;
	      },

	      set: function set(value) {

	        this.constraint.maxDistance = value;
	      }

	    },

	    minZoom: {

	      get: function get() {

	        return this.constraint.minZoom;
	      },

	      set: function set(value) {

	        this.constraint.minZoom = value;
	      }

	    },

	    maxZoom: {

	      get: function get() {

	        return this.constraint.maxZoom;
	      },

	      set: function set(value) {

	        this.constraint.maxZoom = value;
	      }

	    },

	    minPolarAngle: {

	      get: function get() {

	        return this.constraint.minPolarAngle;
	      },

	      set: function set(value) {

	        this.constraint.minPolarAngle = value;
	      }

	    },

	    maxPolarAngle: {

	      get: function get() {

	        return this.constraint.maxPolarAngle;
	      },

	      set: function set(value) {

	        this.constraint.maxPolarAngle = value;
	      }

	    },

	    minAzimuthAngle: {

	      get: function get() {

	        return this.constraint.minAzimuthAngle;
	      },

	      set: function set(value) {

	        this.constraint.minAzimuthAngle = value;
	      }

	    },

	    maxAzimuthAngle: {

	      get: function get() {

	        return this.constraint.maxAzimuthAngle;
	      },

	      set: function set(value) {

	        this.constraint.maxAzimuthAngle = value;
	      }

	    },

	    enableDamping: {

	      get: function get() {

	        return this.constraint.enableDamping;
	      },

	      set: function set(value) {

	        this.constraint.enableDamping = value;
	      }

	    },

	    dampingFactor: {

	      get: function get() {

	        return this.constraint.dampingFactor;
	      },

	      set: function set(value) {

	        this.constraint.dampingFactor = value;
	      }

	    },

	    // backward compatibility

	    noZoom: {

	      get: function get() {

	        console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
	        return !this.enableZoom;
	      },

	      set: function set(value) {

	        console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
	        this.enableZoom = !value;
	      }

	    },

	    noRotate: {

	      get: function get() {

	        console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
	        return !this.enableRotate;
	      },

	      set: function set(value) {

	        console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
	        this.enableRotate = !value;
	      }

	    },

	    noPan: {

	      get: function get() {

	        console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
	        return !this.enablePan;
	      },

	      set: function set(value) {

	        console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
	        this.enablePan = !value;
	      }

	    },

	    noKeys: {

	      get: function get() {

	        console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
	        return !this.enableKeys;
	      },

	      set: function set(value) {

	        console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
	        this.enableKeys = !value;
	      }

	    },

	    staticMoving: {

	      get: function get() {

	        console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
	        return !this.constraint.enableDamping;
	      },

	      set: function set(value) {

	        console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
	        this.constraint.enableDamping = !value;
	      }

	    },

	    dynamicDampingFactor: {

	      get: function get() {

	        console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
	        return this.constraint.dampingFactor;
	      },

	      set: function set(value) {

	        console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
	        this.constraint.dampingFactor = value;
	      }

	    }

	  });
	})();

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(33), __esModule: true };

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(34);
	module.exports = function defineProperties(T, D){
	  return $.setDescs(T, D);
	};

/***/ },
/* 34 */
/***/ function(module, exports) {

	var $Object = Object;
	module.exports = {
	  create:     $Object.create,
	  getProto:   $Object.getPrototypeOf,
	  isEnum:     {}.propertyIsEnumerable,
	  getDesc:    $Object.getOwnPropertyDescriptor,
	  setDesc:    $Object.defineProperty,
	  setDescs:   $Object.defineProperties,
	  getKeys:    $Object.keys,
	  getNames:   $Object.getOwnPropertyNames,
	  getSymbols: $Object.getOwnPropertySymbols,
	  each:       [].forEach
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(36), __esModule: true };

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(34);
	module.exports = function create(P, D){
	  return $.create(P, D);
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _assign = __webpack_require__(38);

	var _assign2 = _interopRequireDefault(_assign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var THREE = __webpack_require__(26);

	var camera = __webpack_require__(44);
	var store = __webpack_require__(13);
	var raycast = __webpack_require__(45);
	var controls = module.exports = new THREE.OrbitControls(camera);
	var bgmusic = document.querySelector('audio');

	(0, _assign2.default)(controls, {
	  maxDistance: 7000,
	  minDistance: 4000,

	  enableDamping: true,
	  dampingFactor: 0.2,

	  rotateSpeed: 0.2,
	  autoRotateSpeed: -0.3,

	  // enablePan: false,
	  enableKeys: false,

	  minPolarAngle: Math.PI / 180 * 50,
	  maxPolarAngle: Math.PI / 180 * 80
	});

	controls.target.set(0, 200, 0);

	store.$watch('rotation', function (value) {
	  return controls.autoRotate = value;
	}, { immediate: true });

	store.$watch('music', function (value) {
	  return value ? bgmusic.play() : bgmusic.pause();
	}, { immediate: true });

	document.addEventListener('mousemove', function (event) {
	  raycast.mouse.x = event.clientX / window.innerWidth * 2 - 1;
	  raycast.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
	});

	document.addEventListener('click', function () {
	  if (store.hoverEnabled) {
	    store.currentPartName = store.hoverPartName;
	  }
	});

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(39), __esModule: true };

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(40);
	module.exports = __webpack_require__(22).Object.assign;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(20);

	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(41)});

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.1 Object.assign(target, source, ...)
	var $        = __webpack_require__(34)
	  , toObject = __webpack_require__(17)
	  , IObject  = __webpack_require__(42);

	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = __webpack_require__(25)(function(){
	  var a = Object.assign
	    , A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , $$    = arguments
	    , $$len = $$.length
	    , index = 1
	    , getKeys    = $.getKeys
	    , getSymbols = $.getSymbols
	    , isEnum     = $.isEnum;
	  while($$len > index){
	    var S      = IObject($$[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  }
	  return T;
	} : Object.assign;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(43);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var THREE = __webpack_require__(26);

	var camera = module.exports = new THREE.PerspectiveCamera(45, // Field of view
	window.innerWidth / window.innerHeight, 1, 1e6);

	camera.position.set(0, 1000, 10000);

	window.addEventListener('resize', function () {
	  camera.aspect = window.innerWidth / window.innerHeight;
	  camera.updateProjectionMatrix();
	});

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var THREE = __webpack_require__(26);
	var camera = __webpack_require__(44);
	var area = __webpack_require__(46);
	var store = __webpack_require__(13);
	var raycaster = new THREE.Raycaster();

	var hoverPartName = store.hoverPartName;

	module.exports = function () {
	  if (!store.hoverEnabled) {
	    store.hoverPartName = '';
	    return;
	  }
	  raycaster.setFromCamera(mouse, camera);
	  var nearest = raycaster.intersectObject(area, true)[0];
	  var targetHoverPartName = nearest != null ? nearest.object.name : '';
	  if (hoverPartName !== targetHoverPartName) {
	    store.hoverPartName = hoverPartName = targetHoverPartName;
	  }
	};

	var mouse = module.exports.mouse = new THREE.Vector2();

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var THREE = __webpack_require__(26);

	var chassis = __webpack_require__(47);
	var wheels = __webpack_require__(51);

	var area = module.exports = window.area = new THREE.Object3D();
	area.position.y = 200;
	area.rotation.y = Math.PI * 45 / 180;

	area.add(chassis, wheels);

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var THREE = __webpack_require__(26);
	var store = __webpack_require__(13);

	var chassis = module.exports = new THREE.Object3D();

	var utils = __webpack_require__(48);

	store.$watch('chassis.parts', function (parts) {
	  // Dispose all mesh
	  for (var mesh = chassis.children[0]; mesh != null; mesh = chassis.children[0]) {
	    utils.dispose(mesh);
	    chassis.remove(mesh);
	  }

	  for (var name in parts) {
	    var part = parts[name];
	    if (part.area && part.set) {
	      var mesh = new THREE.Mesh();
	      mesh.name = name;
	      mesh.material.visible = false;
	      chassis.add(mesh);

	      utils.load(mesh, 'chassis/' + part.area, false);
	    }
	  }
	}, { immediate: true });

	store.$watch('chassis.offsetY', function (offsetY) {
	  return chassis.position.y = offsetY;
	}, { immediate: true });

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _assign = __webpack_require__(38);

	var _assign2 = _interopRequireDefault(_assign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Vue = __webpack_require__(12);
	var THREE = __webpack_require__(26);

	var reflection = __webpack_require__(49);
	var materials = __webpack_require__(50);

	var loader = new THREE.JSONLoader();

	var toTHREEColorObject = function toTHREEColorObject(color) {
	  return new THREE.Color('hsl(' + color.h + ', ' + color.s + ', ' + color.l + ')');
	};

	var getPureMaterial = function getPureMaterial(mesh) {
	  var materials = mesh.material.materials;

	  if (materials == null) {
	    return null;
	  }

	  for (var i = 0, l = materials.length; i < l; i++) {
	    var material = materials[i];
	    if (material.map == null) {
	      return material;
	    }
	  }

	  return null;
	};

	var load = exports.load = function (mesh, file, includeMaterial, callback) {
	  var apply = function apply(geometry, material) {
	    (0, _assign2.default)(mesh, includeMaterial ? { geometry: geometry, material: material } : { geometry: geometry });

	    if (typeof callback === 'function') {
	      callback();
	    }
	  };

	  if (file !== '') {
	    loader.load(file, function (geometry, materials) {
	      materials.forEach(function (material) {
	        material.side = THREE.DoubleSide;
	        if (material.name === 'mirror') {
	          material.envMap = reflection;
	        }
	      });
	      var material = new THREE.MeshFaceMaterial(materials);
	      apply(geometry, material);
	    });
	  } else {
	    // Hide the mesh
	    setTimeout(function () {
	      var material = new THREE.Material();
	      material.visible = false;
	      apply(new THREE.Geometry(), material);
	    }, 0);
	  }
	};

	var dispose = exports.dispose = function (mesh) {
	  var disposeMaterial = function disposeMaterial(material) {
	    if (material.envMap != null) {
	      material.envMap.dispose();
	    }
	    if (material.map != null) {
	      material.map.dispose();
	    }
	    material.dispose();
	  };

	  if (mesh.material != null) {
	    if (mesh.material.materials) {
	      mesh.material.materials.forEach(disposeMaterial);
	    } else {
	      disposeMaterial(mesh.material);
	    }
	  }

	  if (mesh.geometry != null) {
	    mesh.geometry.dispose();
	  }
	};

	exports.initVM = function (mesh, model, prefix) {
	  var autoLoad = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	  return new Vue({
	    // options
	    mesh: mesh,
	    material: null,

	    data: model,
	    watch: {
	      color: {
	        handler: 'setColor',
	        deep: true
	      },
	      specular: {
	        handler: 'setSpecular',
	        deep: true
	      },
	      material: 'setMaterial',
	      choice: 'setChoice'
	    },
	    methods: {
	      setColor: function setColor(color) {
	        var colorObject = toTHREEColorObject(color);
	        var material = this.$options.material;
	        if (material != null) {
	          material.color = colorObject;
	          if (this.material !== 'discolor') {
	            material.specular = colorObject.clone();
	          }
	        }
	      },
	      setSpecular: function setSpecular(color) {
	        var colorObject = toTHREEColorObject(color);
	        var material = this.$options.material;
	        material.specular = colorObject;
	      },
	      setMaterial: function setMaterial(materialStyle, oldMaterialStyle) {

	        var materialFunc = materials[materialStyle];
	        var material = this.$options.material;
	        if (typeof materialFunc === 'function' && material != null) {
	          materialFunc(material);
	          material.needsUpdate = true;
	        }
	        if (materialStyle === 'discolor') {
	          Vue.set(this, 'specular', (0, _assign2.default)({}, this.color));
	        }
	        if (oldMaterialStyle === 'discolor') {
	          Vue.set(this, 'specular', (0, _assign2.default)({}, this.color));
	        }
	      },
	      setChoice: function setChoice(choice) {
	        var _this = this;

	        var mesh = this.$options.mesh;

	        dispose(mesh);
	        this.$options.material = null;

	        load(mesh, choice ? prefix + choice : '', true, function () {
	          _this.$emit('load');
	        });
	      }
	    },
	    events: {
	      load: function load() {
	        this.$options.material = getPureMaterial(mesh);
	        this.setColor(this.color);
	        this.setMaterial(this.material);
	      }
	    },
	    created: function created() {
	      if (autoLoad) {
	        this.setChoice(this.choice);
	      } else {
	        this.$emit('load');
	      }
	    }
	  });
	};

	exports.hover = function (mesh, value) {
	  var color = new THREE.Color(value ? '#666' : '#000');
	  if (mesh != null && mesh.material && mesh.material.materials) {
	    mesh.material.materials.forEach(function (material) {
	      material.emissive = color;
	    });
	  }
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var THREE = __webpack_require__(26);
	var store = __webpack_require__(13);

	var reflections = {};['ground', 'garage', 'lab'].forEach(function (situation) {
	  return reflections[situation] = THREE.ImageUtils.loadTextureCube([situation + '/px.jpg', situation + '/nx.jpg', situation + '/py.jpg', situation + '/ny.jpg', situation + '/pz.jpg', situation + '/nz.jpg']);
	});

	var reflection = module.exports = new THREE.CubeTexture();

	store.$watch('situation', function (value) {
	  reflection.copy(reflections[value]);
	  reflection.needsUpdate = true;
	}, { immediate: true });

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _assign = __webpack_require__(38);

	var _assign2 = _interopRequireDefault(_assign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var THREE = __webpack_require__(26);

	var reflection = __webpack_require__(49);

	var mattingMap = THREE.ImageUtils.loadTexture('bump/matting.jpg', THREE.CubeRefractionMapping);

	mattingMap.wrapS = mattingMap.wrapT = THREE.MirroredRepeatWrapping;
	mattingMap.repeat.set(2, 2);

	var carbonMap = THREE.ImageUtils.loadTexture('bump/carbon.JPG', THREE.CubeRefractionMapping);
	// carbonMap.mapping = THREE.CubeRefractionMapping
	// carbonMap.anisotropy = 4;
	// carbonMap.repeat.set( 10, 10 );
	// carbonMap.offset.set( 0.001, 0.001 );
	// carbonMap.wrapS = carbonMap.wrapT = THREE.RepeatWrapping
	// carbonMap.format = THREE.RGBFormat

	(0, _assign2.default)(exports, {
	  matte: function matte(material) {
	    material.envMap = null;
	    material.bumpMap = null;
	    material.reflectivity = 0;
	    material.needUpdate = true;
	  },
	  normal: function normal(material) {
	    material.envMap = reflection;
	    material.bumpMap = null;
	    material.reflectivity = 0.3;
	  },
	  electroplate: function electroplate(material) {
	    material.envMap = reflection;
	    material.bumpMap = null;
	    material.reflectivity = 0.9;
	  },
	  matting: function matting(material) {
	    material.envMap = reflection;
	    material.bumpMap = mattingMap;
	    material.bumpScale = 100;
	    material.reflectivity = 0.1;
	  },
	  carbon: function carbon(material) {
	    material.envMap = reflection;
	    material.bumpMap = carbonMap;
	    material.bumpScale = 100;
	    material.reflectivity = 0.1;
	  },
	  drawbench: function drawbench(material) {
	    material.envMap = reflection;
	    material.bumpMap = null;
	    material.reflectivity = 0.1;
	  },
	  discolor: function discolor(material) {
	    material.envMap = reflection;
	    material.bumpMap = null;
	    material.reflectivity = 0.3;
	  },
	  steel: function steel(material) {
	    material.envMap = reflection;
	    material.bumpMap = null;
	    material.reflectivity = 0.9;
	  },
	  glass: function glass(material) {
	    material.envMap = reflection;
	    material.bumpMap = null;
	    material.reflectivity = 1;
	  }
	});

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var THREE = __webpack_require__(26);
	var utils = __webpack_require__(48);
	var store = __webpack_require__(13);

	var wheels = module.exports = new THREE.Object3D();

	wheels.add(new THREE.Object3D(), new THREE.Object3D(), new THREE.Object3D(), new THREE.Object3D());

	wheels.children[2].rotation.y = Math.PI;
	wheels.children[3].rotation.y = Math.PI;

	store.$watch('wheels.parts', function (parts) {
	  wheels.children.forEach(function (wheel) {
	    for (var mesh = wheel.children[0]; mesh != null; mesh = wheel.children[0]) {
	      utils.dispose(mesh);
	      wheel.remove(mesh);
	    }
	  });

	  var _loop = function _loop(name) {
	    var part = parts[name];
	    if (part.area) {
	      (function () {
	        var sampleMesh = wheels.children.reduce(function (first, wheel) {
	          var mesh = new THREE.Mesh();
	          mesh.name = name;
	          mesh.material.visible = false;
	          wheel.add(mesh);
	          return first == null ? mesh : first;
	        }, null);

	        utils.load(sampleMesh, 'wheels/' + part.area, false, function () {
	          wheels.children.forEach(function (wheel) {
	            return wheel.getObjectByName(name).geometry = sampleMesh.geometry;
	          });
	        });
	      })();
	    }
	  };

	  for (var name in parts) {
	    _loop(name);
	  }
	}, { immediate: true });

	store.$watch('wheels.offsetX', function (offsetX) {
	  return wheels.children.forEach(function (wheel, index) {
	    wheel.position.x = index < 2 ? offsetX : -offsetX;
	  });
	}, { immediate: true });

	store.$watch('wheels.offsetZ', function (offsetZ) {
	  return wheels.children.forEach(function (wheel, index) {
	    wheel.position.z = index % 2 ? offsetZ : -offsetZ;
	  });
	}, { immediate: true });

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var THREE = __webpack_require__(26);

	var environment = __webpack_require__(53);
	var vehicle = __webpack_require__(56);
	var area = __webpack_require__(46);

	var scene = module.exports = new THREE.Scene();
	scene.add(environment, vehicle, area);

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var THREE = __webpack_require__(26);

	var environment = module.exports = new THREE.Object3D();

	environment.add(__webpack_require__(54), __webpack_require__(55));

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _assign = __webpack_require__(38);

	var _assign2 = _interopRequireDefault(_assign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var THREE = __webpack_require__(26);

	var loader = new THREE.JSONLoader();
	var store = __webpack_require__(13);

	var choices = ['garage', 'ground', 'lab'];
	var data = {};

	var situation = module.exports = new THREE.Mesh();
	situation.position.y = 200;
	situation.receiveShadow = true;
	situation.castShadow = true;

	var loaded = 0;
	choices.forEach(function (choice) {
	  loader.load(choice + '/' + choice + '.json', function (geometry, materials) {
	    data[choice] = {
	      geometry: geometry,
	      material: new THREE.MeshFaceMaterial(materials)
	    };

	    if (++loaded === choices.length) {
	      store.$watch('situation', function (value) {
	        (0, _assign2.default)(situation, data[value]);
	      }, { immediate: true });
	    }
	  });
	});

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _assign = __webpack_require__(38);

	var _assign2 = _interopRequireDefault(_assign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var THREE = __webpack_require__(26);
	var controller = __webpack_require__(37);
	var store = __webpack_require__(13);

	var lights = module.exports = new THREE.Object3D();

	var hemiLight = new THREE.HemisphereLight(0xFFFFFF, 0x888888, 0.5);

	var downLight = new THREE.DirectionalLight(0xFFFFFF, 0.4);
	downLight.position.set(0, 1, 0);

	var spotLight = (0, _assign2.default)(new THREE.SpotLight(), {
	  castShadow: true,
	  onlyShadow: true,
	  shadowCameraNear: 1000,
	  shadowCameraFar: 20000,
	  shadowCameraFov: 90,
	  shadowBias: 0.001
	});

	spotLight.position.set(0, 5000, 0);

	var cameraLight = new THREE.PointLight(0xFFFFFF, 0.2);

	var controllerChange = function controllerChange() {
	  cameraLight.position.copy(controller.object.position);
	};

	setTimeout(function () {
	  controller.addEventListener('change', controllerChange);
	  controllerChange();
	});

	lights.add(hemiLight, downLight, spotLight, cameraLight);

	store.$watch('situation', function (value) {
	  if (value === 'ground') {
	    cameraLight.visible = false;
	    downLight.visible = false;
	    hemiLight.groundColor = new THREE.Color(0x45433A);
	    hemiLight.intensity = 0.95;
	  } else {
	    cameraLight.visible = true;
	    downLight.visible = true;
	    hemiLight.groundColor = new THREE.Color(0x888888);
	    hemiLight.intensity = value == "garage" ? 0.8 : 0.9;
	  }
	}, { immediate: true });

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var THREE = __webpack_require__(26);

	var chassis = __webpack_require__(57);
	var wheels = __webpack_require__(58);

	var vehicle = module.exports = window.vehicle = new THREE.Object3D();
	vehicle.position.y = 200;
	vehicle.rotation.y = Math.PI * 45 / 180;

	vehicle.add(chassis, wheels);

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var THREE = __webpack_require__(26);
	var store = __webpack_require__(13);

	var chassis = module.exports = new THREE.Object3D();

	var utils = __webpack_require__(48);

	store.$watch('chassis.parts', function (parts) {
	  // Dispose all mesh
	  for (var mesh = chassis.children[0]; mesh != null; mesh = chassis.children[0]) {
	    mesh.vm.$destroy();
	    utils.dispose(mesh);
	    chassis.remove(mesh);
	  }
	  for (var name in parts) {
	    var part = parts[name];
	    var mesh = new THREE.Mesh();
	    mesh.name = name;
	    mesh.castShadow = true;
	    chassis.add(mesh);
	    mesh.vm = utils.initVM(mesh, part, 'chassis/', true);
	  }
	}, { immediate: true });

	store.$watch('hoverPartName', function (newPart, oldPart) {
	  var newMesh = chassis.getObjectByName(newPart);
	  var oldMesh = chassis.getObjectByName(oldPart);

	  utils.hover(newMesh, true);
	  utils.hover(oldMesh, false);
	});

	store.$watch('chassis.offsetY', function (offsetY) {
	  return chassis.position.y = offsetY - 30;
	}, { immediate: true });

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _assign = __webpack_require__(38);

	var _assign2 = _interopRequireDefault(_assign);

	var _create = __webpack_require__(35);

	var _create2 = _interopRequireDefault(_create);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var THREE = __webpack_require__(26);
	var utils = __webpack_require__(48);
	var store = __webpack_require__(13);

	var wheels = module.exports = new THREE.Object3D();

	wheels.add(new THREE.Object3D(), new THREE.Object3D(), new THREE.Object3D(), new THREE.Object3D());

	wheels.children[2].rotation.y = Math.PI;
	wheels.children[3].rotation.y = Math.PI;

	var vms = (0, _create2.default)(null);

	store.$watch('wheels.parts', function (parts) {
	  wheels.children.forEach(function (wheel) {
	    for (var mesh = wheel.children[0]; mesh != null; mesh = wheel.children[0]) {
	      utils.dispose(mesh);
	      wheel.remove(mesh);
	    }
	  });

	  for (var name in vms) {
	    vms[name].$destroy();
	    delete vms[name];
	  }

	  var _loop = function _loop(name) {
	    var part = parts[name];
	    var sampleMesh = wheels.children.reduce(function (first, wheel) {
	      var mesh = new THREE.Mesh();
	      mesh.name = name;
	      mesh.castShadow = true;
	      wheel.add(mesh);
	      return first == null ? mesh : first;
	    }, null);

	    vms[name] = utils.initVM(sampleMesh, part, 'wheels/', true);
	    vms[name].$on('load', function () {
	      wheels.children.forEach(function (wheel, index) {
	        var object = wheel.getObjectByName(name);
	        (0, _assign2.default)(object, {
	          geometry: sampleMesh.geometry,
	          material: sampleMesh.material
	        });
	        if (index > 1 && name === 'caliper') {
	          object.rotation.y = Math.PI;
	        }
	      });
	    });
	  };

	  for (var name in parts) {
	    _loop(name);
	  }
	}, { immediate: true });

	store.$watch('hoverPartName', function (newPart, oldPart) {
	  wheels.children.forEach(function (wheel) {
	    var newMesh = wheel.getObjectByName(newPart);
	    var oldMesh = wheel.getObjectByName(oldPart);

	    utils.hover(newMesh, true);
	    utils.hover(oldMesh, false);
	  });
	});

	store.$watch('wheels.offsetX', function (offsetX) {
	  return wheels.children.forEach(function (wheel, index) {
	    wheel.position.x = index < 2 ? offsetX : -offsetX;
	  });
	}, { immediate: true });

	store.$watch('wheels.offsetZ', function (offsetZ) {
	  return wheels.children.forEach(function (wheel, index) {
	    wheel.position.z = index % 2 ? offsetZ : -offsetZ;
	  });
	}, { immediate: true });

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Vue = __webpack_require__(12);
	var store = __webpack_require__(13);

	var vm = module.exports = new Vue({
	  el: '#interact',
	  components: {
	    interact: __webpack_require__(60)
	  },
	  ready: function ready() {
	    var vanish = __webpack_require__(87).vanish;
	    var interactor = document.getElementById('interact');
	    document.addEventListener('mousemove', function (event) {
	      document.removeEventListener('click', vanish, false);
	    });
	    function onMouseMove() {

	      interactor.style.opacity = .3;
	      document.removeEventListener('mouseup', vanish, false);
	    }
	    function onMouseUp() {
	      interactor.style.opacity = 1;
	      document.removeEventListener('mousemove', onMouseMove, false);
	      document.removeEventListener('mouseup', onMouseUp, false);
	      document.addEventListener('mouseup', vanish, false);
	    }
	    document.addEventListener('mousedown', function (e) {
	      document.addEventListener('mousemove', onMouseMove, false);
	      document.addEventListener('mouseup', onMouseUp, false);
	    }, false);

	    document.addEventListener('mouseup', vanish, false);
	  }
	});

	__webpack_require__(86);

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(61)
	module.exports = __webpack_require__(67)

	if (module.exports.__esModule) module.exports = module.exports.default
	;(typeof module.exports === "function" ? module.exports.options : module.exports).template = __webpack_require__(138)
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/bradpitt/Documents/front/carFitting/src/interact/index.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
	  }
	})()}

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(62);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(66)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-72d5f8e0&file=index.vue!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./index.vue", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-72d5f8e0&file=index.vue!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./index.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(63)();
	// imports


	// module
	exports.push([module.id, ".v-interact {\n  width: 100%;\n  height: 100%;\n}\n.v-buttons {\n  position: absolute;\n  top: 10px;\n  left: 60px;\n  z-index: 20;\n}\n.v-buttons button {\n  width: 40px;\n  height: 40px;\n  outline: none;\n  margin: 10px;\n  border: none;\n  -webkit-appearance: none;\n  background-color: transparent;\n  background-image: url(" + __webpack_require__(64) + ");\n  opacity: .5;\n  cursor: pointer;\n  background-size:cover;\n}\n.v-buttons .active {\n  opacity: 1;\n}\n.v-buttons button:nth-child(1) { background-position: 0px 0; }\n.v-buttons button:nth-child(2) { background-position: 0px -44px; }\n.v-buttons button:nth-child(3) { background-position: 0px -88px; }\n.v-buttons button:nth-child(4) { background-position: 0px -132px; }\n.v-buttons button:nth-child(5) { background-position: 0px -176px; }\n/*.v-buttons button:nth-child(6) { background-position: 0px -220px; }*/\n.v-buttons button:nth-child(6) { background-position: 0px -264px; }\n.v-buttons button.logo{\n  background-image: url(" + __webpack_require__(65) + ");\n  background-size:cover;\n  position: relative;\n}\n.logo:hover{\n  opacity: 1;\n}\n.slogan {\n  position: absolute;\n  width: 150px;\n  opacity: 0;\n  left: 40px;\n  top: -36px;\n  -webkit-transition: 0.5s;\n  transition:0.5s;\n}\n.logo:hover .slogan{\n  display: block;\n  top: -11px;\n  opacity: 1;\n}\n.support {\n  position: absolute;\n  width: 150px;\n  opacity: 0;\n  left: 120px;\n  top: -15px;\n  -webkit-transition: 0.5s;\n  transition:0.5s;\n}\n.logo:hover .support{\n  display: block;\n  left:180px;\n  opacity: 1;\n}", ""]);

	// exports


/***/ },
/* 63 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 64 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAL4CAMAAAC6B6J3AAAC91BMVEUAAAD12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Wz12Ww7dqnrAAAA/HRSTlMAIE55mrrU5vgudbLsAj2THH/h8cSefmJMOTAzpfzemFsjMbDNeCYaou2PKgNy9N1rC2zL42gEAWr39gmADKoh1WQ26dBCo3r9XfofZYGQBv6kWeVWFw7n9SiOLNjBRasnHQVQXxCmxuTubfCL+77TWA06gq5AVPNe+d+fYMAl4sKnilFpMtezoZI4Z0RBuLdjCtF7T6nyTUhTqIxciI0tJLtmryITzNzqQ50UN+s8YZbWfMdXEYlSycqHNLk10lrbK4ZwfUYHCBnol0dvm621vzu2mdmVkaDgS3GxlNoSG1UpSj4VGL3OyKyDFkmFz++0dC9uDx52xZyEP3N8mdsMAAAWEUlEQVR4Xuyb6VsUVxaHb7ciLS4ICK6NOyJgM0EJ2ouIIMFEGxNi3GJi2hDJzLhOcEnEney7Tsw+M//n+yGdeh77WJ7psqvq3vng8H70weeFPtSpc+/5YWolkZw3v25BfQogVb+gbv68ZMLYZGHDosVoWLyoYaEVwZKljfUEUN+4dElMxbKmZjygZXlr24qVq1aXWbVyRVvr8hY8oLlpWQzFmrVpPNrXrd9gFBvWr2vHI712TUTFxk14bN7SYarSsWUzHps2RlBs7QRgW1e3eQbdXdsA6NwaUtGzPQPQ+5cXTA280NcLkNneE8bRvQNgZ/+LpkZe7N8JsKO7ZsXArt1AtilnQpDLZ4HduwZqcxT2ANQNmpAM1gHsKdT0tXuBzJCJwFAG2FvDd7dvGBjpMJHoGAGG9z3LsT8LjOZMRHKjQHZ/sCOZAl4yMXgJSCUDf44UjB0wsTgwBqn9AfXIwstJE5Pky5CtWpfBYRgTR3TLGAxXeQIKe4EDxgIHgL0FozEDe1TNY1V/z4DR7AJGjSVGgV3a0b0bRnK2JLkR2K26Zc8OyHQYa3RkYEeP8bMdGDIWGQK2+x1bM1BnrFIHGf+7shOyg3Ylg1no9M0MQN5YJg9sNMIm2JnTglcOHirWxKGDr2hJbidsEscaoF8pxhsPUzOHG8eVpR+QeWwt9OqZ4VVC8aqeLnphbWUWTUOfcrwGE68fqWkuGDjyej28pix9kH48wbbBNjVfvXGUY8dNzRw/xtE31Dy2DdqMx5Jm6FIVOQFbTAi2wAml7oLmJZ5kKaDazMk0b46HkYy/SfqkaojAUk/SCJtV3z8Fb5lQvAWnVAU3Q6MnmUB/MOvhbROSt2G9/hCZ8M5qwGmjq/5OWMk7uvbmNLCwLGmA9oCqx6x9OzSUJYtg3WNB6YzHu1L1sLV/94xH6bFkHSwqSxYjH+UkAFmk6mFrzzEAJqW4LDYmAVTOg7n3zk4dfv+vUvXwte97//DU2fcq3XYDkDBJaPH3xcGjkP1bJLIwkfB3yhZImnmwXFU9Dn83PpbDPDMfWp9+1mNxzt89WmG+qYM2/7NOTM77JG1QZy7ACv+zHpuLRjAr4IKph5X+Dh+biUtGWAn1JgWXjfAPLHDICJchZYDV4pjMYIHMpEhWA09JDmKFg4GSD2BousKVqwAXpwO5CHD1ivzDEHwQKGmGa0Y4BZAwgSQAThnhGjT7JU8V/jrw4fmP8jemE6WyZAbgZrDkJsBMWVBKTN/If3T+Q+C6v/D+X+Ecwtit251TAHdWBbT98VV3AKY6b98aQ8j5foXlYZRWr0idvXvviBYcuXf3bAoNMOl/GL22oiWa3tH7s5UGOz57f7QXQUl8bUUapJZo0h9/8ulnn336ycdpFEoiDdLX6j9vxRKtnz/Z6n0vrS6s0fXkS8v3+i2K4NYXX06H5Msvbomk6Hv9eoOElnxlIvCVXyKDhDcSaUkhiqTgl8hI5A13WlKMhJa0Q4OMqSKxQtE/ppqpykzahDWaKpPrVOXooNqKiQTSVuToIIcg6xI5BMlxzr5EjnNyMLUukYOpHLGtS+SILZcFJW98vI4HqWiSFB5c9w6PJe+yQF97fI0H30STfIMHX1euPWb1BY659G3+T769FMkh/10ucP63V1HuL9XcXw+6v+h0f2Xr9vL5u+/V5bPTa3S9EHhgx/FAFgLOVhvXgAWFgCXNw/iOh2pJo9ZNsS0PZd3kbHF2TRZnQSvAB3Frnko6XWZ+J8tMd2vZ72Ut63TBvGDQ/ar8n4VQS/+8k6W/ji+UalWUJL4QPojRFzKI4S5SUpRISYxwzOnqhtMRwzHCbO0xn9k4gaW2ZjzgBy+wdHl1mcteYOkHPKC5bVn86NUUAUxJ9MphiMwmiUflONyFx3G4C+U43KOEFswxxxxzPN8p27mU7VzKtu+5SNnm/z9TtnMp27mU7cPYKdvcjw0NP+aeYYmVss399HMGIPPzTzkXKVsxgHjspWy1QTw2UrbaoD02UrbaoD3xUrZiCOEJTtlGMognfMpWDOE9wSlbbYjuCU7ZiiG6JzhlK4Z4noCUbc8vV7HC1V96qqZsf8Uav1ZN2f6GNX6rkrK1uyqvmrL9HWv8XjVle+Ucljh3JTBlOwNMmshMAjMBKVvLEp2ytS/RKVslOX4mEv8SiU7ZKkmeSBRFolO27iQ6ZSuSxHQk/i0SnbJ1V3hJ2TqUSMrWoURStg4lkrLVkv6RSDSIRKds3T0nkrLVkhszkegTicqm2qvJ8y6RwjuSSMrWQavXKVt3XVhStg4lkrJ10+qlQbpu9ZKydSlpgUfy+rUs0SlbBxKdsnXQ6nXK1kWr1ylbB61ep2wd1ESnbF1IdMrWgUSnbN1Iiipla73V65Stiy6sU7Z2JTplO4v8cfF/IF2K3upLafijvXONrqI6+/gm1ERrYxLT0gaJovGCNhXEmlNIUIqnkqRwclajcltAheACsQkIqeEWREWDWG2iMYIKwYIBRO4YEIhKQEBQEbDhYmmLoIiipUW07/t8qJvJnD3Jw+zLzJkhi+z/B9baLhc/MnvOnmfv+eU58wjhWLY0l2VlzSIuMisr6zJ8gKMtW23ZVpQTHG3ZVtq/2ihRBGjLtuR8smzL/bBsKzy3bGPPWLbasiWt27INSVu2ZTZKibZsq1qwZastWx0dHW3ZastWW7bastWWrbZstWX7rA+9bJ0y8l7+S2VBhoNethnzLylOWSDFSAwCALzSRtmyvWoU0HSeUy1m1AANLJyratkugsaEF78qxwBInqtq2V7DHrJLRIzxd75m/CxtZC1bTOlezGd0SCdLgQZeyZC1bDEluVTAIDPBSIG0ZYspN8fzGR2zwUgl37LlU5aJGNkvL6XzMt5BL9vlJmSFiNGRkDsB4GWeZcuQi5oUPmDmCSEjfTxAME+ml23GKKuySIaDmZVCRgeAmkSpXrbzASyUua+BmUpphriX7SVAKZgBq6QZ4l62xcAoVgYMVmGYlm3S2XvZpoBBac6Ap8QM6V62C8DI8iuHN2FASMhQ6GVbA2fPahUGx7LlacPhNWKGfC/b6jDgAJ0BVQa51r6X7WLgUFQY2LJlWRDHoUgysGWLayMORczgWrYsxcm2FAqRYGDLFqf6Zg7ldRkGtmxx4petMAFhNC+SDGzZ4vRaWblq8FOh1Ws6IEqtkIEtW0HSO+B5ETKwZatOqRUxmNgXyxRFRYqIgS1bR5SHxQxs2arPi5CB3VR1CmKIIeoUogTxgIItWw8o2LL1iIItW3FqE9Uo2LIVp2N2jSIFW7ZiBmTXKs4LtmzFjI7q84ItWzFDlYJ72YoZqhRs2YoZqhRs2YoZqhRs2YoZqhRs2YoZqhRs2YoZyhRs2YoZ6hRs2YoY6hRs2YbEDHUK7mUrZKhTsGXLYShThJYtZqhTRJYtZihT0LEHsmwRQ5FyR4ACpCzbEUOnrAXE4FNy+6a0r10Hb0hZtmyTjRhcSl86GJEcXi9p2d42gTLWqtUwKYRmAyRIWrbTgGYKUaK0b5zdSjnLdiPQwFCiRKklNHXQVc6ynUIRE+aMIEqUdfT/fxPeKqfj8qDIsu0PANMUlbv0OyB5Q1odXP8217IllaZnGdO/cCNRTWBTGADe+rmol22sO8t2fUJl1/KIZdvz/LZstWWrLdtKD16V46hbtrqXbZmiZYuVEm3ZVkW5l622bHV0dHS0ZastW23ZdjmvLNskbdmqRFu2OIHp9VfcmrZ485Z3PLNst9ZfHlkuQ9u8sWwfoAjovn3kcxRz40xbioteti/mQufNvxlLB8M2dvkxwLvpUe9l+0h2blfrMjMkH0LuetnizH8wdQd1qHa+V/n+pJWL4gm5Jw7GuOpli/MBbVZ55S5oTM0WQp6HheiaqPay/TDr3t2zXxpiXKInoNsacl0/iCT7SUJWUa0KR96yfbLIfIJPNuTVxwnZA5bsDZBfIDNMqZdtYBOwzM4j8aPgGfJOf7BmKfmQamg4spYtZbCMDwyibtNGaJIfkrE2h79ylu0QaJr7aqlq+MemkI8ISYW/EtskcS1bEohtBrm+K3VCJjeFNBAymv6BwrNs8TerslwNMJ0UNIVMIiSZByEzbS1bmhcQJAxQTKpQa1SbF5R8y5a1qMHpSEqbfy/1dfQPTrpgy5YliJutbqf/8H1WRng+2Q8wAAH4li3L1QjyXAKsI+SAFXKQyldFhJuByLJlmYYgFdemwlyScTFjdL6O5I1EbyflLVtyC4IkkI9hXoBkdP1b4z19/yF6Yl6ESkxpy5YsQEJnL9JjBXxMq8O/7/jH7/b/k16D1dnd0aIitmxZ+oI1ho/f5lLYNd2y2l0BufuJKKX2li3JWwXW/HIbJSeuBQh+tOzw0iVbVr9UmAq3f4IAMpYty5G1VsYgAz2s94MMHO50BAHkLduNeyr6jR59I7B0G23mQgZJNf/b1IeSjhKiZtn2BvWM+lDNsv0EnCR/q5JlOxscZYySZTvVGSRBybJNdQZ5X8myBWeZZwXcVbsjHveydQ9h7+7X/PnTbIDXsWUbNchNYy6eADQTI5AUZNm6guRVTYt8hEcjNzU6kI30uMBryAXgAyTIgdCJ9wbCJl72Fq6ZYpPtAgizbMWQemKTBj6EWbYeQLBl6wEEW7YeQLBl6wUEW7aeQLBl6x7yGYIgy9Y9ZDmCIMvWPeSdpKkIgixbtxD67uDdhWaRZOofyLJ1CaEZ9nynZDo+xrFs3UJoMmd9vr3zJ1zL1rZ8C9pkFNB8gOC8XrbdwVHuRQCeZfuZEwRbY+Us2+POIOs5W2xs2X4R54TxOfewAFu2v1+njEh9D6laQsu2fZ92WQppOwZJMT72sk1qfb1sdS/bzOC57GUbsWzdp7dnli1LjrZspZPjg2Xb23vLNtMPyzbok2Xb01fL1v/WWtqyFSslupdty7dstWWro6OjLVtt2WrLVlu22rLVlq3uZRvTUnvZqlu26lG3bNWjbtmqR92yVY+6ZasedcvWXTI2700QW7Yucx8AzBJati7TBwBWpAssW7fpQVWGyQLL1nV2UvdmGNeyFSb+y7b8uiePils53F62ohRXAExAExfYGfw4YP1rYwMcy1aQ24YCzaNn+/q3F83BVqqr75ezbHFuOtENaPDtMYZKLZF5aEtLEPwyE1u2OIGcfAAbSOZU64SO6E8dX7Fli7PkGIAVgj8d+zKsLVc3yVi2+JyQB6HTyyyLXgAQF8+1bHG2tr0RAEOWHdsTMCmPAsBXEWYsVYR5li1O7UQAwJAYS5NqkkmdhUittdkqLGLLFueiXQAIYjabnppp/XWCxeZgAAD0CwgsW5ZX380GG0heDQB0MSHzwwDPZVqv10Vcy5Ylr/5rADsIFarg8siCu8u6xg8EgAM8y7bNm/VGDiyPA+BA8uiCW8VWE0t5sB8A/sWxbAddCCxcCHkDAB43IdvoPJiDsWGA7RzL9iRIQy6iRv8h6zwMMgd7AWCbvWWbJQ8h+6wvJRMA4KdWG/gwtmydQDqB5elaYLV5VwLAfdiyVYOwqqHGHPwbAAqti//D2LJ1AllER3ebZTQAvGX97ZXZ2LJ1AhlAR3PN0dcAE0zI2+yZgixbRcgCOtphvQ3MYqgNE5iQm6oIuZuOhpujCsu3aR8BgKD/EF8uly8TH51beCz/Fvblw+jBsrIZLSu+LJDRW+rf5iz1Dh9aL8k+tLBl+9sxk43UL8+P4uPXvpDYKV9IDOYXEvySKJVbEv3KWhIlc0oiQXFXaAN5hF/cxaHizmmZ2odbpiLL1tuCe6RvWwfxJqiXu02Qh9s5Ztn6sTH1Z4uNLVv1w4L/yB0WkOkeHnv4cYDj4VEU62Xrx6GaL8eDvh90qlu22rK9VVu22rLVlq22bLVlqy1bbdlqy7alR0dHR1u2+V5btu1agGWrLVtt2Wa1DMtWW7basn229Vi22rLVli2OV5atei9b91GwbE8dDDbL4PWKlCyhZVsMKK8rQsSW7ZMYElJjiC3brfdjyEOHZAFiy/ZwWn4YHCecn8b8iK52lu0ccJ05Isv2MLgPcz1uOLtlm+YGsK62fUrfXIA0gWXL3YvcXrjnOLUkj+8p3A44ySMau8fmCyxb+zkvOjmAWDLgZFFzyAbTUAoLLFs7xMThqP4MDG/mNqRFXCv0VbxS7c4OnrX47HEQrKkztAoK4Vu2NgybPUF6U8qbtEfnzQyCLFseZKL5c1SXjJtRVpYwrqTa/FmaXrG6tA3JdMDvZYshTK0LFFimuqggENGTcWx62fIgRQHKGPt0U/LTY8+Qi/gQZtkKICcpI2AyGCVgq2vZ9LLlQQYYLgRKgan1oPB72WKIaW4VYUgRoekHOIq9bE1jrxpwoJpCCjkQ+V62V5jlLUqOIVdxINK9bI9TyDjAgXGonxyGPCDXy7aeQmYADsygkHo+hLmpYkgD4EBDS4L4crl8mXhfbmFfPozSy0odZtTJLivSC2QOhpTILpDyS/3u5ozd8kt9lfRDqxllt/xDS+Xxm2OZl7ochcevYiGR03dGQ8OMvjmokGDBhYT7kggHl0TuizscXNy5L1NxcJlKRrosuHHCyLJV2DosZFuHhcAJ2jpEaROEy3ts2Yaiup37Elm2Xm9MPd9iY8s26hnmxLJ1cuwxPeqWrf+9bLFlW3be97LVvWzLz6VlS6LYy/YZHyzbEm3ZSqfEB8v2Ge8t23I/LNsKnyzb2BZk2ZJWbtlqy/aqc2PZVlks22Rt2WrLlhcdHR1t2epettqy7eJBcee/ZZvUOi1bbdnqXrbPii3bGE8PcLRlqy1bcbRlm6QCcG/ZfhNzy+kTIW42lRqAQ298P5hz+kpJy3amKQq33QsSmdQ4l68BTW4fJcu2OF/tfWX1PmO8Usay7dLIyAU1CEmMNSg3BKwAbNkmRSzbU/kgmUnEzIK1BqWMFV02lu3ASFshmtxvv3shi5t2pSSS8gsMysXlDMCzbB8zJvUoUUrerQZl8CkTwLNsvzEYRDXpewzKV0dMALJs4yKWbQxl5B4l6vmvQalhOzxs2ZayGxu+JU5ywKCMHERoeJbtaQr5jjhKQbax1VhCBzzL9gSFvECcJaY70HTfQgccyzYEbt4B/18y0OTeyRDIsnUNIdONhSx7JuFYtm4hpPRStJAhy9Y1hCT2RAsZsmxdQ8iraCFDlq17CLlpHlvIkGUbLQjJe4otZMiyjRaE1AJbyCyWbYoEZOvpkFzYyX7NXciyFUAeAfV8itxUAWQyOEipnxBfLpf0xP9/llwGson/wpx4X25hXz6MviwrviyQviz1vjy0fHn8RrGQKLYrJHwpiXwp7vwqU8lILwtubNneAzQNHmwd8CaoYZvLTRC/l+01ke1ciJ9Nqts50s7BxrRBemPqyxbbk8MCbNniXy4+dc1j8peLHXsoW7aJ3x/gZMnt4w9tpiPOAY7fR1GkUwuwbLVl6+3hc3nFue5l2zt6lm1lwKtXG8yyjW0tlm2OL5Ztb38s20w/LNug55ZtT7eWrfevyiv96GVLWpllq66UhAylpMxGKdG9bKs87GWrLdv/Ae0QpVMB86N4AAAAAElFTkSuQmCC"

/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAA7C2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMwNjcgNzkuMTU3NzQ3LCAyMDE1LzAzLzMwLTIzOjQwOjQyICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgICAgICAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNSAoV2luZG93cyk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTYtMDMtMDNUMTY6MTQ6MTArMDg6MDA8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE2LTAzLTAzVDE2OjE0OjEwKzA4OjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxNi0wMy0wM1QxNjoxNDoxMCswODowMDwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnhtcC5paWQ6MmM2MDgwZWYtMzE5Yi02MzQxLTk1ZTMtNjYyOTRkNDUwMGI4PC94bXBNTTpJbnN0YW5jZUlEPgogICAgICAgICA8eG1wTU06RG9jdW1lbnRJRD5hZG9iZTpkb2NpZDpwaG90b3Nob3A6ZGRkNDA5ZTUtZTExNy0xMWU1LTkyYTktZDk1MTBiZDdmNDY4PC94bXBNTTpEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06T3JpZ2luYWxEb2N1bWVudElEPnhtcC5kaWQ6NThjNjA5NzQtMmUxOC1mNDRlLWI3MjctNGEzNTkyYjJjODUxPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjU4YzYwOTc0LTJlMTgtZjQ0ZS1iNzI3LTRhMzU5MmIyYzg1MTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMy0wM1QxNjoxNDoxMCswODowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDoyYzYwODBlZi0zMTliLTYzNDEtOTVlMy02NjI5NGQ0NTAwYjg8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTYtMDMtMDNUMTY6MTQ6MTArMDg6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8cGhvdG9zaG9wOkRvY3VtZW50QW5jZXN0b3JzPgogICAgICAgICAgICA8cmRmOkJhZz4KICAgICAgICAgICAgICAgPHJkZjpsaT5hZG9iZTpkb2NpZDpwaG90b3Nob3A6YjY4OGI3MzAtYjkzYS0xMWU1LWFkMGQtODcxMDA3ZmYwNDY0PC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOkJhZz4KICAgICAgICAgPC9waG90b3Nob3A6RG9jdW1lbnRBbmNlc3RvcnM+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+MTAwPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjEwMDwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+YcxsQwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAPoklEQVR42uydf6wV5ZnHPxyOAc/Q6qJ1K4UGqswoFq3UGtCQ3f4QN9taYi2YNgW1VEzXc1KrSbUl0WC63eKuVnOmti6IP+i2EdK6tLaNmLamt1prFRSE7hnRe4MILoUbSp0DN71I/5hnuM95mbln5vw+994nuWGYmTPzzvN9n+d9nud9nvcdR4eTX8pPB84HzgNmANOBKcBk+Ztg/GQA6Je/PUAf0AtsB7ZajtvXyd87rgMBOB+4HJgPXAKc1uBXHACeBXqAJy3H3ToGSCUAGeBSYDFwFXBmi5uwF/gxsB54xnLcd0YlIH4pPxVYBnwReH+V2w8B2wBPVNBuYJ/09sPGvSeLVJ0BTBUVZwOzgXdXec8uYC3woOW4u0cFIH4p/2HgZuBqYHzMbb3AJlErz1mO+1qD3n0WMFfU4QIZk6LoKPAYcI/luC+OSED8Uv5C4A5gYcwtm4ENwE8sx/Va1CYb+AywCJgTc9tGYKXluFtGBCB+KT8F+DawJOJyP/AosNpy3B1tHstmAdcDS8V6M2kdcJvluHu6EhC/lB8PfAW4E7CMy68D9wAPW47rd5iVZwHXAV8FPmBeBm4H7rMc92jXACK97RHgIuPSbuDfgTWW4w52uP+TBb4ErBDjQNMLwDXNkOpxDf6IccCXgbuBierSYWAVcJfluIfTPvfYsWON+dhx42r5ppOBW4GviQUX0hHgFuB7luMe6zhA/FJ+kpiMi4xLTwE3WI7b22oAGgmQX8rPAB4ALjMubQC+aDnu2x0DiDT2CWCWoW9vshx3TacBUScwXwLuNcbFHcCn0nS6pgHil/IXAz8TRyykl4HFSczXdoFQDzhiLq8HLlCn9wFXWI77fD3vz9QJxseApw0wfgDMqwbGsWPHOg6MpO2Sb5sn3xrSGcDTwpPWS4hfyn9aeomOtq6wHPdb3SQR9UqMX8p/QyzHkAZEO/y0ZYBIL/iFAuMd4FrLcdeNJDBSgLIEeFhpnAHgXy3H/XXTAZEx42llAv4N+OxwPaJbgUgDjF/KLxSL6yRl6v9z2jFlXEowZgDPqTHjHeDK0QBGClB+oiRlHzA3jfWVSQHGJDFt9QB+7WgCo9o3WY67EbjWGOifEN41DhDxwNcafsaKuDGjUy2oVlhiwpMV6tQsYK3wsDEqyy/l/w34rjZtLcddEnHfAuAUoNFxqizwq5xd7O8WFeaX8uuAL6hTN1qOe3+SD60GxiyJTWmnb3nEfSsJIqHNojUE4fGOk5YYUJYTzFKGzuPdfin/dLWAZKYKGOMJorYTVThkcUyA8ENN/vZ93TSuCI8WC88QHj4iPK1ZQr5CZQj9pmE88H9Ux4PCwMEkUphAio8AP6XLyHJczy/lbwJWy6mLhKf3pB5DZKbPYyiI9pTluAviekjZK7xOMEe9B/huzi5+i1FGw4wnmxiKEvuAHTfzOJzK+rYC4zBwQxVxDc3hP4xGMKqYxDcwlB1jCW+TjyGSkKCtqFVRzk3YgLJXOEWFUQ4wiilmPOkF7lKnlgiPE0vIHep4t/GwKJqmxgqfMYqiVcLLKB7HAyJ5UzpV55tRVpXRE/SAPuoBGcbq0lHhhcLrqhJyszp+HXgwwQt1wln/mDDEjidrhKdRvD4REEnvvFqduidhdsg56vjVMThizeBB4Dvq1NXC81gJWcZQemc/QYw/CfI6f2nXGOuH5dVDSouMJ8htPhEQyULXFx9JkcQ2zXAIxyheSnyCbM3jQiC8P0FCLqUyC31NCjs7/F1vzi7uGWN7VZ6tNnh3aRQgi9Xx5qRZeWWvMFM5hX8agyCRlOwgSC4/gfcakKvU8YYU0qEtrFfG2J1YSjSPP1MBiJSR6cqlH6d4ny45s8bYn5geV8dTBIPj3vXl6mKv5bhpTFc9pfvpslfIElQ7TZJwStrJqqwyEN7I2cUfjVC1VfJL+V6lYS4HtoYfP1/duymFutIWVqi+bmxgu3uBH6nxapMANgh8PmcX99fy0LJXOIcgB/kk4P6cXXxLzs8T1d2IGc+JwOqcXdwe8jAiGryJoaDtfOA/Q0AuUTf1pHzxRa3oUWWvMJvKROeZwP4aH/dDIAzuHQb+Q45XGZ2zXtpLUI4dRz0KkEsAslIHrseB51K+9FWCqcooGp/iOUfl/lNinEzt0fbk7OLv62DUP6jj/xPA5xPUwjeK9gG/rXKP5vVpfik/PUtQlB/SIbPAslr2SM4uXk+D5rrLXmEywbz8jaKatJN5tjp+oc5Xna6O35J/Lya6lK1W6jM7jam2LMd9zS/lDzFUHXx+1ugV29o50ElWyU1lr7BEmDOgLp9rqIJaQZ8uBkdIf1bO2qBYimnK1Y5IO88G/kXx888Jf79NOYbnZQ0/wqPNVPYKn1Pm81/UpQ9G9Opa6Fzj//ulMxwC7quz7b4CJGnEwlOAzMgQFNYfF7MOsAgXMDT7uEs+NGswsq9B6upgzi4ebGDbD0VIXlXVpo6nZwyHcHcHAPIhdfyiGj9ONwyJWum96rjRtefz1HHSeSHN8zMzhoXVCZHa9yvp2BKlZkK/oUaaNlyIqE7SM4A7U1hjxy2trGFZdEKCQtieV1XqqFar9RZXavP5l0r/vyK9+tZaTGqxEN+jogzbE/5US9LkLJUVUIfbiUTZK5xreOlRfkO9auZUJWkV+lsG5KfKXmEvwcoN38/ZxaRa42xljOzN2cWkElJWxxMydBZNiRknTjUduRoBfy8RC86UvcJihmJoljB3JbCp7BWKZa/wiQSPd5IYHdX8umyHATItRkL0gP5GHc+fbag/lFM4IeL8BfKXL3uFn0vI5QkxkU2yGtFpOk1Czk0QNtlZx/Onm/6HYrymqKnrTwL/Axwoe4VHy17hYuP6KUkkpFq9Ysbwhk9uMyAzY7zxM9WA/sc6nq/VVU9MWOaHBEHM22IiAlmCrM5flr3C/5a9wufl/OU1RhJy6nggY4zyp7UZED2G7BH9Pk/5Dm+nGCzjBt4KQMpeYYIhORtzdvH3Obu4SgBcSjBhNxhhDS4E1pa9wv9TGSVO47hqK7c/K6Zu2APPaKOFNVn14IGcXQwZMFfFno7U+ZoQ2IPASxHffAgoKStsQKytdWWv8EkB4BIq438TIviWptPo3x7IGOI1tc3jR9i4bTHe71/rfEdYeLQ/Zxd/I8d6HcY9Obv4cqResYs/z9nF5QLIncMwfTBnF9MYHprnezNmLKVDxo8/xKiZ/XW+410ROn5amtBRzi4eytnFO3J2caZ45t+vMYYVxfO+jGFe2m0ERIvuthinsN5Y26kRwGqGbE/zsJxd3Jyzi182DITtKduked6bMR4wu42AaINCpxPpuYuaLayyV/ioetbbMYC8XOPj36jDB9E8354B9MrO75alVBPbzQ2kc5QP8FKE3j9onK/FB5mknhVlCtdK5yWRYpOXwms9hm3NWo7b55fyB1QPnQu8VqW3XStm4AD1ZWj44lB9HPin8FzOLvrynolGNOEi0idhhAkSS0w/QUxePYW9RM7tlfeOr9L2ieJ/hIZHf0oJmastLMtx+8KPfRa4Qo7ni0ca93G3AP/VREkZNMR5otL/y8te4SPSwydVGStOZ6iCd5qhmnYqD12XUnxU/mqlQzm7uDHF/dp3eVbHsnoUIAuiRE0FxT7cZNWlAflchFo7p87nvw2E4fU5TWx7kpDJAtNRDWNZT2qd6pfyMxPY8s2iFw0V1WjakrOLu5vkCCc2ef1S3jHGryePS4jluFv9Uv5N4H1y8SriS3cXEyQcDJIuO6MaTRCn6hXjXTNqHKcG1WB+ndIAekBfJePFkQa0P6skLwldqY7fDLfN0APm40BejheZgIRqS0IaL9ECkqnat+qViLJXGFSADBqhkdXN/o4YdbXI4D1aZUGwfmJIc2TRmZFCgw10Lusm4e2cKN5rQJ6hcg7i+oRIdwNdFuPE0Sbp0LzdJbyvBER2ltEl0EtlYfqRQHM7RUKEp0vVqQf1rj7mjOFaNVBPpnK5uq6UEkmy01ZjX5ul4zqG5kCOCs+JBES2+XlMnbpZdgnoZvoIlXPyW9ooHScRbIMR0mPm1kpRc+p6LacPEGzZ0M1Soh3Jgzm7eKSN0rGMypr+u80bTgBE9lzS7v8K2bKhW0HRE0B/ahcYwkO9OOZGy3E3VwVEaKXxQV/rYpWlJ6BeamM7bjU6x8qomyIBkQ2w9BKwt8oiyt0oJTq5+tU2SccMo1Ovi9tkbLi8rNsYyk86mWAzE7oQFA3IzlaDIfQAQylWvvCWVIDImoB62dfLZDOTrgFFqm31OixbWg2G8Ew7prcPt9NbtczF+6is57tXNjPpJpM3lJAjKsrbKjPXJtiNJ6QXqFKlNSwgsjXcNQxFQy1gfRdZXTo19UgrpcMv5XME9SeWev811bbbq5rbKwul3KJOXQD8d5eoLj2f8karwFDjhp4eviXJgj5Jk62/R2W10RdkZ5mOBaXsFa6kMsluZ6vA8Ev5FVSu+75eeFj9mSn04SSCBDYdll863K46jdohoewVrgfuT/kzM+TznZxdvLnJUoFfyi8lWJ49pO0Ee4gkqvxKXI4gD/wUlTVxD8smJjRZWi4TBqf5M6m3BWAsJFjCL6Rw57bEZXip6kNkQeArGCp9ywAbWgBKvQHOtwi2aWo2GBsUTw8LGKk6QldsClb2CheKdO4n3fx6liAl6Hc5u9jTDCCUmnqIdmwKphoxtm3e0AD+TXWq9dvmGZLyBJWVVz8AllfbhLjTgUkARE5MW21NHSbYgvXXNb+3Ad7oaN16dYPhZ7R/61UZ6J8nmLPeYTiPm+NiXyYDwr92gpC0DfJNmw0wQtP2+brb0sC4zWjdvns9sKyjtu9WjR5ug/u7CPYhGVEb3CfZea1tgKiPmCXeqpmbu5tgy4YHLcf9WycP6pKQsIxg2tWsvXyBIFC4o+FS28QPGk+wAdadnLie7+sEuwQ8lGJ9+VYBYRGk6nyVyoQECCaXbgfuqxa17ThA1AdOIcgTXhJxuZ9gYfrVzehtNUj1cmln1NqLjwJfH25yqSsAUR98IcE2P3Fhls1iSj5uOW6pRW1yCLLQFxFfK7IRWBk3B961gCgmzCGYX7ma+JKxXoJFhnuA58yVUut491lios8nKJaJqy88SpAweHdUqs6IAkQxZyrBfiXLqNwmI4r+SlCc6hGkgu4WR6yfyvWmIFg75DSCxcSmEtSH2OI3vKvKe3YR5DevNTMKRzwgCpgMwaqci0V9vK/FTXiToD5jPfCMTnwelYBEAHQ+QWXrfIJlLBq9IM4BggLLHuDJsHKpY0I3dDjJUuizCcroZogKOlOAmsyJC48NiCo7QFCu1idj0ivANstx+zr5e/8+AKu2XYNSwuBRAAAAAElFTkSuQmCC"

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}

	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}

	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}

	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}

	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;

		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		var blob = new Blob([css], { type: "text/css" });

		var oldSrc = linkElement.href;

		linkElement.href = URL.createObjectURL(blob);

		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// <template>
	//   <div class="v-interact" @click="click()">
	//     <div class="v-buttons">
	//       <button :class="{ active: current == 'selector' }" @click.stop="toggleCurrent('selector')"></button>
	//       <button class="active" @click.stop="changeSituation()"></button>
	//       <button :class="{ active: current == 'remolder' }" @click.stop="toggleCurrent('remolder')"></button>
	//       <button :class="{ active:store.rotation }" @click="store.rotation = !store.rotation"></button>
	//       <button :class="{ active:store.music }" @click="store.music = !store.music"></button>
	//       <button class="active" @click="close()"></button>
	//     </div>
	//     <vehicle-selector v-if="current == 'selector'"></vehicle-selector>
	//     <vehicle-remolder v-if="current == 'remolder'"></vehicle-remolder>
	//   </div>
	// </template>
	// <style>
	// .v-interact {
	//   width: 100%;
	//   height: 100%;
	// }
	// .v-buttons {
	//   position: absolute;
	//   top: 10px;
	//   left: 60px;
	//   z-index: 20;
	// }
	// .v-buttons button {
	//   width: 40px;
	//   height: 40px;
	//   outline: none;
	//   margin: 10px;
	//   border: none;
	//   -webkit-appearance: none;
	//   background-color: transparent;
	//   background-image: url('./buttons.png');
	//   opacity: .5;
	//   cursor: pointer;
	//   background-size:cover;
	// }
	// .v-buttons .active {
	//   opacity: 1;
	// }
	// .v-buttons button:nth-child(1) { background-position: 0px 0; }
	// .v-buttons button:nth-child(2) { background-position: 0px -44px; }
	// .v-buttons button:nth-child(3) { background-position: 0px -88px; }
	// .v-buttons button:nth-child(4) { background-position: 0px -132px; }
	// .v-buttons button:nth-child(5) { background-position: 0px -176px; }
	// /*.v-buttons button:nth-child(6) { background-position: 0px -220px; }*/
	// .v-buttons button:nth-child(6) { background-position: 0px -264px; }
	// .v-buttons button.logo{
	//   background-image: url('./SYA.png');
	//   background-size:cover;
	//   position: relative;
	// }
	// .logo:hover{
	//   opacity: 1;
	// }
	// .slogan {
	//   position: absolute;
	//   width: 150px;
	//   opacity: 0;
	//   left: 40px;
	//   top: -36px;
	//   transition:0.5s;
	// }
	// .logo:hover .slogan{
	//   display: block;
	//   top: -11px;
	//   opacity: 1;
	// }
	// .support {
	//   position: absolute;
	//   width: 150px;
	//   opacity: 0;
	//   left: 120px;
	//   top: -15px;
	//   transition:0.5s;
	// }
	// .logo:hover .support{
	//   display: block;
	//   left:180px;
	//   opacity: 1;
	// }
	// </style>
	// <script>
	module.exports = {
	  data: function data() {
	    return {
	      store: __webpack_require__(13),
	      current: ''
	    };
	  },
	  methods: {
	    changeSituation: function changeSituation() {
	      this.store.situation = ({
	        'garage': 'ground',
	        'ground': 'lab',
	        'lab': 'garage'
	      })[this.store.situation];
	    },
	    click: function click() {
	      if (this.current === 'selector') {
	        this.current = '';
	      }
	    },
	    toggleCurrent: function toggleCurrent(current) {
	      this.current = this.current === current ? '' : current;
	    },
	    close: function close() {
	      if (location.hash[0] == '#') {
	        location.href = location.hash.slice(1) + '#close';
	      } else {
	        window.close();
	      }
	    }
	  },
	  components: {
	    vehicleSelector: __webpack_require__(68),
	    vehicleRemolder: __webpack_require__(80)
	  },
	  watch: {
	    current: function current(value) {
	      this.store.hoverEnabled = value !== 'selector';
	    },
	    'store.currentPartName': function storeCurrentPartName(value) {
	      if (value) this.current = 'remolder';
	    }
	  }
	};
	// </script>

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(69)
	module.exports = __webpack_require__(71)

	if (module.exports.__esModule) module.exports = module.exports.default
	;(typeof module.exports === "function" ? module.exports.options : module.exports).template = __webpack_require__(79)
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/bradpitt/Documents/front/carFitting/src/interact/selector/index.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
	  }
	})()}

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(70);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(66)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-895642f8&file=index.vue!./../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./index.vue", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-895642f8&file=index.vue!./../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./index.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(63)();
	// imports


	// module
	exports.push([module.id, ".brands-scroller {\n  top: 100px;\n  left: 70px;\n}\n.vehicles-scroller {\n  top: 100px;\n  left: 300px;\n}", ""]);

	// exports


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// <template>
	//   <div class="v-scroll">
	//     <component is="scroller" :items="brands"
	//       :current-item.sync="currentBrand"
	//       class="brands-scroller"></component>
	//     <component is="scroller" :items="currentBrand.vehicles"
	//       :current-item.sync="currentVehicle"
	//       class="vehicles-scroller"></component>
	//   </div>
	// </template>

	// <style>

	// .brands-scroller {
	//   top: 100px;
	//   left: 70px;
	// }
	// .vehicles-scroller {
	//   top: 100px;
	//   left: 300px;
	// }

	// </style>

	// <script>
	var Vue = __webpack_require__(12);
	var _data = {
	  store: __webpack_require__(13),
	  brands: __webpack_require__(72)
	};

	_data.currentBrand = _data.brands[0];
	_data.currentVehicle = _data.currentBrand.vehicles[0];

	module.exports = {
	  data: function data() {
	    return _data;
	  },
	  methods: {
	    stopped: function stopped() {
	      console.log('stopped');
	    }
	  },
	  components: {
	    scroller: __webpack_require__(73)
	  },
	  watch: {
	    currentVehicle: function currentVehicle(vehicle) {
	      this.store.chassis.name = vehicle.id;
	    }
	  }
	};

	// </script>

/***/ },
/* 72 */
/***/ function(module, exports) {

	module.exports = [
		{
			"id": "Audi",
			"html": "<img class='icon' src='icons/audi.png'>奥迪<br><small>Audi</small>",
			"vehicles": [
				{
					"id": "a3",
					"html": "奥迪A3<br><small>Audi A3</small>"
				},
				{
					"id": "a4",
					"html": "奥迪A4L<br><small>Audi A4L</small>"
				},
				{
					"id": "a5",
					"html": "奥迪A5<br><small>Audi A5</small>"
				},
				{
					"id": "tt",
					"html": "奥迪TT<br><small>Audi TT</small>"
				}
			]
		},
		{
			"id": "BMW",
			"html": "<img class='icon' src='icons/bmw.png'>宝马<br><small>BMW</small>",
			"vehicles": [
				{
					"id": "bmw3",
					"html": "宝马3系<br><small>BMW 3-Serie</small>"
				},
				{
					"id": "bmw5",
					"html": "宝马5系<br><small>BMW 5-Serie</small>"
				}
			]
		},
		{
			"id": "Porsche",
			"html": "<img class='icon' src='icons/porsche.png'>保时捷<br><small>Porsche</small>",
			"vehicles": [
				{
					"id": "panamera",
					"html": "Panamera<br><small>Panamera</small>"
				},
				{
					"id": "macan",
					"html": "Macan<br><small>Macan</small>"
				},
				{
					"id": "cayenne",
					"html": "卡宴<br><small>Cayenne</small>"
				},
				{
					"id": "cayenne2015",
					"html": "卡宴 2015<br><small>Cayenne 2015</small>"
				}
			]
		},
		{
			"id": "Mercedes-Benz",
			"html": "<img class='icon' src='icons/mercedes.png'>奔驰<br><small>Mercedes-Benz</small>",
			"vehicles": [
				{
					"id": "c",
					"html": "奔驰C级<br><small>MB C-Class</small>"
				},
				{
					"id": "e",
					"html": "奔驰E级<br><small>MB E-Class</small>"
				},
				{
					"id": "cla",
					"html": "奔驰CLA级<br><small>MB CLA-Class</small>"
				}
			]
		},
		{
			"id": "Honda",
			"html": "<img class='icon' src='icons/honda.png'>本田<br><small>Honda</small>",
			"vehicles": [
				{
					"id": "civic",
					"html": "思域<br><small>Civic</small>"
				},
				{
					"id": "spirior",
					"html": "思铂睿<br><small>Spirior</small>"
				}
			]
		},
		{
			"id": "Buick",
			"html": "<img class='icon' src='icons/buick.png'>别克<br><small>Buick</small>",
			"vehicles": [
				{
					"id": "regal",
					"html": "君威<br><small>Regal</small>"
				}
			]
		},
		{
			"id": "Volkswagen",
			"html": "<img class='icon' src='icons/vw.png'>大众<br><small>Volkswagen</small>",
			"vehicles": [
				{
					"id": "golf",
					"html": "高尔夫<br><small>Golf</small>"
				},
				{
					"id": "cc",
					"html": "CC<br><small>CC</small>"
				},
				{
					"id": "beetle",
					"html": "甲壳虫<br><small>Beetle</small>"
				},
				{
					"id": "scirocco",
					"html": "尚酷<br><small>Scirocco</small>"
				}
			]
		},
		{
			"id": "Toyota",
			"html": "<img class='icon' src='icons/toyota.png'>丰田<br><small>Toyota</small>",
			"vehicles": [
				{
					"id": "reiz",
					"html": "锐志<br><small>Reiz</small>"
				},
				{
					"id": "camry",
					"html": "凯美瑞<br><small>Camry</small>"
				}
			]
		},
		{
			"id": "Ford",
			"html": "<img class='icon' src='icons/ford.png'>福特<br><small>Ford</small>",
			"vehicles": [
				{
					"id": "mondeo",
					"html": "蒙迪欧<br><small>Mondeo</small>"
				},
				{
					"id": "focus",
					"html": "福克斯<br><small>Focus</small>"
				}
			]
		},
		{
			"id": "Jaguar",
			"html": "<img class='icon' src='icons/jaguar.png'>捷豹<br><small>Jaguar</small>",
			"vehicles": [
				{
					"id": "xf",
					"html": "XF<br><small>XF</small>"
				},
				{
					"id": "xj",
					"html": "XJ<br><small>XJ</small>"
				}
			]
		},
		{
			"id": "Cadillac",
			"html": "<img class='icon' src='icons/cadillac.png'>凯迪拉克<br><small>Cadillac</small>",
			"vehicles": [
				{
					"id": "ats",
					"html": "ATS-L<br><small>ATS-L</small>"
				},
				{
					"id": "cts",
					"html": "CTS<br><small>CTS</small>"
				}
			]
		},
		{
			"id": "Lexus",
			"html": "<img class='icon' src='icons/lexus.png'>雷克萨斯<br><small>Lexus</small>",
			"vehicles": [
				{
					"id": "ct",
					"html": "CT<br><small>CT</small>"
				},
				{
					"id": "is",
					"html": "IS<br><small>IS</small>"
				}
			]
		},
		{
			"id": "Land Rover",
			"html": "<img class='icon' src='icons/landrover.png'>路虎<br><small>Land Rover</small>",
			"vehicles": [
				{
					"id": "evoque",
					"html": "极光<br><small>Evoque</small>"
				}
			]
		},
		{
			"id": "Mazda",
			"html": "<img class='icon' src='icons/mazda.png'>马自达<br><small>Mazda</small>",
			"vehicles": [
				{
					"id": "mazda6",
					"html": "马自达6<br><small>Mazda 6</small>"
				},
				{
					"id": "atenza",
					"html": "阿特兹<br><small>Atenza</small>"
				}
			]
		},
		{
			"id": "Maserati",
			"html": "<img class='icon' src='icons/maserati.png'>玛莎拉蒂<br><small>Maserati</small>",
			"vehicles": [
				{
					"id": "ghibili",
					"html": "Ghibili<br><small>Ghibili</small>"
				}
			]
		},
		{
			"id": "MINI",
			"html": "<img class='icon' src='icons/mini.png'>MINI<br><small>MINI</small>",
			"vehicles": [
				{
					"id": "cooper",
					"html": "Clubman<br><small>Clubman</small>"
				},
				{
					"id": "countryman",
					"html": "Countryman<br><small>Countryman</small>"
				}
			]
		},
		{
			"id": "KIA",
			"html": "<img class='icon' src='icons/kia.png'>起亚<br><small>KIA</small>",
			"vehicles": [
				{
					"id": "k5",
					"html": "K5<br><small>K5</small>"
				}
			]
		},
		{
			"id": "Nissan",
			"html": "<img class='icon' src='icons/nissan.png'>日产<br><small>Nissan</small>",
			"vehicles": [
				{
					"id": "gtr",
					"html": "GT-R<br><small>GT-R</small>"
				}
			]
		},
		{
			"id": "Rohens",
			"html": "<img class='icon' src='icons/rohens.png'>劳恩斯<br><small>Rohens</small>",
			"vehicles": [
				{
					"id": "coupe",
					"html": "酷派<br><small>Coupe</small>"
				}
			]
		},
		{
			"id": "Mitsubishi",
			"html": "<img class='icon' src='icons/mitsubishi.png'>三菱<br><small>Mitsubishi</small>",
			"vehicles": [
				{
					"id": "lancer",
					"html": "翼神<br><small>Lancer EX</small>"
				}
			]
		},
		{
			"id": "Smart",
			"html": "<img class='icon' src='icons/smart.png'>Smart<br><small>Smart</small>",
			"vehicles": [
				{
					"id": "smart",
					"html": "For Two<br><small>For Two</small>"
				}
			]
		},
		{
			"id": "Hyundai",
			"html": "<img class='icon' src='icons/hyundai.png'>现代<br><small>Hyundai</small>",
			"vehicles": [
				{
					"id": "sonata",
					"html": "索纳塔9<br><small>Sonata 9</small>"
				}
			]
		},
		{
			"id": "Chevrolet",
			"html": "<img class='icon' src='icons/chevrolet.png'>雪佛兰<br><small>Chevrolet</small>",
			"vehicles": [
				{
					"id": "cruze",
					"html": "科鲁兹<br><small>Cruze</small>"
				},
				{
					"id": "malibu",
					"html": "迈锐宝<br><small>Malibu</small>"
				}
			]
		},
		{
			"id": "Infiniti",
			"html": "<img class='icon' src='icons/infiniti.png'>英菲尼迪<br><small>Infiniti</small>",
			"vehicles": [
				{
					"id": "q50l",
					"html": "Q50L<br><small>Q50L</small>"
				}
			]
		}
	];

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(74)
	module.exports = __webpack_require__(76)

	if (module.exports.__esModule) module.exports = module.exports.default
	;(typeof module.exports === "function" ? module.exports.options : module.exports).template = __webpack_require__(78)
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/bradpitt/Documents/front/carFitting/src/interact/selector/scroller/index.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
	  }
	})()}

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(75);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(66)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-a77dc80a&file=index.vue!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./index.vue", function() {
				var newContent = require("!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-a77dc80a&file=index.vue!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./index.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(63)();
	// imports


	// module
	exports.push([module.id, ".v-scroller {\n  position: absolute;\n  overflow: hidden;\n  height: 540px;\n  background-image: -webkit-linear-gradient(top,\n    transparent 0%, rgba(0,0,0,0.6) 50%, transparent 100%);\n  background-image: linear-gradient(to bottom,\n    transparent 0%, rgba(0,0,0,0.6) 50%, transparent 100%);\n  -webkit-mask-image: -webkit-linear-gradient(top,\n    transparent 0%, black 50%, transparent 100%);\n          mask-image: linear-gradient(to bottom,\n    transparent 0%, black 50%, transparent 100%);\n  color: #F5D96C;\n  font-size: 20px;\n  text-align: center;\n  line-height: 1.25;\n}\n\n.v-scroller::before,\n.v-scroller::after {\n  content: '';\n  position: absolute;\n  height: 1px;\n  width: 30px;\n  display: block;\n  top: 50%;\n  margin-top: -5px;\n  background-color: currentColor;\n}\n\n.v-scroller::before { left: 0; }\n.v-scroller::after { right: 0; }\n\n.v-scroller > div {\n  position: relative;\n  height: 60px;\n  border-top: 240px solid transparent;\n  border-bottom: 240px solid transparent;\n}\n\n.v-scroller li {\n  width: 220px;\n  height: 60px;\n  cursor: pointer;\n  position: relative;\n}\n\n.v-scroller small {\n  font-size: 80%;\n}\n.v-scroller img.icon{\n  position: absolute;\n    width: 30px;\n    left: 40px;\n}\n.v-scroller img.lock{\n  position: absolute;\n    width: 22px;\n    top: 0;\n    right: 30px;\n}", ""]);

	// exports


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// <template>
	// <div class="v-scroller" @mousedown.stop @touchstart.stop @click.stop>
	//   <div v-el:wrapper>
	//     <ul>
	//       <li v-if="!item.lock" v-for="item in items" v-html="item.html" @click="currentItem = item"></li>
	//       <li v-if="item.lock" v-for="item in items" v-html="item.html" @click="note"
	//         ></li>
	//     </ul>
	//   </div>
	// </div>
	// </template>

	// <style>

	// .v-scroller {
	//   position: absolute;
	//   overflow: hidden;
	//   height: 540px;
	//   background-image: linear-gradient(to bottom,
	//     transparent 0%, rgba(0,0,0,0.6) 50%, transparent 100%);
	//   mask-image: linear-gradient(to bottom,
	//     transparent 0%, black 50%, transparent 100%);
	//   color: #F5D96C;
	//   font-size: 20px;
	//   text-align: center;
	//   line-height: 1.25;
	// }

	// .v-scroller::before,
	// .v-scroller::after {
	//   content: '';
	//   position: absolute;
	//   height: 1px;
	//   width: 30px;
	//   display: block;
	//   top: 50%;
	//   margin-top: -5px;
	//   background-color: currentColor;
	// }

	// .v-scroller::before { left: 0; }
	// .v-scroller::after { right: 0; }

	// .v-scroller > div {
	//   position: relative;
	//   height: 60px;
	//   border-top: 240px solid transparent;
	//   border-bottom: 240px solid transparent;
	// }

	// .v-scroller li {
	//   width: 220px;
	//   height: 60px;
	//   cursor: pointer;
	//   position: relative;
	// }

	// .v-scroller small {
	//   font-size: 80%;
	// }
	// .v-scroller img.icon{
	//   position: absolute;
	//     width: 30px;
	//     left: 40px;
	// }
	// .v-scroller img.lock{
	//   position: absolute;
	//     width: 22px;
	//     top: 0;
	//     right: 30px;
	// }

	// </style>

	// <script>
	var IScroll = __webpack_require__(77);

	var vm = module.exports = {
	  props: {
	    items: {
	      type: Array,
	      required: true
	    },
	    currentItem: {
	      twoWay: true,
	      required: true
	    }
	  },
	  computed: {
	    currentIndex: function currentIndex() {
	      return this.items.indexOf(this.currentItem);
	    }
	  },
	  watch: {
	    items: function items() {
	      var _this = this;

	      this.$nextTick(function () {
	        return _this.refresh();
	      });
	    },
	    currentItem: function currentItem() {
	      var _this2 = this;

	      this.$nextTick(function () {
	        return _this2.$data.$iScroll.goToPage(0, _this2.currentIndex);
	      });
	    }
	  },
	  ready: function ready() {
	    var _this3 = this;

	    this.$nextTick(function () {
	      return _this3.refresh();
	    });
	  },

	  methods: {
	    refresh: function refresh() {
	      var _this4 = this;

	      if (this.$data.$iScroll != null) {
	        this.$data.$iScroll.destroy();
	      }
	      this.$data.$iScroll = new IScroll(this.$els.wrapper, {
	        mouseWheel: true,
	        snap: true,
	        bindToWrapper: true
	      });
	      this.$data.$iScroll.on('scrollEnd', function (e) {
	        var index = _this4.$data.$iScroll.currentPage.pageY;
	        //线上版
	        if (!_this4.items[index].lock) _this4.currentItem = _this4.items[index];
	      });
	      this.$data.$iScroll.goToPage(0, this.currentIndex, 0);
	    },

	    note: function note() {
	      var note = document.querySelector('#notification');
	      note.style.display = 'block';
	    }
	  }
	};
	var note = document.querySelector('#notification');
	note.addEventListener('click', function (e) {
	  e.stopPropagation();
	  note.style.display = 'none';
	});

	// </script>

/***/ },
/* 77 */
/***/ function(module, exports) {

	/*! iScroll v5.1.3 ~ (c) 2008-2014 Matteo Spinelli ~ http://cubiq.org/license */
	(function (window, document, Math) {
	var rAF = window.requestAnimationFrame	||
		window.webkitRequestAnimationFrame	||
		window.mozRequestAnimationFrame		||
		window.oRequestAnimationFrame		||
		window.msRequestAnimationFrame		||
		function (callback) { window.setTimeout(callback, 1000 / 60); };

	var utils = (function () {
		var me = {};

		var _elementStyle = document.createElement('div').style;
		var _vendor = (function () {
			var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
				transform,
				i = 0,
				l = vendors.length;

			for ( ; i < l; i++ ) {
				transform = vendors[i] + 'ransform';
				if ( transform in _elementStyle ) return vendors[i].substr(0, vendors[i].length-1);
			}

			return false;
		})();

		function _prefixStyle (style) {
			if ( _vendor === false ) return false;
			if ( _vendor === '' ) return style;
			return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
		}

		me.getTime = Date.now || function getTime () { return new Date().getTime(); };

		me.extend = function (target, obj) {
			for ( var i in obj ) {
				target[i] = obj[i];
			}
		};

		me.addEvent = function (el, type, fn, capture) {
			el.addEventListener(type, fn, !!capture);
		};

		me.removeEvent = function (el, type, fn, capture) {
			el.removeEventListener(type, fn, !!capture);
		};

		me.prefixPointerEvent = function (pointerEvent) {
			return window.MSPointerEvent ? 
				'MSPointer' + pointerEvent.charAt(9).toUpperCase() + pointerEvent.substr(10):
				pointerEvent;
		};

		me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
			var distance = current - start,
				speed = Math.abs(distance) / time,
				destination,
				duration;

			deceleration = deceleration === undefined ? 0.0006 : deceleration;

			destination = current + ( speed * speed ) / ( 2 * deceleration ) * ( distance < 0 ? -1 : 1 );
			duration = speed / deceleration;

			if ( destination < lowerMargin ) {
				destination = wrapperSize ? lowerMargin - ( wrapperSize / 2.5 * ( speed / 8 ) ) : lowerMargin;
				distance = Math.abs(destination - current);
				duration = distance / speed;
			} else if ( destination > 0 ) {
				destination = wrapperSize ? wrapperSize / 2.5 * ( speed / 8 ) : 0;
				distance = Math.abs(current) + destination;
				duration = distance / speed;
			}

			return {
				destination: Math.round(destination),
				duration: duration
			};
		};

		var _transform = _prefixStyle('transform');

		me.extend(me, {
			hasTransform: _transform !== false,
			hasPerspective: _prefixStyle('perspective') in _elementStyle,
			hasTouch: 'ontouchstart' in window,
			hasPointer: window.PointerEvent || window.MSPointerEvent, // IE10 is prefixed
			hasTransition: _prefixStyle('transition') in _elementStyle
		});

		// This should find all Android browsers lower than build 535.19 (both stock browser and webview)
		me.isBadAndroid = /Android /.test(window.navigator.appVersion) && !(/Chrome\/\d/.test(window.navigator.appVersion));

		me.extend(me.style = {}, {
			transform: _transform,
			transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
			transitionDuration: _prefixStyle('transitionDuration'),
			transitionDelay: _prefixStyle('transitionDelay'),
			transformOrigin: _prefixStyle('transformOrigin')
		});

		me.hasClass = function (e, c) {
			var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
			return re.test(e.className);
		};

		me.addClass = function (e, c) {
			if ( me.hasClass(e, c) ) {
				return;
			}

			var newclass = e.className.split(' ');
			newclass.push(c);
			e.className = newclass.join(' ');
		};

		me.removeClass = function (e, c) {
			if ( !me.hasClass(e, c) ) {
				return;
			}

			var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
			e.className = e.className.replace(re, ' ');
		};

		me.offset = function (el) {
			var left = -el.offsetLeft,
				top = -el.offsetTop;

			// jshint -W084
			while (el = el.offsetParent) {
				left -= el.offsetLeft;
				top -= el.offsetTop;
			}
			// jshint +W084

			return {
				left: left,
				top: top
			};
		};

		me.preventDefaultException = function (el, exceptions) {
			for ( var i in exceptions ) {
				if ( exceptions[i].test(el[i]) ) {
					return true;
				}
			}

			return false;
		};

		me.extend(me.eventType = {}, {
			touchstart: 1,
			touchmove: 1,
			touchend: 1,

			mousedown: 2,
			mousemove: 2,
			mouseup: 2,

			pointerdown: 3,
			pointermove: 3,
			pointerup: 3,

			MSPointerDown: 3,
			MSPointerMove: 3,
			MSPointerUp: 3
		});

		me.extend(me.ease = {}, {
			quadratic: {
				style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
				fn: function (k) {
					return k * ( 2 - k );
				}
			},
			circular: {
				style: 'cubic-bezier(0.1, 0.57, 0.1, 1)',	// Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
				fn: function (k) {
					return Math.sqrt( 1 - ( --k * k ) );
				}
			},
			back: {
				style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
				fn: function (k) {
					var b = 4;
					return ( k = k - 1 ) * k * ( ( b + 1 ) * k + b ) + 1;
				}
			},
			bounce: {
				style: '',
				fn: function (k) {
					if ( ( k /= 1 ) < ( 1 / 2.75 ) ) {
						return 7.5625 * k * k;
					} else if ( k < ( 2 / 2.75 ) ) {
						return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;
					} else if ( k < ( 2.5 / 2.75 ) ) {
						return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;
					} else {
						return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;
					}
				}
			},
			elastic: {
				style: '',
				fn: function (k) {
					var f = 0.22,
						e = 0.4;

					if ( k === 0 ) { return 0; }
					if ( k == 1 ) { return 1; }

					return ( e * Math.pow( 2, - 10 * k ) * Math.sin( ( k - f / 4 ) * ( 2 * Math.PI ) / f ) + 1 );
				}
			}
		});

		me.tap = function (e, eventName) {
			var ev = document.createEvent('Event');
			ev.initEvent(eventName, true, true);
			ev.pageX = e.pageX;
			ev.pageY = e.pageY;
			e.target.dispatchEvent(ev);
		};

		me.click = function (e) {
			var target = e.target,
				ev;

			if ( !(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName) ) {
				ev = document.createEvent('MouseEvents');
				ev.initMouseEvent('click', true, true, e.view, 1,
					target.screenX, target.screenY, target.clientX, target.clientY,
					e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
					0, null);

				ev._constructed = true;
				target.dispatchEvent(ev);
			}
		};

		return me;
	})();

	function IScroll (el, options) {
		this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
		this.scroller = this.wrapper.children[0];
		this.scrollerStyle = this.scroller.style;		// cache style for better performance

		this.options = {

			resizeScrollbars: true,

			mouseWheelSpeed: 20,

			snapThreshold: 0.334,

	// INSERT POINT: OPTIONS 

			startX: 0,
			startY: 0,
			scrollY: true,
			directionLockThreshold: 5,
			momentum: true,

			bounce: true,
			bounceTime: 600,
			bounceEasing: '',

			preventDefault: true,
			preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ },

			HWCompositing: true,
			useTransition: true,
			useTransform: true
		};

		for ( var i in options ) {
			this.options[i] = options[i];
		}

		// Normalize options
		this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

		this.options.useTransition = utils.hasTransition && this.options.useTransition;
		this.options.useTransform = utils.hasTransform && this.options.useTransform;

		this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
		this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

		// If you want eventPassthrough I have to lock one of the axes
		this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
		this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

		// With eventPassthrough we also need lockDirection mechanism
		this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
		this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

		this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

		this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

		if ( this.options.tap === true ) {
			this.options.tap = 'tap';
		}

		if ( this.options.shrinkScrollbars == 'scale' ) {
			this.options.useTransition = false;
		}

		this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

	// INSERT POINT: NORMALIZATION

		// Some defaults	
		this.x = 0;
		this.y = 0;
		this.directionX = 0;
		this.directionY = 0;
		this._events = {};

	// INSERT POINT: DEFAULTS

		this._init();
		this.refresh();

		this.scrollTo(this.options.startX, this.options.startY);
		this.enable();
	}

	IScroll.prototype = {
		version: '5.1.3',

		_init: function () {
			this._initEvents();

			if ( this.options.scrollbars || this.options.indicators ) {
				this._initIndicators();
			}

			if ( this.options.mouseWheel ) {
				this._initWheel();
			}

			if ( this.options.snap ) {
				this._initSnap();
			}

			if ( this.options.keyBindings ) {
				this._initKeys();
			}

	// INSERT POINT: _init

		},

		destroy: function () {
			this._initEvents(true);

			this._execEvent('destroy');
		},

		_transitionEnd: function (e) {
			if ( e.target != this.scroller || !this.isInTransition ) {
				return;
			}

			this._transitionTime();
			if ( !this.resetPosition(this.options.bounceTime) ) {
				this.isInTransition = false;
				this._execEvent('scrollEnd');
			}
		},

		_start: function (e) {
			// React to left mouse button only
			if ( utils.eventType[e.type] != 1 ) {
				if ( e.button !== 0 ) {
					return;
				}
			}

			if ( !this.enabled || (this.initiated && utils.eventType[e.type] !== this.initiated) ) {
				return;
			}

			if ( this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
				pos;

			this.initiated	= utils.eventType[e.type];
			this.moved		= false;
			this.distX		= 0;
			this.distY		= 0;
			this.directionX = 0;
			this.directionY = 0;
			this.directionLocked = 0;

			this._transitionTime();

			this.startTime = utils.getTime();

			if ( this.options.useTransition && this.isInTransition ) {
				this.isInTransition = false;
				pos = this.getComputedPosition();
				this._translate(Math.round(pos.x), Math.round(pos.y));
				this._execEvent('scrollEnd');
			} else if ( !this.options.useTransition && this.isAnimating ) {
				this.isAnimating = false;
				this._execEvent('scrollEnd');
			}

			this.startX    = this.x;
			this.startY    = this.y;
			this.absStartX = this.x;
			this.absStartY = this.y;
			this.pointX    = point.pageX;
			this.pointY    = point.pageY;

			this._execEvent('beforeScrollStart');
		},

		_move: function (e) {
			if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
				return;
			}

			if ( this.options.preventDefault ) {	// increases performance on Android? TODO: check!
				e.preventDefault();
			}

			var point		= e.touches ? e.touches[0] : e,
				deltaX		= point.pageX - this.pointX,
				deltaY		= point.pageY - this.pointY,
				timestamp	= utils.getTime(),
				newX, newY,
				absDistX, absDistY;

			this.pointX		= point.pageX;
			this.pointY		= point.pageY;

			this.distX		+= deltaX;
			this.distY		+= deltaY;
			absDistX		= Math.abs(this.distX);
			absDistY		= Math.abs(this.distY);

			// We need to move at least 10 pixels for the scrolling to initiate
			if ( timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10) ) {
				return;
			}

			// If you are scrolling in one direction lock the other
			if ( !this.directionLocked && !this.options.freeScroll ) {
				if ( absDistX > absDistY + this.options.directionLockThreshold ) {
					this.directionLocked = 'h';		// lock horizontally
				} else if ( absDistY >= absDistX + this.options.directionLockThreshold ) {
					this.directionLocked = 'v';		// lock vertically
				} else {
					this.directionLocked = 'n';		// no lock
				}
			}

			if ( this.directionLocked == 'h' ) {
				if ( this.options.eventPassthrough == 'vertical' ) {
					e.preventDefault();
				} else if ( this.options.eventPassthrough == 'horizontal' ) {
					this.initiated = false;
					return;
				}

				deltaY = 0;
			} else if ( this.directionLocked == 'v' ) {
				if ( this.options.eventPassthrough == 'horizontal' ) {
					e.preventDefault();
				} else if ( this.options.eventPassthrough == 'vertical' ) {
					this.initiated = false;
					return;
				}

				deltaX = 0;
			}

			deltaX = this.hasHorizontalScroll ? deltaX : 0;
			deltaY = this.hasVerticalScroll ? deltaY : 0;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			// Slow down if outside of the boundaries
			if ( newX > 0 || newX < this.maxScrollX ) {
				newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
			}
			if ( newY > 0 || newY < this.maxScrollY ) {
				newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
			}

			this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
			this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

			if ( !this.moved ) {
				this._execEvent('scrollStart');
			}

			this.moved = true;

			this._translate(newX, newY);

	/* REPLACE START: _move */

			if ( timestamp - this.startTime > 300 ) {
				this.startTime = timestamp;
				this.startX = this.x;
				this.startY = this.y;
			}

	/* REPLACE END: _move */

		},

		_end: function (e) {
			if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
				return;
			}

			if ( this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {
				e.preventDefault();
			}

			var point = e.changedTouches ? e.changedTouches[0] : e,
				momentumX,
				momentumY,
				duration = utils.getTime() - this.startTime,
				newX = Math.round(this.x),
				newY = Math.round(this.y),
				distanceX = Math.abs(newX - this.startX),
				distanceY = Math.abs(newY - this.startY),
				time = 0,
				easing = '';

			this.isInTransition = 0;
			this.initiated = 0;
			this.endTime = utils.getTime();

			// reset if we are outside of the boundaries
			if ( this.resetPosition(this.options.bounceTime) ) {
				return;
			}

			this.scrollTo(newX, newY);	// ensures that the last position is rounded

			// we scrolled less than 10 pixels
			if ( !this.moved ) {
				if ( this.options.tap ) {
					utils.tap(e, this.options.tap);
				}

				if ( this.options.click ) {
					utils.click(e);
				}

				this._execEvent('scrollCancel');
				return;
			}

			if ( this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100 ) {
				this._execEvent('flick');
				return;
			}

			// start momentum animation if needed
			if ( this.options.momentum && duration < 300 ) {
				momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
				momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
				newX = momentumX.destination;
				newY = momentumY.destination;
				time = Math.max(momentumX.duration, momentumY.duration);
				this.isInTransition = 1;
			}


			if ( this.options.snap ) {
				var snap = this._nearestSnap(newX, newY);
				this.currentPage = snap;
				time = this.options.snapSpeed || Math.max(
						Math.max(
							Math.min(Math.abs(newX - snap.x), 1000),
							Math.min(Math.abs(newY - snap.y), 1000)
						), 300);
				newX = snap.x;
				newY = snap.y;

				this.directionX = 0;
				this.directionY = 0;
				easing = this.options.bounceEasing;
			}

	// INSERT POINT: _end

			if ( newX != this.x || newY != this.y ) {
				// change easing function when scroller goes out of the boundaries
				if ( newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY ) {
					easing = utils.ease.quadratic;
				}

				this.scrollTo(newX, newY, time, easing);
				return;
			}

			this._execEvent('scrollEnd');
		},

		_resize: function () {
			var that = this;

			clearTimeout(this.resizeTimeout);

			this.resizeTimeout = setTimeout(function () {
				that.refresh();
			}, this.options.resizePolling);
		},

		resetPosition: function (time) {
			var x = this.x,
				y = this.y;

			time = time || 0;

			if ( !this.hasHorizontalScroll || this.x > 0 ) {
				x = 0;
			} else if ( this.x < this.maxScrollX ) {
				x = this.maxScrollX;
			}

			if ( !this.hasVerticalScroll || this.y > 0 ) {
				y = 0;
			} else if ( this.y < this.maxScrollY ) {
				y = this.maxScrollY;
			}

			if ( x == this.x && y == this.y ) {
				return false;
			}

			this.scrollTo(x, y, time, this.options.bounceEasing);

			return true;
		},

		disable: function () {
			this.enabled = false;
		},

		enable: function () {
			this.enabled = true;
		},

		refresh: function () {
			var rf = this.wrapper.offsetHeight;		// Force reflow

			this.wrapperWidth	= this.wrapper.clientWidth;
			this.wrapperHeight	= this.wrapper.clientHeight;

	/* REPLACE START: refresh */

			this.scrollerWidth	= this.scroller.offsetWidth;
			this.scrollerHeight	= this.scroller.offsetHeight;

			this.maxScrollX		= this.wrapperWidth - this.scrollerWidth;
			this.maxScrollY		= this.wrapperHeight - this.scrollerHeight;

	/* REPLACE END: refresh */

			this.hasHorizontalScroll	= this.options.scrollX && this.maxScrollX < 0;
			this.hasVerticalScroll		= this.options.scrollY && this.maxScrollY < 0;

			if ( !this.hasHorizontalScroll ) {
				this.maxScrollX = 0;
				this.scrollerWidth = this.wrapperWidth;
			}

			if ( !this.hasVerticalScroll ) {
				this.maxScrollY = 0;
				this.scrollerHeight = this.wrapperHeight;
			}

			this.endTime = 0;
			this.directionX = 0;
			this.directionY = 0;

			this.wrapperOffset = utils.offset(this.wrapper);

			this._execEvent('refresh');

			this.resetPosition();

	// INSERT POINT: _refresh

		},

		on: function (type, fn) {
			if ( !this._events[type] ) {
				this._events[type] = [];
			}

			this._events[type].push(fn);
		},

		off: function (type, fn) {
			if ( !this._events[type] ) {
				return;
			}

			var index = this._events[type].indexOf(fn);

			if ( index > -1 ) {
				this._events[type].splice(index, 1);
			}
		},

		_execEvent: function (type) {
			if ( !this._events[type] ) {
				return;
			}

			var i = 0,
				l = this._events[type].length;

			if ( !l ) {
				return;
			}

			for ( ; i < l; i++ ) {
				this._events[type][i].apply(this, [].slice.call(arguments, 1));
			}
		},

		scrollBy: function (x, y, time, easing) {
			x = this.x + x;
			y = this.y + y;
			time = time || 0;

			this.scrollTo(x, y, time, easing);
		},

		scrollTo: function (x, y, time, easing) {
			easing = easing || utils.ease.circular;

			this.isInTransition = this.options.useTransition && time > 0;

			if ( !time || (this.options.useTransition && easing.style) ) {
				this._transitionTimingFunction(easing.style);
				this._transitionTime(time);
				this._translate(x, y);
			} else {
				this._animate(x, y, time, easing.fn);
			}
		},

		scrollToElement: function (el, time, offsetX, offsetY, easing) {
			el = el.nodeType ? el : this.scroller.querySelector(el);

			if ( !el ) {
				return;
			}

			var pos = utils.offset(el);

			pos.left -= this.wrapperOffset.left;
			pos.top  -= this.wrapperOffset.top;

			// if offsetX/Y are true we center the element to the screen
			if ( offsetX === true ) {
				offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
			}
			if ( offsetY === true ) {
				offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
			}

			pos.left -= offsetX || 0;
			pos.top  -= offsetY || 0;

			pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
			pos.top  = pos.top  > 0 ? 0 : pos.top  < this.maxScrollY ? this.maxScrollY : pos.top;

			time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x-pos.left), Math.abs(this.y-pos.top)) : time;

			this.scrollTo(pos.left, pos.top, time, easing);
		},

		_transitionTime: function (time) {
			time = time || 0;

			this.scrollerStyle[utils.style.transitionDuration] = time + 'ms';

			if ( !time && utils.isBadAndroid ) {
				this.scrollerStyle[utils.style.transitionDuration] = '0.001s';
			}


			if ( this.indicators ) {
				for ( var i = this.indicators.length; i--; ) {
					this.indicators[i].transitionTime(time);
				}
			}


	// INSERT POINT: _transitionTime

		},

		_transitionTimingFunction: function (easing) {
			this.scrollerStyle[utils.style.transitionTimingFunction] = easing;


			if ( this.indicators ) {
				for ( var i = this.indicators.length; i--; ) {
					this.indicators[i].transitionTimingFunction(easing);
				}
			}


	// INSERT POINT: _transitionTimingFunction

		},

		_translate: function (x, y) {
			if ( this.options.useTransform ) {

	/* REPLACE START: _translate */

				this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

	/* REPLACE END: _translate */

			} else {
				x = Math.round(x);
				y = Math.round(y);
				this.scrollerStyle.left = x + 'px';
				this.scrollerStyle.top = y + 'px';
			}

			this.x = x;
			this.y = y;


		if ( this.indicators ) {
			for ( var i = this.indicators.length; i--; ) {
				this.indicators[i].updatePosition();
			}
		}


	// INSERT POINT: _translate

		},

		_initEvents: function (remove) {
			var eventType = remove ? utils.removeEvent : utils.addEvent,
				target = this.options.bindToWrapper ? this.wrapper : window;

			eventType(window, 'orientationchange', this);
			eventType(window, 'resize', this);

			if ( this.options.click ) {
				eventType(this.wrapper, 'click', this, true);
			}

			if ( !this.options.disableMouse ) {
				eventType(this.wrapper, 'mousedown', this);
				eventType(target, 'mousemove', this);
				eventType(target, 'mousecancel', this);
				eventType(target, 'mouseup', this);
			}

			if ( utils.hasPointer && !this.options.disablePointer ) {
				eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
				eventType(target, utils.prefixPointerEvent('pointermove'), this);
				eventType(target, utils.prefixPointerEvent('pointercancel'), this);
				eventType(target, utils.prefixPointerEvent('pointerup'), this);
			}

			if ( utils.hasTouch && !this.options.disableTouch ) {
				eventType(this.wrapper, 'touchstart', this);
				eventType(target, 'touchmove', this);
				eventType(target, 'touchcancel', this);
				eventType(target, 'touchend', this);
			}

			eventType(this.scroller, 'transitionend', this);
			eventType(this.scroller, 'webkitTransitionEnd', this);
			eventType(this.scroller, 'oTransitionEnd', this);
			eventType(this.scroller, 'MSTransitionEnd', this);
		},

		getComputedPosition: function () {
			var matrix = window.getComputedStyle(this.scroller, null),
				x, y;

			if ( this.options.useTransform ) {
				matrix = matrix[utils.style.transform].split(')')[0].split(', ');
				x = +(matrix[12] || matrix[4]);
				y = +(matrix[13] || matrix[5]);
			} else {
				x = +matrix.left.replace(/[^-\d.]/g, '');
				y = +matrix.top.replace(/[^-\d.]/g, '');
			}

			return { x: x, y: y };
		},

		_initIndicators: function () {
			var interactive = this.options.interactiveScrollbars,
				customStyle = typeof this.options.scrollbars != 'string',
				indicators = [],
				indicator;

			var that = this;

			this.indicators = [];

			if ( this.options.scrollbars ) {
				// Vertical scrollbar
				if ( this.options.scrollY ) {
					indicator = {
						el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenX: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}

				// Horizontal scrollbar
				if ( this.options.scrollX ) {
					indicator = {
						el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenY: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}
			}

			if ( this.options.indicators ) {
				// TODO: check concat compatibility
				indicators = indicators.concat(this.options.indicators);
			}

			for ( var i = indicators.length; i--; ) {
				this.indicators.push( new Indicator(this, indicators[i]) );
			}

			// TODO: check if we can use array.map (wide compatibility and performance issues)
			function _indicatorsMap (fn) {
				for ( var i = that.indicators.length; i--; ) {
					fn.call(that.indicators[i]);
				}
			}

			if ( this.options.fadeScrollbars ) {
				this.on('scrollEnd', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollCancel', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1);
					});
				});

				this.on('beforeScrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1, true);
					});
				});
			}


			this.on('refresh', function () {
				_indicatorsMap(function () {
					this.refresh();
				});
			});

			this.on('destroy', function () {
				_indicatorsMap(function () {
					this.destroy();
				});

				delete this.indicators;
			});
		},

		_initWheel: function () {
			utils.addEvent(this.wrapper, 'wheel', this);
			utils.addEvent(this.wrapper, 'mousewheel', this);
			utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

			this.on('destroy', function () {
				utils.removeEvent(this.wrapper, 'wheel', this);
				utils.removeEvent(this.wrapper, 'mousewheel', this);
				utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
			});
		},

		_wheel: function (e) {
			if ( !this.enabled ) {
				return;
			}

			e.preventDefault();
			e.stopPropagation();

			var wheelDeltaX, wheelDeltaY,
				newX, newY,
				that = this;

			if ( this.wheelTimeout === undefined ) {
				that._execEvent('scrollStart');
			}

			// Execute the scrollEnd event after 400ms the wheel stopped scrolling
			clearTimeout(this.wheelTimeout);
			this.wheelTimeout = setTimeout(function () {
				that._execEvent('scrollEnd');
				that.wheelTimeout = undefined;
			}, 400);

			if ( 'deltaX' in e ) {
				if (e.deltaMode === 1) {
					wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
					wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
				} else {
					wheelDeltaX = -e.deltaX;
					wheelDeltaY = -e.deltaY;
				}
			} else if ( 'wheelDeltaX' in e ) {
				wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
				wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
			} else if ( 'wheelDelta' in e ) {
				wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
			} else if ( 'detail' in e ) {
				wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
			} else {
				return;
			}

			wheelDeltaX *= this.options.invertWheelDirection;
			wheelDeltaY *= this.options.invertWheelDirection;

			if ( !this.hasVerticalScroll ) {
				wheelDeltaX = wheelDeltaY;
				wheelDeltaY = 0;
			}

			if ( this.options.snap ) {
				newX = this.currentPage.pageX;
				newY = this.currentPage.pageY;

				if ( wheelDeltaX > 0 ) {
					newX--;
				} else if ( wheelDeltaX < 0 ) {
					newX++;
				}

				if ( wheelDeltaY > 0 ) {
					newY--;
				} else if ( wheelDeltaY < 0 ) {
					newY++;
				}

				this.goToPage(newX, newY);

				return;
			}

			newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
			newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

			if ( newX > 0 ) {
				newX = 0;
			} else if ( newX < this.maxScrollX ) {
				newX = this.maxScrollX;
			}

			if ( newY > 0 ) {
				newY = 0;
			} else if ( newY < this.maxScrollY ) {
				newY = this.maxScrollY;
			}

			this.scrollTo(newX, newY, 0);

	// INSERT POINT: _wheel
		},

		_initSnap: function () {
			this.currentPage = {};

			if ( typeof this.options.snap == 'string' ) {
				this.options.snap = this.scroller.querySelectorAll(this.options.snap);
			}

			this.on('refresh', function () {
				var i = 0, l,
					m = 0, n,
					cx, cy,
					x = 0, y,
					stepX = this.options.snapStepX || this.wrapperWidth,
					stepY = this.options.snapStepY || this.wrapperHeight,
					el;

				this.pages = [];

				if ( !this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight ) {
					return;
				}

				if ( this.options.snap === true ) {
					cx = Math.round( stepX / 2 );
					cy = Math.round( stepY / 2 );

					while ( x > -this.scrollerWidth ) {
						this.pages[i] = [];
						l = 0;
						y = 0;

						while ( y > -this.scrollerHeight ) {
							this.pages[i][l] = {
								x: Math.max(x, this.maxScrollX),
								y: Math.max(y, this.maxScrollY),
								width: stepX,
								height: stepY,
								cx: x - cx,
								cy: y - cy
							};

							y -= stepY;
							l++;
						}

						x -= stepX;
						i++;
					}
				} else {
					el = this.options.snap;
					l = el.length;
					n = -1;

					for ( ; i < l; i++ ) {
						if ( i === 0 || el[i].offsetLeft <= el[i-1].offsetLeft ) {
							m = 0;
							n++;
						}

						if ( !this.pages[m] ) {
							this.pages[m] = [];
						}

						x = Math.max(-el[i].offsetLeft, this.maxScrollX);
						y = Math.max(-el[i].offsetTop, this.maxScrollY);
						cx = x - Math.round(el[i].offsetWidth / 2);
						cy = y - Math.round(el[i].offsetHeight / 2);

						this.pages[m][n] = {
							x: x,
							y: y,
							width: el[i].offsetWidth,
							height: el[i].offsetHeight,
							cx: cx,
							cy: cy
						};

						if ( x > this.maxScrollX ) {
							m++;
						}
					}
				}

				this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

				// Update snap threshold if needed
				if ( this.options.snapThreshold % 1 === 0 ) {
					this.snapThresholdX = this.options.snapThreshold;
					this.snapThresholdY = this.options.snapThreshold;
				} else {
					this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
					this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
				}
			});

			this.on('flick', function () {
				var time = this.options.snapSpeed || Math.max(
						Math.max(
							Math.min(Math.abs(this.x - this.startX), 1000),
							Math.min(Math.abs(this.y - this.startY), 1000)
						), 300);

				this.goToPage(
					this.currentPage.pageX + this.directionX,
					this.currentPage.pageY + this.directionY,
					time
				);
			});
		},

		_nearestSnap: function (x, y) {
			if ( !this.pages.length ) {
				return { x: 0, y: 0, pageX: 0, pageY: 0 };
			}

			var i = 0,
				l = this.pages.length,
				m = 0;

			// Check if we exceeded the snap threshold
			if ( Math.abs(x - this.absStartX) < this.snapThresholdX &&
				Math.abs(y - this.absStartY) < this.snapThresholdY ) {
				return this.currentPage;
			}

			if ( x > 0 ) {
				x = 0;
			} else if ( x < this.maxScrollX ) {
				x = this.maxScrollX;
			}

			if ( y > 0 ) {
				y = 0;
			} else if ( y < this.maxScrollY ) {
				y = this.maxScrollY;
			}

			for ( ; i < l; i++ ) {
				if ( x >= this.pages[i][0].cx ) {
					x = this.pages[i][0].x;
					break;
				}
			}

			l = this.pages[i].length;

			for ( ; m < l; m++ ) {
				if ( y >= this.pages[0][m].cy ) {
					y = this.pages[0][m].y;
					break;
				}
			}

			if ( i == this.currentPage.pageX ) {
				i += this.directionX;

				if ( i < 0 ) {
					i = 0;
				} else if ( i >= this.pages.length ) {
					i = this.pages.length - 1;
				}

				x = this.pages[i][0].x;
			}

			if ( m == this.currentPage.pageY ) {
				m += this.directionY;

				if ( m < 0 ) {
					m = 0;
				} else if ( m >= this.pages[0].length ) {
					m = this.pages[0].length - 1;
				}

				y = this.pages[0][m].y;
			}

			return {
				x: x,
				y: y,
				pageX: i,
				pageY: m
			};
		},

		goToPage: function (x, y, time, easing) {
			easing = easing || this.options.bounceEasing;

			if ( x >= this.pages.length ) {
				x = this.pages.length - 1;
			} else if ( x < 0 ) {
				x = 0;
			}

			if ( y >= this.pages[x].length ) {
				y = this.pages[x].length - 1;
			} else if ( y < 0 ) {
				y = 0;
			}

			var posX = this.pages[x][y].x,
				posY = this.pages[x][y].y;

			time = time === undefined ? this.options.snapSpeed || Math.max(
				Math.max(
					Math.min(Math.abs(posX - this.x), 1000),
					Math.min(Math.abs(posY - this.y), 1000)
				), 300) : time;

			this.currentPage = {
				x: posX,
				y: posY,
				pageX: x,
				pageY: y
			};

			this.scrollTo(posX, posY, time, easing);
		},

		next: function (time, easing) {
			var x = this.currentPage.pageX,
				y = this.currentPage.pageY;

			x++;

			if ( x >= this.pages.length && this.hasVerticalScroll ) {
				x = 0;
				y++;
			}

			this.goToPage(x, y, time, easing);
		},

		prev: function (time, easing) {
			var x = this.currentPage.pageX,
				y = this.currentPage.pageY;

			x--;

			if ( x < 0 && this.hasVerticalScroll ) {
				x = 0;
				y--;
			}

			this.goToPage(x, y, time, easing);
		},

		_initKeys: function (e) {
			// default key bindings
			var keys = {
				pageUp: 33,
				pageDown: 34,
				end: 35,
				home: 36,
				left: 37,
				up: 38,
				right: 39,
				down: 40
			};
			var i;

			// if you give me characters I give you keycode
			if ( typeof this.options.keyBindings == 'object' ) {
				for ( i in this.options.keyBindings ) {
					if ( typeof this.options.keyBindings[i] == 'string' ) {
						this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
					}
				}
			} else {
				this.options.keyBindings = {};
			}

			for ( i in keys ) {
				this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
			}

			utils.addEvent(window, 'keydown', this);

			this.on('destroy', function () {
				utils.removeEvent(window, 'keydown', this);
			});
		},

		_key: function (e) {
			if ( !this.enabled ) {
				return;
			}

			var snap = this.options.snap,	// we are using this alot, better to cache it
				newX = snap ? this.currentPage.pageX : this.x,
				newY = snap ? this.currentPage.pageY : this.y,
				now = utils.getTime(),
				prevTime = this.keyTime || 0,
				acceleration = 0.250,
				pos;

			if ( this.options.useTransition && this.isInTransition ) {
				pos = this.getComputedPosition();

				this._translate(Math.round(pos.x), Math.round(pos.y));
				this.isInTransition = false;
			}

			this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

			switch ( e.keyCode ) {
				case this.options.keyBindings.pageUp:
					if ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {
						newX += snap ? 1 : this.wrapperWidth;
					} else {
						newY += snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.pageDown:
					if ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {
						newX -= snap ? 1 : this.wrapperWidth;
					} else {
						newY -= snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.end:
					newX = snap ? this.pages.length-1 : this.maxScrollX;
					newY = snap ? this.pages[0].length-1 : this.maxScrollY;
					break;
				case this.options.keyBindings.home:
					newX = 0;
					newY = 0;
					break;
				case this.options.keyBindings.left:
					newX += snap ? -1 : 5 + this.keyAcceleration>>0;
					break;
				case this.options.keyBindings.up:
					newY += snap ? 1 : 5 + this.keyAcceleration>>0;
					break;
				case this.options.keyBindings.right:
					newX -= snap ? -1 : 5 + this.keyAcceleration>>0;
					break;
				case this.options.keyBindings.down:
					newY -= snap ? 1 : 5 + this.keyAcceleration>>0;
					break;
				default:
					return;
			}

			if ( snap ) {
				this.goToPage(newX, newY);
				return;
			}

			if ( newX > 0 ) {
				newX = 0;
				this.keyAcceleration = 0;
			} else if ( newX < this.maxScrollX ) {
				newX = this.maxScrollX;
				this.keyAcceleration = 0;
			}

			if ( newY > 0 ) {
				newY = 0;
				this.keyAcceleration = 0;
			} else if ( newY < this.maxScrollY ) {
				newY = this.maxScrollY;
				this.keyAcceleration = 0;
			}

			this.scrollTo(newX, newY, 0);

			this.keyTime = now;
		},

		_animate: function (destX, destY, duration, easingFn) {
			var that = this,
				startX = this.x,
				startY = this.y,
				startTime = utils.getTime(),
				destTime = startTime + duration;

			function step () {
				var now = utils.getTime(),
					newX, newY,
					easing;

				if ( now >= destTime ) {
					that.isAnimating = false;
					that._translate(destX, destY);

					if ( !that.resetPosition(that.options.bounceTime) ) {
						that._execEvent('scrollEnd');
					}

					return;
				}

				now = ( now - startTime ) / duration;
				easing = easingFn(now);
				newX = ( destX - startX ) * easing + startX;
				newY = ( destY - startY ) * easing + startY;
				that._translate(newX, newY);

				if ( that.isAnimating ) {
					rAF(step);
				}
			}

			this.isAnimating = true;
			step();
		},
		handleEvent: function (e) {
			switch ( e.type ) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
				case 'orientationchange':
				case 'resize':
					this._resize();
					break;
				case 'transitionend':
				case 'webkitTransitionEnd':
				case 'oTransitionEnd':
				case 'MSTransitionEnd':
					this._transitionEnd(e);
					break;
				case 'wheel':
				case 'DOMMouseScroll':
				case 'mousewheel':
					this._wheel(e);
					break;
				case 'keydown':
					this._key(e);
					break;
				case 'click':
					if ( !e._constructed ) {
						e.preventDefault();
						e.stopPropagation();
					}
					break;
			}
		}
	};
	function createDefaultScrollbar (direction, interactive, type) {
		var scrollbar = document.createElement('div'),
			indicator = document.createElement('div');

		if ( type === true ) {
			scrollbar.style.cssText = 'position:absolute;z-index:9999';
			indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
		}

		indicator.className = 'iScrollIndicator';

		if ( direction == 'h' ) {
			if ( type === true ) {
				scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
				indicator.style.height = '100%';
			}
			scrollbar.className = 'iScrollHorizontalScrollbar';
		} else {
			if ( type === true ) {
				scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
				indicator.style.width = '100%';
			}
			scrollbar.className = 'iScrollVerticalScrollbar';
		}

		scrollbar.style.cssText += ';overflow:hidden';

		if ( !interactive ) {
			scrollbar.style.pointerEvents = 'none';
		}

		scrollbar.appendChild(indicator);

		return scrollbar;
	}

	function Indicator (scroller, options) {
		this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
		this.wrapperStyle = this.wrapper.style;
		this.indicator = this.wrapper.children[0];
		this.indicatorStyle = this.indicator.style;
		this.scroller = scroller;

		this.options = {
			listenX: true,
			listenY: true,
			interactive: false,
			resize: true,
			defaultScrollbars: false,
			shrink: false,
			fade: false,
			speedRatioX: 0,
			speedRatioY: 0
		};

		for ( var i in options ) {
			this.options[i] = options[i];
		}

		this.sizeRatioX = 1;
		this.sizeRatioY = 1;
		this.maxPosX = 0;
		this.maxPosY = 0;

		if ( this.options.interactive ) {
			if ( !this.options.disableTouch ) {
				utils.addEvent(this.indicator, 'touchstart', this);
				utils.addEvent(window, 'touchend', this);
			}
			if ( !this.options.disablePointer ) {
				utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
			}
			if ( !this.options.disableMouse ) {
				utils.addEvent(this.indicator, 'mousedown', this);
				utils.addEvent(window, 'mouseup', this);
			}
		}

		if ( this.options.fade ) {
			this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
			this.wrapperStyle[utils.style.transitionDuration] = utils.isBadAndroid ? '0.001s' : '0ms';
			this.wrapperStyle.opacity = '0';
		}
	}

	Indicator.prototype = {
		handleEvent: function (e) {
			switch ( e.type ) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
			}
		},

		destroy: function () {
			if ( this.options.interactive ) {
				utils.removeEvent(this.indicator, 'touchstart', this);
				utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.removeEvent(this.indicator, 'mousedown', this);

				utils.removeEvent(window, 'touchmove', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
				utils.removeEvent(window, 'mousemove', this);

				utils.removeEvent(window, 'touchend', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
				utils.removeEvent(window, 'mouseup', this);
			}

			if ( this.options.defaultScrollbars ) {
				this.wrapper.parentNode.removeChild(this.wrapper);
			}
		},

		_start: function (e) {
			var point = e.touches ? e.touches[0] : e;

			e.preventDefault();
			e.stopPropagation();

			this.transitionTime();

			this.initiated = true;
			this.moved = false;
			this.lastPointX	= point.pageX;
			this.lastPointY	= point.pageY;

			this.startTime	= utils.getTime();

			if ( !this.options.disableTouch ) {
				utils.addEvent(window, 'touchmove', this);
			}
			if ( !this.options.disablePointer ) {
				utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
			}
			if ( !this.options.disableMouse ) {
				utils.addEvent(window, 'mousemove', this);
			}

			this.scroller._execEvent('beforeScrollStart');
		},

		_move: function (e) {
			var point = e.touches ? e.touches[0] : e,
				deltaX, deltaY,
				newX, newY,
				timestamp = utils.getTime();

			if ( !this.moved ) {
				this.scroller._execEvent('scrollStart');
			}

			this.moved = true;

			deltaX = point.pageX - this.lastPointX;
			this.lastPointX = point.pageX;

			deltaY = point.pageY - this.lastPointY;
			this.lastPointY = point.pageY;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			this._pos(newX, newY);

	// INSERT POINT: indicator._move

			e.preventDefault();
			e.stopPropagation();
		},

		_end: function (e) {
			if ( !this.initiated ) {
				return;
			}

			this.initiated = false;

			e.preventDefault();
			e.stopPropagation();

			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
			utils.removeEvent(window, 'mousemove', this);

			if ( this.scroller.options.snap ) {
				var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

				var time = this.options.snapSpeed || Math.max(
						Math.max(
							Math.min(Math.abs(this.scroller.x - snap.x), 1000),
							Math.min(Math.abs(this.scroller.y - snap.y), 1000)
						), 300);

				if ( this.scroller.x != snap.x || this.scroller.y != snap.y ) {
					this.scroller.directionX = 0;
					this.scroller.directionY = 0;
					this.scroller.currentPage = snap;
					this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
				}
			}

			if ( this.moved ) {
				this.scroller._execEvent('scrollEnd');
			}
		},

		transitionTime: function (time) {
			time = time || 0;
			this.indicatorStyle[utils.style.transitionDuration] = time + 'ms';

			if ( !time && utils.isBadAndroid ) {
				this.indicatorStyle[utils.style.transitionDuration] = '0.001s';
			}
		},

		transitionTimingFunction: function (easing) {
			this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
		},

		refresh: function () {
			this.transitionTime();

			if ( this.options.listenX && !this.options.listenY ) {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
			} else if ( this.options.listenY && !this.options.listenX ) {
				this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
			} else {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
			}

			if ( this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll ) {
				utils.addClass(this.wrapper, 'iScrollBothScrollbars');
				utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

				if ( this.options.defaultScrollbars && this.options.customStyle ) {
					if ( this.options.listenX ) {
						this.wrapper.style.right = '8px';
					} else {
						this.wrapper.style.bottom = '8px';
					}
				}
			} else {
				utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
				utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

				if ( this.options.defaultScrollbars && this.options.customStyle ) {
					if ( this.options.listenX ) {
						this.wrapper.style.right = '2px';
					} else {
						this.wrapper.style.bottom = '2px';
					}
				}
			}

			var r = this.wrapper.offsetHeight;	// force refresh

			if ( this.options.listenX ) {
				this.wrapperWidth = this.wrapper.clientWidth;
				if ( this.options.resize ) {
					this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
					this.indicatorStyle.width = this.indicatorWidth + 'px';
				} else {
					this.indicatorWidth = this.indicator.clientWidth;
				}

				this.maxPosX = this.wrapperWidth - this.indicatorWidth;

				if ( this.options.shrink == 'clip' ) {
					this.minBoundaryX = -this.indicatorWidth + 8;
					this.maxBoundaryX = this.wrapperWidth - 8;
				} else {
					this.minBoundaryX = 0;
					this.maxBoundaryX = this.maxPosX;
				}

				this.sizeRatioX = this.options.speedRatioX || (this.scroller.maxScrollX && (this.maxPosX / this.scroller.maxScrollX));	
			}

			if ( this.options.listenY ) {
				this.wrapperHeight = this.wrapper.clientHeight;
				if ( this.options.resize ) {
					this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
					this.indicatorStyle.height = this.indicatorHeight + 'px';
				} else {
					this.indicatorHeight = this.indicator.clientHeight;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;

				if ( this.options.shrink == 'clip' ) {
					this.minBoundaryY = -this.indicatorHeight + 8;
					this.maxBoundaryY = this.wrapperHeight - 8;
				} else {
					this.minBoundaryY = 0;
					this.maxBoundaryY = this.maxPosY;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;
				this.sizeRatioY = this.options.speedRatioY || (this.scroller.maxScrollY && (this.maxPosY / this.scroller.maxScrollY));
			}

			this.updatePosition();
		},

		updatePosition: function () {
			var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
				y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

			if ( !this.options.ignoreBoundaries ) {
				if ( x < this.minBoundaryX ) {
					if ( this.options.shrink == 'scale' ) {
						this.width = Math.max(this.indicatorWidth + x, 8);
						this.indicatorStyle.width = this.width + 'px';
					}
					x = this.minBoundaryX;
				} else if ( x > this.maxBoundaryX ) {
					if ( this.options.shrink == 'scale' ) {
						this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
						this.indicatorStyle.width = this.width + 'px';
						x = this.maxPosX + this.indicatorWidth - this.width;
					} else {
						x = this.maxBoundaryX;
					}
				} else if ( this.options.shrink == 'scale' && this.width != this.indicatorWidth ) {
					this.width = this.indicatorWidth;
					this.indicatorStyle.width = this.width + 'px';
				}

				if ( y < this.minBoundaryY ) {
					if ( this.options.shrink == 'scale' ) {
						this.height = Math.max(this.indicatorHeight + y * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
					}
					y = this.minBoundaryY;
				} else if ( y > this.maxBoundaryY ) {
					if ( this.options.shrink == 'scale' ) {
						this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
						y = this.maxPosY + this.indicatorHeight - this.height;
					} else {
						y = this.maxBoundaryY;
					}
				} else if ( this.options.shrink == 'scale' && this.height != this.indicatorHeight ) {
					this.height = this.indicatorHeight;
					this.indicatorStyle.height = this.height + 'px';
				}
			}

			this.x = x;
			this.y = y;

			if ( this.scroller.options.useTransform ) {
				this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
			} else {
				this.indicatorStyle.left = x + 'px';
				this.indicatorStyle.top = y + 'px';
			}
		},

		_pos: function (x, y) {
			if ( x < 0 ) {
				x = 0;
			} else if ( x > this.maxPosX ) {
				x = this.maxPosX;
			}

			if ( y < 0 ) {
				y = 0;
			} else if ( y > this.maxPosY ) {
				y = this.maxPosY;
			}

			x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
			y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

			this.scroller.scrollTo(x, y);
		},

		fade: function (val, hold) {
			if ( hold && !this.visible ) {
				return;
			}

			clearTimeout(this.fadeTimeout);
			this.fadeTimeout = null;

			var time = val ? 250 : 500,
				delay = val ? 0 : 300;

			val = val ? '1' : '0';

			this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

			this.fadeTimeout = setTimeout((function (val) {
				this.wrapperStyle.opacity = val;
				this.visible = +val;
			}).bind(this, val), delay);
		}
	};

	IScroll.utils = utils;

	if ( typeof module != 'undefined' && module.exports ) {
		module.exports = IScroll;
	} else {
		window.IScroll = IScroll;
	}

	})(window, document, Math);

/***/ },
/* 78 */
/***/ function(module, exports) {

	module.exports = "<div class=\"v-scroller\" @mousedown.stop @touchstart.stop @click.stop>\n  <div v-el:wrapper>\n    <ul>\n      <li v-if=\"!item.lock\" v-for=\"item in items\" v-html=\"item.html\" @click=\"currentItem = item\"></li>\n      <li v-if=\"item.lock\" v-for=\"item in items\" v-html=\"item.html\" @click=\"note\"\n        ></li>\n    </ul>\n  </div>\n</div>";

/***/ },
/* 79 */
/***/ function(module, exports) {

	module.exports = "<div class=\"v-scroll\">\n    <component is=\"scroller\" :items=\"brands\"\n      :current-item.sync=\"currentBrand\"\n      class=\"brands-scroller\"></component>\n    <component is=\"scroller\" :items=\"currentBrand.vehicles\"\n      :current-item.sync=\"currentVehicle\"\n      class=\"vehicles-scroller\"></component>\n  </div>";

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(81)

	if (module.exports.__esModule) module.exports = module.exports.default
	;(typeof module.exports === "function" ? module.exports.options : module.exports).template = __webpack_require__(137)
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/bradpitt/Documents/front/carFitting/src/interact/remolder/index.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
	  }
	})()}

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// <template>
	// <div class="remolding">
	//   <component is="parts"></component>
	//   <component is="materials"
	//     v-show="store.currentPart == null || store.currentPart.set"></component>
	// </div>
	// <style type="text/css">
	//   .remolding{
	//     position: absolute;
	//     left: 0;
	//     right: 0;
	//     top: 0;
	//     bottom: 0;
	//     z-index: 15;
	//     background: -webkit-radial-gradient(center, circle cover, rgba(0,0,0,0) 0%, rgba(0,0,0,0.01) 40%, rgba(0,0,0,0.04) 50%, rgba(0,0,0,0.09) 60%, rgba(0,0,0,0.12) 65%, rgba(0,0,0,0.2) 70%, rgba(0,0,0,0.26) 75%, rgba(0,0,0,0.31) 78%, rgba(0,0,0,0.35) 80%, rgba(0,0,0,0.38) 81%, rgba(0,0,0,0.42) 82%, rgba(0,0,0,0.45) 83%, rgba(0,0,0,0.52) 85%, rgba(0,0,0,0.75) 90%, rgba(0,0,0,0.9) 95%, #000 100%);
	//   }
	// </style>
	// </template>
	// <script>
	module.exports = {
	  data: function data() {
	    return {
	      store: __webpack_require__(13)
	    };
	  },
	  components: {
	    parts: __webpack_require__(82),
	    materials: __webpack_require__(90)
	  }
	};
	// </script>

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(83)
	module.exports = __webpack_require__(85)

	if (module.exports.__esModule) module.exports = module.exports.default
	;(typeof module.exports === "function" ? module.exports.options : module.exports).template = __webpack_require__(88)
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/bradpitt/Documents/front/carFitting/src/interact/remolder/parts/index.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
	  }
	})()}

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(84);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(66)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-25e70570&file=index.vue!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./index.vue", function() {
				var newContent = require("!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-25e70570&file=index.vue!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./index.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(63)();
	// imports


	// module
	exports.push([module.id, "#wrapper {\n    position: fixed;\n    right: 30px;\n    top: 60px;\n    font-size: 14px;\n    width: 100px;\n    height: 540px;\n  }\n  .v-parts li{\n    opacity: 0.5;\n    text-align: center;\n  }\n  .v-parts li.active{\n    opacity: 1;\n  }\n  .v-parts li span{\n    width:40px;\n    height: 40px;\n    border-radius: 40px;\n    color: #F5D96C;\n    border:1px solid #F5D96C;\n    display: inline-block;\n    margin-top: 13px;\n    cursor: pointer;\n    text-align: center;\n    line-height: 40px;\n    font-size: 12px\n  }\n\n  .v-parts .icon {\n    position: relative;\n    display: inline-block;\n    width: 23px;\n    height: 23px;\n    border: 6px solid currentColor;\n    border-radius: 100%;\n    opacity: .5;\n    -webkit-transform: rotate(45deg);\n            transform: rotate(45deg);\n  }\n\n  .v-parts .active .icon {\n    opacity: 1;\n    -webkit-transform: rotate(-45deg);\n            transform: rotate(-45deg);\n  }\n\n  .v-parts .icon::before,\n  .v-parts .icon::after {\n    content: '';\n    position: absolute;\n    display: block;\n    height: 8px;\n    width: 8px;\n    border: 6px solid transparent;\n    border-radius: 100%;\n  }\n\n  .v-parts .icon::before {\n    left: 1px;\n    top: 1px;\n    border-color: currentColor transparent transparent currentColor;\n  }\n\n  .v-parts .icon::after {\n    right: 1px;\n    bottom: 1px;\n    border-color: transparent currentColor currentColor transparent;\n  }\n\n  .v-parts ul {\n    display: none;\n  }\n\n  .v-parts > li.active > ul {\n    display: block;\n  }\n  .v-parts > li.active > ul span {\n    width:30px;\n    height: 30px;\n    border-radius: 30px;\n    line-height: 30px;\n  }\n\n  .v-parts .sizes {\n    position: absolute;\n    top: 0;\n    right: 80px;\n  }\n\n  .v-parts > li.active > ul > li.active > ul {\n    display: block;\n    position: absolute;\n    top: 0;\n    right: 50px;\n    height: 600px;\n    -webkit-writing-mode: vertical-rl;\n        -ms-writing-mode: tb-rl;\n            writing-mode: vertical-rl;\n    text-align: left;\n  }\n  .v-parts > li.active > ul > li.active > ul > li {\n    display: inline-block;\n  }\n  .v-parts img{\n    height: 49px;\n    -webkit-transition: .5s;\n    transition:.5s;\n  }\n  .v-parts img:hover{\n    -webkit-transform:scale(1.2);\n            transform:scale(1.2);\n  }\n  .v-spring{\n    position: absolute;\n    right: 0;\n    top: 100px;\n    width: 100px;\n  }\n  .type{\n    width: 30px !important;\n    height: 30px !important;\n    border-radius: 30px !important;\n    line-height: 30px !important;\n  }\n  #jack{\n    position: absolute;\n    right: 120px;\n    bottom: 20px;\n    width:70px;\n  }\n  #jack img{\n    float: left;\n    width: 24px;\n    margin-right: 10px;\n  }\n  #vBar{\n    float: left;\n    width: 14px;\n    height: 126px;\n    position: relative;\n    background-color: #bbb;\n    -moz-border-radius: 10px;\n    -webkit-border-radius: 10px;\n  }\n  #vKnob{\n    left: 1px;\n    width: 12px;\n    height: 20px;\n    background-color: white;\n    -moz-border-radius: 8px;\n    -webkit-border-radius: 8px;\n    position: relative;\n  }\n  #wrapper .scroller{\n    position: absolute;\n    width: 100%;\n  }", ""]);

	// exports


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _keys = __webpack_require__(14);

	var _keys2 = _interopRequireDefault(_keys);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// <template>
	//   <div id="wrapper" @mousedown.stop @touchstart.stop @click.stop>
	//     <ul class="v-parts">
	//       <li :class="{active: !store.currentPartName}"
	//         @click="store.currentPartName = ''"><span class="text">整车</span></li>
	//       <li v-for="part in parts"
	//         v-if="part.set || part.choices.length > 1"
	//         :class="{active: store.currentPartName == part.name}"
	//         @click="store.currentPartName = (store.currentPartName == part.name ? '' : part.name)">
	//         <span class="text" v-text="map[part.name] || part.name"></span>
	//         <ul v-if="part.choices.length > 1">
	//           <li v-for="choice in part.choices" :class="{active: store.currentPart && store.currentPart.choice === choice}" @click.stop="changePart(choice)">
	//             <img v-if="part.previews[$index]" :src="'chassis/' + part.previews[$index]">
	//             <span v-else v-text="$index + 1"></span>
	//           </li>
	//         </ul>
	//       </li>
	//       <li v-for="part in wheels"
	//         v-if="part.set || part.choices.length > 1"
	//         :class="{active: store.currentPartName == part.name}"
	//         @click="store.currentPartName = (store.currentPartName == part.name ? '' : part.name)">
	//         <span class="text" v-text="map[part.name] || part.name"></span>
	//         <ul v-if="part.name == 'rim'" class="sizes">
	//           <li v-for="size in part.sizeNumber" :class="{active: store.wheels.name == size}" @click.stop="store.wheels.name = size">
	//             <span v-text="size"></span>
	//             <ul v-if="part.choices.length > 1">
	//               <li v-for="choice in part.choices" :class="{active: store.currentPart && store.currentPart.choice === choice}" @click.stop="changePart(choice)">
	//                 <img v-if="part.previews[$index]" :src="'wheels/' + part.previews[$index]">
	//                 <span v-else v-text="$index + 1"></span>
	//               </li>
	//             </ul>
	//           </li>
	//         </ul>
	//       </li>
	//       <li v-for="type in types" @click="changeType($index)" :class="{active: currentType == type}">
	//         <span class="type" v-text="type ==''?'原车':type"></span>
	//       </li>
	//     </ul>
	//     </div>
	//   <div id="jack">
	//       <img src="../../jack.png">
	//       <div id="vBar">
	//         <div id="vKnob" :style="'top:'+store.chassis.offsetY+'px';" @mousedown.stop="knobEvent($event)"></div>
	//       </div>
	//     </div>
	// </template>
	// <style>

	//   #wrapper {
	//     position: fixed;
	//     right: 30px;
	//     top: 60px;
	//     font-size: 14px;
	//     width: 100px;
	//     height: 540px;
	//   }
	//   .v-parts li{
	//     opacity: 0.5;
	//     text-align: center;
	//   }
	//   .v-parts li.active{
	//     opacity: 1;
	//   }
	//   .v-parts li span{
	//     width:40px;
	//     height: 40px;
	//     border-radius: 40px;
	//     color: #F5D96C;
	//     border:1px solid #F5D96C;
	//     display: inline-block;
	//     margin-top: 13px;
	//     cursor: pointer;
	//     text-align: center;
	//     line-height: 40px;
	//     font-size: 12px
	//   }

	//   .v-parts .icon {
	//     position: relative;
	//     display: inline-block;
	//     width: 23px;
	//     height: 23px;
	//     border: 6px solid currentColor;
	//     border-radius: 100%;
	//     opacity: .5;
	//     transform: rotate(45deg);
	//   }

	//   .v-parts .active .icon {
	//     opacity: 1;
	//     transform: rotate(-45deg);
	//   }

	//   .v-parts .icon::before,
	//   .v-parts .icon::after {
	//     content: '';
	//     position: absolute;
	//     display: block;
	//     height: 8px;
	//     width: 8px;
	//     border: 6px solid transparent;
	//     border-radius: 100%;
	//   }

	//   .v-parts .icon::before {
	//     left: 1px;
	//     top: 1px;
	//     border-color: currentColor transparent transparent currentColor;
	//   }

	//   .v-parts .icon::after {
	//     right: 1px;
	//     bottom: 1px;
	//     border-color: transparent currentColor currentColor transparent;
	//   }

	//   .v-parts ul {
	//     display: none;
	//   }

	//   .v-parts > li.active > ul {
	//     display: block;
	//   }
	//   .v-parts > li.active > ul span {
	//     width:30px;
	//     height: 30px;
	//     border-radius: 30px;
	//     line-height: 30px;
	//   }

	//   .v-parts .sizes {
	//     position: absolute;
	//     top: 0;
	//     right: 80px;
	//   }

	//   .v-parts > li.active > ul > li.active > ul {
	//     display: block;
	//     position: absolute;
	//     top: 0;
	//     right: 50px;
	//     height: 600px;
	//     writing-mode: vertical-rl;
	//     text-align: left;
	//   }
	//   .v-parts > li.active > ul > li.active > ul > li {
	//     display: inline-block;
	//   }
	//   .v-parts img{
	//     height: 49px;
	//     transition:.5s;
	//   }
	//   .v-parts img:hover{
	//     transform:scale(1.2);
	//   }
	//   .v-spring{
	//     position: absolute;
	//     right: 0;
	//     top: 100px;
	//     width: 100px;
	//   }
	//   .type{
	//     width: 30px !important;
	//     height: 30px !important;
	//     border-radius: 30px !important;
	//     line-height: 30px !important;
	//   }
	//   #jack{
	//     position: absolute;
	//     right: 120px;
	//     bottom: 20px;
	//     width:70px;
	//   }
	//   #jack img{
	//     float: left;
	//     width: 24px;
	//     margin-right: 10px;
	//   }
	//   #vBar{
	//     float: left;
	//     width: 14px;
	//     height: 126px;
	//     position: relative;
	//     background-color: #bbb;
	//     -moz-border-radius: 10px;
	//     -webkit-border-radius: 10px;
	//   }
	//   #vKnob{
	//     left: 1px;
	//     width: 12px;
	//     height: 20px;
	//     background-color: white;
	//     -moz-border-radius: 8px;
	//     -webkit-border-radius: 8px;
	//     position: relative;
	//   }
	//   #wrapper .scroller{
	//     position: absolute;
	//     width: 100%;
	//   }
	// </style>

	// <script>
	var Vue = __webpack_require__(12);
	var store = __webpack_require__(13);
	var chassis = __webpack_require__(27);
	var _wheels = __webpack_require__(28);
	var audio = __webpack_require__(86);
	var vanish = __webpack_require__(87).vanish;
	var IScroll = __webpack_require__(77);
	String.prototype.minus = function (str2) {

	  var head = 0;
	  var tail = 0;
	  var result;
	  var str1 = this.toString();
	  if (str1 === str2) {
	    result = "";
	  } else {
	    for (; str1[str1.length - 1 - tail] == str2[str2.length - 1 - tail]; tail++) {}
	    str1 = str1.slice(0, str1.length - tail);
	    str2 = str2.slice(0, str2.length - tail);

	    for (; str1[head] == str2[head]; head++) {}
	    str1 = str1.slice(head, str1.length);
	    str2 = str2.slice(head, str2.length);
	    result = str1.length > str2.length ? str1 : str2;
	  }
	  return result;
	};
	var transfer = function transfer(data) {
	  var tmp;
	  tmp = (0, _keys2.default)(data).sort().map(function (partName) {
	    var part = data[partName];

	    var partModel = { name: partName };
	    return Vue.util.extend(partModel, part);
	  });
	  return tmp;
	};
	var transferWheels = function transferWheels(data, wheels) {
	  var tmp;
	  var sizeNumber = (0, _keys2.default)(wheels).map(function (size) {
	    return size;
	  });
	  tmp = (0, _keys2.default)(data).sort().map(function (partName) {
	    var part = data[partName];
	    var partModel = { name: partName, sizeNumber: sizeNumber };
	    // if(partName=="rim"){
	    //   part.choices = Object.keys(data[partName].choices).sort().map(function(brand){
	    //     return {name:brand,parts:data[partName].choices[brand]}
	    //   })
	    // }
	    return Vue.util.extend(partModel, part);
	  });
	  return tmp;
	};
	var transferTypes = function transferTypes(data) {
	  var result = [];
	  var overlop = [];
	  data.forEach(function (part) {
	    overlop = [];
	    if (part.choices.length > 1) {
	      result = [];
	      part.choices.forEach(function (choice, index) {
	        var type;
	        type = choice.minus(part.choices[0]).replace(/\-/g, '').replace(/\./g, '').toUpperCase();
	        console.log(type);
	        result.push(type);
	      });
	    }
	  });
	  console.log(result);
	  return result;
	};
	module.exports = {
	  data: function data() {
	    return {
	      store: store,
	      currentBrand: "",
	      map: {
	        body: "车身",
	        fbumper: "前杠",
	        rbumper: "后杠",
	        sideskirt: "侧裙",
	        hood: "引擎盖",
	        roof: "车顶",
	        trunk: "尾箱",
	        reflector: "反光镜",
	        caliper: "卡钳",
	        "rim": "轮毂",
	        "spoiler": "尾翼"
	      },
	      currentType: ""
	    };
	  },
	  computed: {
	    parts: function parts() {
	      return transfer(chassis[this.store.chassis.name]);
	    },
	    wheels: function wheels() {
	      return transferWheels(_wheels[this.store.wheels.name], _wheels);
	    },
	    types: function types() {
	      return transferTypes(this.parts);
	    }
	  },
	  methods: {
	    changePart: function changePart(choice) {
	      audio.part();
	      this.store.currentPart.choice = choice || "";
	    },
	    brandSrc: function brandSrc(brand) {
	      return 'parts/' + brand + '/logo.png';
	    },
	    partSrc: function partSrc(part) {
	      return this.currentBrand ? 'parts/' + this.currentBrand + '/' + part + '.png' : 'parts/bbs/logo.png';
	    },
	    changeType: function changeType(index) {
	      this.currentType = this.types[index];
	      this.parts.forEach((function (part) {
	        if (part.choices.length > 1) {
	          this.store.chassis.parts[part.name].choice = part.choices[index];
	        }
	      }).bind(this));
	    },
	    knobEvent: function knobEvent(event) {
	      //拖拽控件
	      var knob = document.querySelector('#vKnob');
	      var bar = document.querySelector('#jack');
	      var initY = event.clientY;
	      var store = this.store;
	      var init = store.chassis.offsetY;
	      function moveEvent(evt) {
	        evt.stopPropagation();
	        var top = evt.clientY - initY;
	        store.chassis.offsetY = init + top;
	        if (knob.offsetTop < 0) store.chassis.offsetY = 0;
	        if (knob.offsetTop > 106) store.chassis.offsetY = 106;
	        document.removeEventListener('mouseup', vanish, false);
	      }
	      function upEvent(evt) {
	        evt.stopPropagation();
	        bar.removeEventListener('mousemove', moveEvent);
	        knob.removeEventListener('mouseup', upEvent);
	        document.addEventListener('mouseup', vanish, false);
	      }
	      bar.addEventListener('mousemove', moveEvent);
	      knob.addEventListener('mouseup', upEvent);
	      document.addEventListener('mouseup', upEvent);
	      bar.addEventListener('mouseup', function () {
	        bar.removeEventListener('mousemove', moveEvent);
	      });
	    }
	  },
	  ready: function ready() {}
	};
	// </script>

/***/ },
/* 86 */
/***/ function(module, exports) {

	'use strict';

	var partAudio = new Audio('part.wav');
	var colorAudio = new Audio('color.wav');

	exports.part = function () {
	  partAudio.play();
	};

	exports.color = function () {
	  colorAudio.play();
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var store = __webpack_require__(13);

	exports.vanish = function (event) {
	  var vm = __webpack_require__(59);
	  if (event.target.className == 'remolding' && !store.hoverPartName) vm.$children[0].$data.current = '';
	};

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = "<div id=\"wrapper\" @mousedown.stop @touchstart.stop @click.stop>\n    <ul class=\"v-parts\">\n      <li :class=\"{active: !store.currentPartName}\"\n        @click=\"store.currentPartName = ''\"><span class=\"text\">整车</span></li>\n      <li v-for=\"part in parts\"\n        v-if=\"part.set || part.choices.length > 1\"\n        :class=\"{active: store.currentPartName == part.name}\"\n        @click=\"store.currentPartName = (store.currentPartName == part.name ? '' : part.name)\">\n        <span class=\"text\" v-text=\"map[part.name] || part.name\"></span>\n        <ul v-if=\"part.choices.length > 1\">\n          <li v-for=\"choice in part.choices\" :class=\"{active: store.currentPart && store.currentPart.choice === choice}\" @click.stop=\"changePart(choice)\">\n            <img v-if=\"part.previews[$index]\" :src=\"'chassis/' + part.previews[$index]\">\n            <span v-else v-text=\"$index + 1\"></span>\n          </li>\n        </ul>\n      </li>\n      <li v-for=\"part in wheels\"\n        v-if=\"part.set || part.choices.length > 1\"\n        :class=\"{active: store.currentPartName == part.name}\"\n        @click=\"store.currentPartName = (store.currentPartName == part.name ? '' : part.name)\">\n        <span class=\"text\" v-text=\"map[part.name] || part.name\"></span>\n        <ul v-if=\"part.name == 'rim'\" class=\"sizes\">\n          <li v-for=\"size in part.sizeNumber\" :class=\"{active: store.wheels.name == size}\" @click.stop=\"store.wheels.name = size\">\n            <span v-text=\"size\"></span>\n            <ul v-if=\"part.choices.length > 1\">\n              <li v-for=\"choice in part.choices\" :class=\"{active: store.currentPart && store.currentPart.choice === choice}\" @click.stop=\"changePart(choice)\">\n                <img v-if=\"part.previews[$index]\" :src=\"'wheels/' + part.previews[$index]\">\n                <span v-else v-text=\"$index + 1\"></span>\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li v-for=\"type in types\" @click=\"changeType($index)\" :class=\"{active: currentType == type}\">\n        <span class=\"type\" v-text=\"type ==''?'原车':type\"></span>\n      </li>\n    </ul>\n    </div>\n  <div id=\"jack\">\n      <img src=\"" + __webpack_require__(89) + "\">\n      <div id=\"vBar\">\n        <div id=\"vKnob\" :style=\"'top:'+store.chassis.offsetY+'px';\" @mousedown.stop=\"knobEvent($event)\"></div>\n      </div>\n    </div>";

/***/ },
/* 89 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAEeCAYAAADBzeYyAAAACXBIWXMAABYlAAAWJQFJUiTwAAAMKWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjarVdnVFPpFt23JKGEGkBAkNCbIEWQIr0LAtJhLIQkQCghpqBidxxGwbGLBSs6KuKoYwFkLIg6WBgEe3+og8rIOFiwofJ+BHDKez/eWu9b62btu7PPOfucdddd9wBao3kSSQGpDRSK5dKEiGBuWnoGl9UBAiQ48IEtjy+TBMXHx+C/njfXQQDAFSeeRFKA/+3oCIQyPkDEA8gSyPiFAHEYoI35EqkcYLQBsJwml8gBxmsAetK09AyAqQJAL0eJTQDoZSmxCwA9aVJCCMAMBVTYPJ40B9CMB8At5ufIAU0JABexQCQGNLcC8Ofn8gSAZgeAkYWFRQJAiw3ALutPeXL+kjNrKCePlzOElb0AAFRCRTJJAW8G/t+nsEAxWMMCADtXGpkAQA8gducXRScAYAPEMXFWbBwAXYA4JxIAA/h2riIyeUDfzZeFZAAwAEgIeKHRAEwA0kCRnxw0gN14UkCpJ2NF8qikAZwlLUoYyE8WC2VhiYM4VxgVM5BzkbggdhBvzhaFRwHQBsjDJblJqUqf5JliUUosAE2AbJPlJ0YP6O+X5IbEDmqkioRkAFYA+TpbGp6g1FCGhbLBvihnPi8sEYAhQAXKc5MilbFUmlCWFjPoTSAMDVN6oARCcfKAZ0oukQcnDMSWSgriB/TUZmFBRIJyztQBWXHiYOxluTRpYObUwzzeuHilf+qNRB6fpPRG04hBCELBhQJcZKEIeRC1dtd1gzvwTzh4kCIHQjgNMIMRqeBBCjF4SEQJfocYQsiG4oLBgxRCFEOMT0Os8tcJ2eBBimIIIUM+HkOKQtqY9qd96Rjanw6k/Wk32ov2Hozjag1WZYYxQ5mRzHCm/ZAPPopQgCJIIfon9yWS8ZjRznjIuMboYNxCNAoghAJSCCEe6iwFv0IK0eD9FNEC6d+cczEeHVAMTEWILIjRNaihbWg32oMOpv1of9obXNqANoYTPZr2ooPoANqX9qC9/+JQMeTiyyz/Xk8I8V96HOA1HTQ9BlxkDfkPGVL9PUvIn2YkQBGi/66kFlGHqGbqFHWeOkbVgUudpOqpFuo4VfenJ+FXSJEzVC0BQoiRjwKIBjUuNS5dLh//UZ034EAKIWSAXDhdDgAhRZIZUlFOrpwbJJEUCLlRYr7zSK6bi6snkJaewVW+Pl4ZgABAGFz4wk1tBLzLACLnC8ezBI4+BjhvvnCWLwH2cuB4G18hLVZyNAAwoAYt6MEII2AJOzjBDZ7wRSDCMA5xSEI6JoOPXBRCimmYhfkoRTmWYw02YAu2Yzd+wEHU4RhO4WdcRBuu4Q460Iln6MEb9BEEwSI0CA5hRJgR1oQj4UZ4Ef5EGBFDJBDpRCaRQ4gJBTGL+JooJ1YSG4htRDXxI3GUOEWcJ9qJW8QDoot4SXwgKZJN6pGmpA05ivQig8hoMomcROaQU8kSciG5lFxHVpF7yVryFHmRvEZ2kM/IXgqUOmVAmVNOlBcVQsVRGVQ2JaXmUGVUBVVF7aMaqGbqCtVBdVPvaSbNobm0E+1LR9LJNJ+eSs+hl9Ab6N10LX2GvkI/oHvozwwNhgnDkeHDiGKkMXIY0xiljArGTsYRxlnGNUYn4w2TyTRg2jLHMCOZ6cw85kzmEuYm5n5mI7Od+YjZy2KxjFiOLD9WHIvHkrNKWetZe1knWZdZnax3KuoqZipuKuEqGSpilQUqFSp7VE6oXFZ5otKnqq1qreqjGqcqUJ2hukx1h2qD6iXVTtU+NR01WzU/tSS1PLX5auvU9qmdVbur9kpdXd1C3Vt9grpIfZ76OvUD6ufUH6i/Z+uyHdgh7IlsBXspexe7kX2L/UpDQ8NGI1AjQ0OusVSjWuO0xn2Nd5ocTWfNKE2B5lzNSs1azcuaz7VUtay1grQma5VoVWgd0rqk1a2tqm2jHaLN056jXal9VPuGdq8OR8dVJ06nUGeJzh6d8zpPdVm6NrphugLdhbrbdU/rPuJQHEtOCIfP+Zqzg3OW06nH1LPVi9LL0yvX+0GvVa9HX1d/tH6K/nT9Sv3j+h0GlIGNQZRBgcEyg4MG1w0+DDMdFjRMOGzxsH3DLg97azjcMNBQaFhmuN/wmuEHI65RmFG+0QqjOqN7xrSxg/EE42nGm43PGncP1xvuO5w/vGz4weG3TUgTB5MEk5km201aTHpNR5hGmEpM15ueNu0eYTAicETeiNUjTozoMuOY+ZuJzFabnTT7javPDeIWcNdxz3B7zE3MI80V5tvMW837LGwtki0WWOy3uGepZullmW252rLJssfKzGq81SyrGqvb1qrWXta51mutm63f2tjapNp8a1Nn89TW0DbKtsS2xvaunYZdgN1Uuyq7q/ZMey/7fPtN9m0OpIOHQ65DpcMlR9LR01HkuMmxfSRjpPdI8ciqkTec2E5BTsVONU4PnA2cY5wXONc5Px9lNSpj1IpRzaM+u3i4FLjscLnjqus6znWBa4PrSzcHN75bpdtVdw33cPe57vXuL0Y7jhaO3jz6pgfHY7zHtx5NHp88x3hKPfd5do2xGpM5ZuOYG156XvFeS7zOeTO8g73neh/zfu/j6SP3Oejzh6+Tb77vHt+nY23HCsfuGPvIz8KP57fNr8Of65/pv9W/I8A8gBdQFfAw0DJQELgz8EmQfVBe0N6g58EuwdLgI8FvQ3xCZoc0hlKhEaFloa1humHJYRvC7odbhOeE14T3RHhEzIxojGRERkeuiLwRZRrFj6qO6hk3ZtzscWei2dGJ0RuiH8Y4xEhjGsaT48eNXzX+bqx1rDi2Lg5xUXGr4u7F28ZPjf9pAnNC/ITKCY8TXBNmJTQnchKnJO5JfJMUnLQs6U6yXbIiuSlFK2ViSnXK29TQ1JWpHWmj0manXUw3Thel12ewMlIydmb0fhX21ZqvOid6TCydeH2S7aTpk85PNp5cMPn4FK0pvCmHMhmZqZl7Mj/y4nhVvN6sqKyNWT38EP5a/jNBoGC1oEvoJ1wpfJLtl70y+2mOX86qnK7cgNyK3G5RiGiD6EVeZN6WvLf5cfm78vsLUgv2F6oUZhYeFeuK88VnikYUTS9qlzhKSiUdU32mrpnaI42W7pQRskmyermeXCJvUdgpvlE8KPYvrix+Ny1l2qHpOtPF01tmOMxYPONJSXjJ9zPpmfyZTbPMZ82f9WB20Oxtc4g5WXOa5lrOXTi3c17EvN3z1ebnz/9lgcuClQtef536dcNC04XzFj76JuKbmlLNUmnpjW99v92yiF4kWtS62H3x+sWfywRlF8pdyivKPy7hL7nwnet3677rX5q9tHWZ57LNy5nLxcuvrwhYsXulzsqSlY9WjV9Vu5q7umz16zVT1pyvGF2xZa3aWsXajnUx6+rXW61fvv7jhtwN1yqDK/dvNNm4eOPbTYJNlzcHbt63xXRL+ZYPW0Vbb26L2FZbZVNVsZ25vXj74x0pO5q/9/q+eqfxzvKdn3aJd3XsTth9pnpMdfUekz3LasgaRU3X3ol7234I/aF+n9O+bfsN9pcfwAHFgd9+zPzx+sHog02HvA7tO2x9eOMRzpGyWqJ2Rm1PXW5dR316ffvRcUebGnwbjvzk/NOuY+bHKo/rH192Qu3EwhP9J0tO9jZKGrtP5Zx61DSl6c7ptNNXz0w403o2+uy5n8N/Pt0c1HzynN+5Y+d9zh+94HWh7qLnxdoWj5Yjv3j8cqTVs7X20phL9W3ebQ3tY9tPXA64fOpK6JWfr0ZdvXgt9lr79eTrN29MvNFxU3Dz6a2CWy9uF9/uuzPvLuNu2T3texX3Te5X/cv+X/s7PDuOPwh90PIw8eGdR/xHz36V/fqxc+FjjccVT8yeVD91e3qsK7yr7bevfut8JnnW1136u87vG5/bPT/8R+AfLT1pPZ0vpC/6Xy55ZfRq1+vRr5t643vvvyl80/e27J3Ru93vvd43f0j98KRv2kfWx3Wf7D81fI7+fLe/sL9fwpPyAAAUADI7G3i5C9BIBzhtgJqmcv8CABDKnRFQfoP8Z6zc0QAAnsCuQCB5HhDTCGxuBKznAexGIB5AUiBId/eha+DIst3dlLnYUoDxrr//lSnAagA+Sfv7+zb193/aAVC3gMapyr0PAJjawFYjAGi5of2P/evfb+JrV7CZIKoAAAAgY0hSTQAAbXUAAHOgAAD83QAAg2QAAHDoAADsaAAAMD4AABCQ5OyZ6gAAC0BJREFUeNrsnW1MW9cZx5/QaxrzHpoEiFKYVPsDjkYyUZEUERKIULxBuBFUgn4ACYTWrUHKi0TbZGmqvKztaJVsCmxTNAUp+7BUaqLerFuToG5ai6YSBfVlwvlgVwoWAjIyqHmxg+2YfeBe99oYc9/Oy7XOkZAiR7z8dM/9n+c8z/88Z8Py8jKk4kiDFB1c/Af1zkqr2SD+dvvfgfjPNkhT8fSJn54s3PzsbvFz3kRcAgCAdyIw2Nt3pz8G7PXug0eKt1nrTAa0ClAOlwYAkAJQAAC8yLEiHg0mfKfUqCKfqmBsHWNglIAJKQf2SYJVO2WeWCgcSQk4OUcaAMAX92ePidPRrFNSAABB5IiNFQEAutpqawo3p+/R8pMLt2zUE2cKoXAk8L/Z4LdafvfU4+CXf/rzP/6ZMAg2Yrx3uqEvK4M7ovb7Fvzh/jcvfNJNrdzf+9Z3XsN0Fobuz/RQvY7dvPXFIy3fh0KZWeTBwBgYA2NgDIyBMTAGZn6wBX94PBXBhEePl0ZQ/GCO4I4XvvMuCpf+ODiQCmBCKBwJuB8uXv/91c+QpiFwgQmzvpB71DN/5fqNz904fiGHY7q5Hy5ex53mMxwsFI4EloKRfs+Y/0Z8ggXn2MCK6wyMgTEwBsbAGBh9gzPbH1zvrLQWbdm4Z+b7oOvmX4cemTryaHBWWm0lmS/bSjKbxY94KRaderw0fOHip++aCqylqdr+k9Kco1mZ3HZYu6AoBEORuRNv32qnHuzYq3VtxdusdemWtBxQViFdBUcNWEtTtd3+o8yXdVgLBZdnfkDawBIXj6622hpbcUbz3hfzt4M+TxdfXGQdl949jrQY7CrNATDIpCa+i/jlXhIDZ/XW7YDYccfhFIO9L+bnoASS5yg5HGJgK8kEQO+JFDxj/hvIVFESg3XWHsOhQuFI4PiZW68YCrZGZACkoHSDKYwMkAEBAHgnA4O9l3+wpesC+2XnAd5ektmsIjIw/Amtl01WDNZ0qKrAYc/uJHjoQFU2eV0wQmIQM920ZJMTghEWAwAAYcEfHteTTV4FJjvjQkwMPGP+j7QazhKC9b1z+GNScm10aSkaeVw823gt3ZKGC0oAAEBZWuIAAF7rPMA7bNk4pBt5JTMGTBQJHrUYuNzzA9c+/NcIjvnNAQCICy3VYkDDtgVbnXldsAV/eDwrg6NaDDSBeScCgw5btpbIApsYaF7HLp1r/IuFS7MqhNMdGWADUwC3knmdfjLs+m7xKm4x0B1SHf9FXccLxZm8LAKhQgx0g8kDYenfZjyKxewQDIyBMTAGxsAYGIXDNHYIKSUoq02DdyIwODYRuPvhzdXbJOojj/bW/eWOF7I6kiRshUSWCGrBVDoHVsFRBabTOSAMjcz0SLt3Kt6xrrbaGoctq0NnKZd32LJcAHCKKFiDs9LqsGV3Fm+z1hnlHMjPTXcQU0VJDFA7BzjcYlBRlocs4yxve8HhEgMczgHvROAuUjCDxEDtENwPF68bLvdyMdAg1bqh7n0ze15eF9ANpiAyQAoUCkcCX436PogvdmgG0+ApNBwoWUpQFZgBnkJdMADK6wOKwCQxIPV0ANTXB5ImTAmKAYDO+sAqMBpsREbUB2LASFohjK4PRMHOvfGzd8QgEqsgoCoWcgAArc3V9qryfFxQWA6lcgAADltWBwYorMVCLn4fQ6sY0LJtIV4s5MwiBprAvJOBweIiK0+zGGgCc7nnrxYXqW6CjN1GpGkdE41i66kjURuR5sijtbnavntn3rkElgjTOQcSBsHtLfvKn9uUXpZpfaZwMfB0anJ6aYgGG5FusFQYrD7GwBgYA2NgDMzMw3RNFLraamukfydrpGCKyKOlqdq+w57VIdvp89EdxmJ4/N5/fOfjA3KqwVScLIwprFM5FeUnC3fYskHhHpGvKMubAwD6migYcLJQkOf3iT4xg3sO8M8XWecAgByYJAbO6q2GJmnlh484EmKAozbNUSoGmsasL4ReFSUxqH1pM65ylDDqmb+CBAxVAxIlULO+kFu+jhki93GRAZHKZ/wtIrrAaOg5MOpeuJKoeqMazCw9BxSDma3nQFIwM/ccSAhGWgwA9BcLY8CaGvcWVPw49y2Sviij6gNRMLHA/j5Q3oBEdUiFGQp5sZADiB44pVoMNIE9X2StQfi0iBQLkTZRIFks5MwiBprAjGqiQJNzgAMA8Iz5b+wqzdHURIHWngPRdUy8eFAJnCl6DsREHuffqH9/U67FvgacqZwDq2LFrrbamh32rJ+LlohoLoGWBiSKx/Ly8ppf9Qdfsib7f5q/mB2CgTEwBsbAGBgDwzzqZR2YFIdUtI721v3ltpKMZvkZgWAoMufyLAwYkuLGPRScLBRmfEHXmd/8/RT1YBpOFgoLi+HxN3/9Q8WFKjCdJwuFrx/M/U6alsR9Hgb2HOCLt210AQBZMBQ9B4g2UcDRcwAbGK6eA9iaKBh4dYki8ZA3UTBcFQkWC4XuUx8fNvyJ4by6JBHU0MhMT7eRCzTpngML/vD40P2ZnvjssyYwM/QcUAVGi3NASc+BdcFocQ6oPVm4JhgtV5doLRYmTHGTbHFhVH0gBuy9XzX0EXhCSBqUR9cxsYkC1vuM1IiBJrD2ln3lFTs3YWuigOOYsdhEIRt1EwXszgEOIPYKOVrFgIZtCxW3FXDSPsbCpVEtBprAJqeXhoqLrFaN7xmVPQei65h4fRBPqxhofseGRmZ6qsrz14sFTeMcWG3ELMt9K87vQd3VJZqD4KbGvQX5uRYHAEAw+HSOxn4durctZh2sPsbAGBgDY2AMzMzDVE0U2lv3lxdufnZPevqKnX5qeunLtbzIpog8jr1a17ZGwlYAABj1zA/8IS4opxYsSUeIhLsOl2d+QL7joA5Mx7lP4fbn/31FqrpQ8Y41HaoqkK4u0XEInHfYszsBoJ84mOQcMOoQuNhKkRyYJAYVZXkAiPKZHAkxwHFbAYdLDHB0hPBOBgaRghkkBmoHOjsEwdsKhPhErSFgSSIDLFDeycBg7+U7/YZEHiojA8NhVmLFJ8NfP5j7baKDeKrBaOgI4Z0I3F2vPqAITC4GpKab2vpAUjDSV5dIEq6lPpAQjLQYGFEfiAHraqut2VWac5SUGBhZH4iCyZ4SdiAUxUIOYMVW5KzeihMKebFwxTWwso/haRYDTWDiPoZqMaAluideLOTMIgaawGZ9IfemXAvVYqAJ7KsHcx/U7nnOrjYrhFMMNK9jp487TxZu2ajkXqSkrcmoAwOI9s7hE8BFtwker/8jMzgHVsWKDc5Kq8Oe3ZmfaynNyuC2L/jD496JwKBZ7pJAkhqgabD6GANjYAyMgTEwBqZxNB2qKmhtrrabaaOZdMS1swYAOGxasCTtrAVTPjFUve2JgeGsZGIDu3i28doOWzYRIGSqePq48yShEhNaMIXpBbZAMzAGxsAYGANjYAyMgTGw1ACTXwWJ4/uwgMlcPWoje35Xac5Ro+FUl5Fe7z54ROaCW/VH6vhbEuY+vBOBwd6+WJOl4WAXzzZeI7CJFIKhyNyJt2+1I5mK7S37ygntjPl0S1qO2vyjYrD09GdIbvd58TQ9k3sGxsAYGANDCxYMPp0DRJURJYv0gj88jgSMtF1PrX9L1VQUz2fhfmqCyzM/gPQd6718p1+8wRcXnDDrC7m1GNQ0mcRe6zzAi/3i9Eb0SSP9+LPNyMGkocK8qQpqavrJ8IVLt9/Fuh+LH63N1fbdO/POiZdE6dqPhcKRwPA3358x9AiI3qFjeuqedkjBNE5PQ6YdFjCF09PQaYcNTBpxl7TxgNEBjsUT3OCstObnWhwzvpAL142NzOzMwBgY2vH/AQDvL8cWbGJioQAAAABJRU5ErkJggg=="

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91)
	module.exports = __webpack_require__(93)

	if (module.exports.__esModule) module.exports = module.exports.default
	;(typeof module.exports === "function" ? module.exports.options : module.exports).template = __webpack_require__(136)
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/bradpitt/Documents/front/carFitting/src/interact/remolder/materials/index.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
	  }
	})()}

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(92);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(66)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-1e8e393c&file=index.vue!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./index.vue", function() {
				var newContent = require("!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-1e8e393c&file=index.vue!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./index.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(63)();
	// imports


	// module
	exports.push([module.id, ".v-materials {\n  position: absolute;\n  left: 0px;\n  bottom: 0px;\n  width: 500px;\n  height: 360px;\n}\n.st56{\n  opacity: 0.5\n}\n.st1{\n  fill:#F5D96C;\n}\n.fastColor{\n  position: absolute;\n  z-index: 999;\n  left: 500px;\n  bottom: 10px;\n  width: 380px;\n}\n.fastColor .discolor li{\ndisplay: inline-block;\nmargin: 0 5px;\n}\n.fastColor .discolor li .circle{\n    width: 9px;\n    height: 18px;\n    display: inline-block;\n    border-radius:9px 0px 0px 9px;\n    border: 1px #F5D96C solid;\n    border-width: 1px 0px;\n\n\n}\n.fastColor .discolor li .circle.right {\n    border-radius:0px 9px 9px 0px;\n}\n.fastColor .normal li{\n\n    width: 18px;\n    height: 18px;\n    display: inline-block;\n    border-radius: 20px;\n    margin: 0 5px;\n    border: 1px #F5D96C solid\n\n}", ""]);

	// exports


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _assign = __webpack_require__(38);

	var _assign2 = _interopRequireDefault(_assign);

	var _typeof2 = __webpack_require__(94);

	var _typeof3 = _interopRequireDefault(_typeof2);

	var _keys = __webpack_require__(14);

	var _keys2 = _interopRequireDefault(_keys);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// <template>
	// <svg xmlns="http://www.w3.org/2000/svg"
	//   viewBox="0 0 1080 1080" class="v-materials" @click.stop="afterClick($event)" id="regular" v-el:svg>
	//   <component is="color" v-if="current == 'junior'"  :value.sync="color" :BRangle.sync="BRangle" :BLangle.sync="BLangle" :current.sync="current" :colorpad.sync="colorpad" :material.sync="material" :cancel.sync="cancel"></component>
	//   <component is="proColor" v-if="current == 'pro'"  :current.sync="current" :BRangle.sync="BRangle" :BLangle.sync="BLangle"  :deg="deg" :value.sync="color" :colorpad.sync="colorpad" :material.sync="material" ></component>
	// </svg>
	// <component is="specular" v-if="material == 'discolor'" :value.sync="specular"></component>
	// <div class="fastColor">
	//   <ul v-if="material == 'discolor'" class="discolor">
	//     <li v-for="fastcolor in materialToColor[material]"  @click="color = fastcolor['nor'],specular = fastcolor['spe']"><div class="circle" :style="'background:'+toHex(fastcolor['nor'])"></div><div class="circle right" :style="'background:'+toHex(fastcolor['spe'])"></div></li>
	//   </ul>
	//   <ul v-else class= "normal" >
	//     <li v-for="fastcolor in materialToColor[material]" :style="'background:'+toHex(fastcolor)" @click="color = fastcolor"></li>
	//   </ul>
	// </div>
	// </template>

	// <style>
	// .v-materials {
	//   position: absolute;
	//   left: 0px;
	//   bottom: 0px;
	//   width: 500px;
	//   height: 360px;
	// }
	// .st56{
	//   opacity: 0.5
	// }
	// .st1{
	//   fill:#F5D96C;
	// }
	// .fastColor{
	//   position: absolute;
	//   z-index: 999;
	//   left: 500px;
	//   bottom: 10px;
	//   width: 380px;
	// }
	// .fastColor .discolor li{
	// display: inline-block;
	// margin: 0 5px;
	// }
	// .fastColor .discolor li .circle{
	//     width: 9px;
	//     height: 18px;
	//     display: inline-block;
	//     border-radius:9px 0px 0px 9px;
	//     border: 1px #F5D96C solid;
	//     border-width: 1px 0px;

	// }
	// .fastColor .discolor li .circle.right {
	//     border-radius:0px 9px 9px 0px;
	// }
	// .fastColor .normal li{

	//     width: 18px;
	//     height: 18px;
	//     display: inline-block;
	//     border-radius: 20px;
	//     margin: 0 5px;
	//     border: 1px #F5D96C solid

	// }
	// </style>

	// <script>
	var repaint = __webpack_require__(116);
	var store = __webpack_require__(13);
	var parts = __webpack_require__(27);
	module.exports = {
	  data: function data() {
	    return {
	      cancel: false,
	      store: store,
	      color: { h: 0, s: '100%', l: '50%' },
	      BLangle: 0,
	      BRangle: 0,
	      current: 'junior',
	      deg: '0',
	      colorpad: [{ h: 0, s: '100%', l: '50%' }, { h: 0, s: '100%', l: '50%' }, { h: 0, s: '100%', l: '50%' }, { h: 0, s: '100%', l: '50%' }, { h: 0, s: '100%', l: '50%' }, { h: 0, s: '100%', l: '50%' }],
	      material: "normal",
	      materials: [],
	      specular: { h: 1, s: '100%', l: '100%' },
	      materialToColor: {
	        "matte": [{ h: 0.16667, s: '60%', l: '50%' }, { h: 0.52777, s: '30%', l: '60%' }, { h: 0.09722, s: '10%', l: '40%' }, { h: 0.88889, s: '20%', l: '30%' }, { h: 0.1, s: '100%', l: '50%' }, { h: 0.83333, s: '30%', l: '50%' }, { h: 0.58333, s: '40%', l: '60%' }, { h: 0.63888, s: '50%', l: '40%' }, { h: 0.97222, s: '30%', l: '50%' }, { h: 0.13888, s: '50%', l: '50%' }, { h: 0.05555, s: '20%', l: '30%' }, { h: 0.27777, s: '10%', l: '30%' }, { h: 0.13888, s: '40%', l: '50%' }, { h: 0.11111, s: '20%', l: '40%' }, { h: 0.91666, s: '30%', l: '70%' }, { h: 0.97222, s: '60%', l: '30%' }, { h: 0.61111, s: '20%', l: '50%' }, { h: 0.63888, s: '50%', l: '30%' }, { h: 0.22222, s: '40%', l: '50%' }, { h: 0.15277, s: '70%', l: '50%' }, { h: 0.25, s: '40%', l: '70%' }, { h: 0.61111, s: '60%', l: '60%' }],
	        "normal": [{ h: 0.69444, s: '40%', l: '30%' }, { h: 0, s: '60%', l: '40%' }, { h: 0, s: '10%', l: '40%' }, { h: 0.44444, s: '10%', l: '30%' }, { h: 0, s: '10%', l: '20%' }, { h: 0.5, s: '40%', l: '40%' }, { h: 0.583333, s: '40%', l: '40%' }, { h: 0.083333, s: '50%', l: '40%' }, { h: 0.916666, s: '50%', l: '70%' }, { h: 0.027777, s: '80%', l: '30%' }, { h: 0.5, s: '30%', l: '60%' }, { h: 0.18, s: '60%', l: '50%' }, { h: 0.361111, s: '30%', l: '50%' }, { h: 0.444444, s: '70%', l: '20%' }, { h: 0.888889, s: '60%', l: '30%' }, { h: 0.027777, s: '50%', l: '30%' }, { h: 0.75, s: '30%', l: '30%' }, { h: 0.777778, s: '30%', l: '40%' }, { h: 0.63888, s: '50%', l: '50%' }, { h: 0.61111, s: '50%', l: '60%' }, { h: 0.63888, s: '40%', l: '60%' }, { h: 0.08333, s: '60%', l: '60%' }, { h: 0.52777, s: '40%', l: '40%' }],
	        "electroplate": [{ h: 0, s: '95%', l: '80%' }, { h: 0.5, s: '90%', l: '65%' }, { h: 0.56666, s: '90%', l: '90%' }],
	        "discolor": [{ nor: { h: 1, s: '100%', l: '100%' }, spe: { h: 0.583333, s: '50%', l: '60%' } }, { nor: { h: 1, s: '100%', l: '100%' }, spe: { h: 0.125, s: '60%', l: '85%' } }, { nor: { h: 1, s: '100%', l: '100%' }, spe: { h: 0.25, s: '50%', l: '60%' } }, { nor: { h: 0.8, s: '30%', l: '30%' }, spe: { h: 0.38888, s: '10%', l: '30%' } }, { nor: { h: 0.52777, s: '40%', l: '30%' }, spe: { h: 0.27777, s: '20%', l: '40%' } }]
	      }
	    };
	  },
	  computed: {
	    isAll: function isAll() {
	      var specificParts = parts[this.store.chassis.name];
	      return (0, _keys2.default)(specificParts).filter(function (partName) {
	        return specificParts[partName].all;
	      });
	    }
	  },
	  components: {
	    color: __webpack_require__(117),
	    proColor: __webpack_require__(122),
	    specular: __webpack_require__(125)
	  },
	  methods: {
	    toHex: function toHex(value) {
	      var h = value.h;
	      var s = value.s;
	      var l = value.l;
	      var color = new THREE.Color("hsl(" + h + "," + s + "," + l + ")");
	      return '#' + color.getHexString();
	    },
	    afterClick: function afterClick(e) {
	      console.log(e.layerX, e.layerY, e.layerX, e.layerY, e.pageX, e.pageY);
	      var width = 500;
	      var height = 360;
	      var radius = Math.pow(Math.pow(e.layerX - width / 2, 2) + Math.pow(e.layerY - height / 2, 2), 1 / 2);
	      if (radius < 0.25 * width) {
	        this.deg = e.layerX > width / 2 ? Math.asin((height / 2 - e.layerY) / radius) / Math.PI * 180 : 180 - Math.asin((height / 2 - e.layerY) / radius) / Math.PI * 180;
	        this.deg = this.deg >= 0 ? this.deg : this.deg + 360;
	      }
	      if (radius > 0.3 * width && radius < 0.3 * width + 15) {
	        var angle = e.layerX > width / 2 ? Math.asin((height / 2 - e.layerY) / radius) / Math.PI * 180 : 180 - Math.asin((height / 2 - e.layerY) / radius) / Math.PI * 180;
	        if (angle > -15 && angle < 75) {
	          this.BRangle = 10 - Math.round((angle + 10) / 8) * 8;
	        }
	        angle = angle >= 0 ? angle : angle + 360;
	        if (angle > 145 && angle < 235) {
	          this.BLangle = 30 - Math.round((angle - 150) / 8) * 8;
	        }
	      }
	    },
	    cmp: function cmp(x, y) {
	      if (x === y) {
	        return true;
	      }
	      if (!(x instanceof Object) || !(y instanceof Object)) {
	        return false;
	      }
	      if (x.constructor !== y.constructor) {
	        return false;
	      }
	      for (var p in x) {
	        if (x.hasOwnProperty(p)) {
	          if (!y.hasOwnProperty(p)) {
	            return false;
	          }
	          if (x[p] === y[p]) {
	            continue;
	          }
	          if ((0, _typeof3.default)(x[p]) !== "object") {
	            return false;
	          }
	          if (!Object.equals(x[p], y[p])) {
	            return false;
	          }
	        }
	      }
	      for (p in y) {
	        if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) {
	          return false;
	        }
	      }
	      return true;
	    }
	  },
	  watch: {
	    color: function color(value) {
	      if (this.store.currentPart) {
	        this.store.currentPart.color = value;
	      } else {
	        this.isAll.forEach((function (partName) {
	          this.store.chassis.parts[partName].color = value;
	        }).bind(this));
	      }
	    },
	    material: function material(value, oldvalue) {
	      if (this.store.currentPartName) {
	        this.store.currentPart.material = value;
	      } else {
	        this.isAll.forEach((function (partName) {
	          this.store.chassis.parts[partName].material = value;
	        }).bind(this));
	        if (oldvalue == 'discolor') {
	          this.isAll.forEach((function (partName) {
	            var part = this.store.chassis.parts[partName];
	            part.specular = (0, _assign2.default)({}, part.color);
	          }).bind(this));
	        }
	      }
	    },
	    'store.currentPartName': function storeCurrentPartName(value, oldvalue) {
	      if (this.store.currentPart) this.color = this.store.currentPart.color;
	      var oldpart = this.store.chassis.parts[oldvalue] || this.store.wheels.parts[oldvalue];
	      if (oldpart) {
	        this.colorpad.push(oldpart.color);
	        this.colorpad.shift();
	      }
	    },
	    specular: function specular(value, oldvalue) {
	      if (this.store.currentPart) {
	        this.store.currentPart.specular = value;
	      } else {
	        this.isAll.forEach((function (partName) {
	          this.store.chassis.parts[partName].specular = value;
	        }).bind(this));
	      }
	    },
	    current: function current() {
	      repaint();
	    }
	  }
	};
	// </script>

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _Symbol = __webpack_require__(95)["default"];

	exports["default"] = function (obj) {
	  return obj && obj.constructor === _Symbol ? "symbol" : typeof obj;
	};

	exports.__esModule = true;

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(96), __esModule: true };

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(97);
	__webpack_require__(115);
	module.exports = __webpack_require__(22).Symbol;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var $              = __webpack_require__(34)
	  , global         = __webpack_require__(21)
	  , has            = __webpack_require__(98)
	  , DESCRIPTORS    = __webpack_require__(99)
	  , $export        = __webpack_require__(20)
	  , redefine       = __webpack_require__(100)
	  , $fails         = __webpack_require__(25)
	  , shared         = __webpack_require__(103)
	  , setToStringTag = __webpack_require__(104)
	  , uid            = __webpack_require__(106)
	  , wks            = __webpack_require__(105)
	  , keyOf          = __webpack_require__(107)
	  , $names         = __webpack_require__(109)
	  , enumKeys       = __webpack_require__(110)
	  , isArray        = __webpack_require__(111)
	  , anObject       = __webpack_require__(112)
	  , toIObject      = __webpack_require__(108)
	  , createDesc     = __webpack_require__(102)
	  , getDesc        = $.getDesc
	  , setDesc        = $.setDesc
	  , _create        = $.create
	  , getNames       = $names.get
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , setter         = false
	  , HIDDEN         = wks('_hidden')
	  , isEnum         = $.isEnum
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , useNative      = typeof $Symbol == 'function'
	  , ObjectProto    = Object.prototype;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(setDesc({}, 'a', {
	    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = getDesc(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  setDesc(it, key, D);
	  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
	} : setDesc;

	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol.prototype);
	  sym._k = tag;
	  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
	    configurable: true,
	    set: function(value){
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    }
	  });
	  return sym;
	};

	var isSymbol = function(it){
	  return typeof it == 'symbol';
	};

	var $defineProperty = function defineProperty(it, key, D){
	  if(D && has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return setDesc(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key);
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
	    ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  var D = getDesc(it = toIObject(it), key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = getNames(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
	  return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var names  = getNames(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
	  return result;
	};
	var $stringify = function stringify(it){
	  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	  var args = [it]
	    , i    = 1
	    , $$   = arguments
	    , replacer, $replacer;
	  while($$.length > i)args.push($$[i++]);
	  replacer = args[1];
	  if(typeof replacer == 'function')$replacer = replacer;
	  if($replacer || !isArray(replacer))replacer = function(key, value){
	    if($replacer)value = $replacer.call(this, key, value);
	    if(!isSymbol(value))return value;
	  };
	  args[1] = replacer;
	  return _stringify.apply($JSON, args);
	};
	var buggyJSON = $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	});

	// 19.4.1.1 Symbol([description])
	if(!useNative){
	  $Symbol = function Symbol(){
	    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
	    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
	  };
	  redefine($Symbol.prototype, 'toString', function toString(){
	    return this._k;
	  });

	  isSymbol = function(it){
	    return it instanceof $Symbol;
	  };

	  $.create     = $create;
	  $.isEnum     = $propertyIsEnumerable;
	  $.getDesc    = $getOwnPropertyDescriptor;
	  $.setDesc    = $defineProperty;
	  $.setDescs   = $defineProperties;
	  $.getNames   = $names.get = $getOwnPropertyNames;
	  $.getSymbols = $getOwnPropertySymbols;

	  if(DESCRIPTORS && !__webpack_require__(114)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	}

	var symbolStatics = {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    return keyOf(SymbolRegistry, key);
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	};
	// 19.4.2.2 Symbol.hasInstance
	// 19.4.2.3 Symbol.isConcatSpreadable
	// 19.4.2.4 Symbol.iterator
	// 19.4.2.6 Symbol.match
	// 19.4.2.8 Symbol.replace
	// 19.4.2.9 Symbol.search
	// 19.4.2.10 Symbol.species
	// 19.4.2.11 Symbol.split
	// 19.4.2.12 Symbol.toPrimitive
	// 19.4.2.13 Symbol.toStringTag
	// 19.4.2.14 Symbol.unscopables
	$.each.call((
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
	  'species,split,toPrimitive,toStringTag,unscopables'
	).split(','), function(it){
	  var sym = wks(it);
	  symbolStatics[it] = useNative ? sym : wrap(sym);
	});

	setter = true;

	$export($export.G + $export.W, {Symbol: $Symbol});

	$export($export.S, 'Symbol', symbolStatics);

	$export($export.S + $export.F * !useNative, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});

	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 98 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(25)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(101);

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var $          = __webpack_require__(34)
	  , createDesc = __webpack_require__(102);
	module.exports = __webpack_require__(99) ? function(object, key, value){
	  return $.setDesc(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 102 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(21)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(34).setDesc
	  , has = __webpack_require__(98)
	  , TAG = __webpack_require__(105)('toStringTag');

	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var store  = __webpack_require__(103)('wks')
	  , uid    = __webpack_require__(106)
	  , Symbol = __webpack_require__(21).Symbol;
	module.exports = function(name){
	  return store[name] || (store[name] =
	    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
	};

/***/ },
/* 106 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var $         = __webpack_require__(34)
	  , toIObject = __webpack_require__(108);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = $.getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(42)
	  , defined = __webpack_require__(18);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(108)
	  , getNames  = __webpack_require__(34).getNames
	  , toString  = {}.toString;

	var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function(it){
	  try {
	    return getNames(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};

	module.exports.get = function getOwnPropertyNames(it){
	  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
	  return getNames(toIObject(it));
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var $ = __webpack_require__(34);
	module.exports = function(it){
	  var keys       = $.getKeys(it)
	    , getSymbols = $.getSymbols;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = $.isEnum
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
	  }
	  return keys;
	};

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(43);
	module.exports = Array.isArray || function(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(113);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 114 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 115 */
/***/ function(module, exports) {

	

/***/ },
/* 116 */
/***/ function(module, exports) {

	'use strict';

	window.repaint = module.exports = function () {
	  var svg1 = document.getElementById('regular');
	  var svg2 = document.getElementById('spe');

	  setTimeout(function () {
	    if (svg1) svg1.style.display = 'none';
	    if (svg2) svg2.style.display = 'none';
	    setTimeout(function () {
	      if (svg1) svg1.style.display = null;
	      if (svg2) svg2.style.display = null;
	    }, 20);
	  }, 20);
	};

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(118)
	module.exports = __webpack_require__(120)

	if (module.exports.__esModule) module.exports = module.exports.default
	;(typeof module.exports === "function" ? module.exports.options : module.exports).template = __webpack_require__(121)
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/bradpitt/Documents/front/carFitting/src/interact/remolder/materials/color.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
	  }
	})()}

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(119);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(66)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-767ae166&file=color.vue!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./color.vue", function() {
				var newContent = require("!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-767ae166&file=color.vue!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./color.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(63)();
	// imports


	// module
	exports.push([module.id, ".v-colors .color path {\n  stroke: #888;\n  cursor: pointer;\n}\n  #regular .st4_1{fill:url(#SVGID_1_1);}\n  #regular .st5_1{fill:url(#SVGID_2_1);}\n  #regular .st0{display:none;}\n  #regular .st1{display:inline;fill:#333333;}\n  #regular .st2{fill:#F5D96C;}\n  #regular .st3{fill:url(#SVGID_1_);}\n  #regular .st4{fill:url(#SVGID_2_);}\n  #regular .st5{fill:url(#SVGID_3_);}\n  #regular .st6{fill:url(#SVGID_4_);}\n  #regular .st7{fill:url(#SVGID_5_);}\n  #regular .st8{fill:url(#SVGID_6_);}\n  #regular .st9{fill:url(#SVGID_7_);}\n  #regular .st10{fill:url(#SVGID_8_);}\n  #regular .st11{fill:url(#SVGID_9_);}\n  #regular .st12{fill:url(#SVGID_10_);}\n  #regular .st13{fill:url(#SVGID_11_);}\n  #regular .st14{fill:url(#SVGID_12_);}\n  #regular .st15{fill:url(#SVGID_13_);}\n  #regular .st16{fill:url(#SVGID_14_);}\n  #regular .st17{fill:url(#SVGID_15_);}\n  #regular .st18{fill:url(#SVGID_16_);}\n  #regular .st19{fill:url(#SVGID_17_);}\n  #regular .st20{fill:url(#SVGID_18_);}\n  #regular .st21{fill:none;stroke:url(#SVGID_19_);stroke-miterlimit:10;}\n  #regular .st22{fill:url(#SVGID_20_);}\n  #regular .st23{fill:url(#SVGID_21_);}\n  #regular .st24{fill:url(#SVGID_22_);}\n  #regular .st25{fill:url(#SVGID_23_);}\n  #regular .st26{fill:url(#SVGID_24_);}\n  #regular .st27{fill:url(#SVGID_25_);}\n  #regular .st28{fill:url(#SVGID_26_);}\n  #regular .st29{fill:url(#SVGID_27_);}\n  #regular .st30{fill:url(#SVGID_28_);}\n  #regular .st31{fill:url(#SVGID_29_);}\n  #regular .st32{fill:url(#SVGID_30_);}\n  #regular .st33{fill:url(#SVGID_31_);}\n  #regular .st34{-webkit-clip-path:url(#SVGID_33_);clip-path:url(#SVGID_33_);}\n  #regular .st35{fill:url(#SVGID_34_);}\n  #regular .st36{-webkit-clip-path:url(#SVGID_36_);clip-path:url(#SVGID_36_);}\n  #regular .st37{fill:url(#SVGID_37_);}\n  #regular .st38{-webkit-clip-path:url(#SVGID_39_);clip-path:url(#SVGID_39_);}\n  #regular .st39{fill:url(#SVGID_40_);}\n  #regular .st40{fill:url(#SVGID_41_);}\n  #regular .st41{fill:url(#SVGID_42_);}\n  #regular .st42{fill:url(#SVGID_43_);}\n  #regular .st43{-webkit-clip-path:url(#SVGID_45_);clip-path:url(#SVGID_45_);}\n  #regular .st44{opacity:0.5;fill:url(#SVGID_46_);}\n  #regular .st45{opacity:0.5;fill:url(#SVGID_47_);}\n  #regular .st46{opacity:0.5;fill:url(#SVGID_48_);}\n  #regular .st47{opacity:0.5;fill:url(#SVGID_49_);}\n  #regular .st48{opacity:0.5;fill:url(#SVGID_50_);}\n  #regular .st49{opacity:0.5;fill:url(#SVGID_51_);}\n  #regular .st00{\n    fill: none;\n    stroke: #F5D96C;\n    stroke-width: 2;\n    stroke-miterlimit: 10;\n  }\n  .font{\n    font-size: 36px;\n    font-family: 'MicrosoftYaHei';\n    fill:#F5D96C;\n  }", ""]);

	// exports


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// <template>
	// <g id="Scale_B">
	//   <path class="st2" d="M457.8,768.8c-0.6-0.2-1.3-0.5-1.9-0.7c-2.5,6.9-5,13.8-7.5,20.7c121.4,44.7,257.3-4.8,321.6-117
	//     c-6.4-3.7-12.7-7.3-19.1-11c-0.3,0.6-0.7,1.2-1,1.7c5.8,3.3,11.5,6.7,17.3,10c-15.4,26.5-34,48.7-57.4,68.5
	//     c-4.3-5.1-8.6-10.2-12.9-15.3c-0.5,0.4-1,0.9-1.5,1.3c4.3,5.1,8.6,10.2,12.9,15.3c-23.6,19.6-48.6,34.1-77.4,44.7
	//     c-2.3-6.3-4.6-12.5-6.8-18.8c-0.6,0.2-1.3,0.5-1.9,0.7c2.3,6.3,4.6,12.5,6.8,18.8c-28.8,10.4-57.4,15.4-88,15.5c0-6.7,0-13.3,0-20
	//     c-0.7,0-1.3,0-2,0c0,6.7,0,13.3,0,20c-30.6-0.1-59.2-5.1-88-15.5C453.3,781.3,455.5,775.1,457.8,768.8z"/>
	//   <path class="st2" d="M384.6,726.9c-4.3,5.1-8.6,10.2-12.9,15.3c-0.4,0.5-0.9,1-1.3,1.5C213.3,612.9,257.2,361,449.4,291.1
	//     c192.1-69.9,387.7,94.8,351.4,296c-7.2-1.3-14.4-2.5-21.7-3.8c0.1-0.7,0.2-1.3,0.3-2c6.6,1.2,13.1,2.3,19.7,3.5
	//     c5.2-30.2,5.2-59.2,0-89.4c-6.6,1.2-13.1,2.3-19.7,3.5c-0.1-0.7-0.2-1.3-0.3-2c6.6-1.2,13.1-2.3,19.7-3.5
	//     c-5.4-30.2-15.3-57.4-30.6-84c-5.8,3.3-11.5,6.7-17.3,10c-0.3-0.6-0.7-1.2-1-1.7c5.8-3.3,11.5-6.7,17.3-10
	//     c-15.4-26.5-34-48.7-57.4-68.5c-4.3,5.1-8.6,10.2-12.9,15.3c-0.5-0.4-1-0.9-1.5-1.3c4.3-5.1,8.6-10.2,12.9-15.3
	//     c-23.6-19.6-48.6-34.1-77.4-44.7c-2.3,6.3-4.6,12.5-6.8,18.8c-0.6-0.2-1.3-0.5-1.9-0.7c2.3-6.3,4.6-12.5,6.8-18.8
	//     c-28.8-10.4-57.4-15.4-88-15.5c0,6.7,0,13.3,0,20c-0.7,0-1.3,0-2,0c0-6.7,0-13.3,0-20c-30.6,0.1-59.2,5.1-88,15.5
	//     c2.3,6.3,4.6,12.5,6.8,18.8c-0.6,0.2-1.3,0.5-1.9,0.7c-2.3-6.3-4.6-12.5-6.8-18.8c-28.8,10.6-53.8,25.1-77.4,44.7
	//     c4.3,5.1,8.6,10.2,12.9,15.3c-0.5,0.4-1,0.9-1.5,1.3c-4.3-5.1-8.6-10.2-12.9-15.3c-23.4,19.8-42,42-57.4,68.5
	//     c5.8,3.3,11.5,6.7,17.3,10c-0.3,0.6-0.7,1.2-1,1.7c-5.8-3.3-11.5-6.7-17.3-10c-15.2,26.6-25.1,53.8-30.6,84
	//     c6.6,1.2,13.1,2.3,19.7,3.5c-0.1,0.7-0.2,1.3-0.3,2c-6.6-1.2-13.1-2.3-19.7-3.5c-5.2,30.2-5.2,59.2,0,89.4
	//     c6.6-1.2,13.1-2.3,19.7-3.5c0.1,0.7,0.2,1.3,0.3,2c-6.6,1.2-13.1,2.3-19.7,3.5c5.4,30.2,15.3,57.4,30.6,84
	//     c5.8-3.3,11.5-6.7,17.3-10c0.3,0.6,0.7,1.2,1,1.7c-5.8,3.3-11.5,6.7-17.3,10c15.4,26.5,34,48.7,57.4,68.5
	//     c4.3-5.1,8.6-10.2,12.9-15.3C383.5,726,384,726.5,384.6,726.9z"/>
	//   <path class="st2" d="M692.2,484.7c-30.6-84.1-123.6-127.4-207.6-96.8c-84.1,30.6-127.4,123.6-96.8,207.6
	//     c30.6,84.1,123.6,127.4,207.6,96.8C679.5,661.7,722.8,568.8,692.2,484.7z M594.7,690.5c-83,30.2-174.9-12.6-205.1-95.6
	//     c-30.2-83,12.6-174.9,95.6-205.1c83-30.2,174.9,12.6,205.1,95.6C720.6,568.4,677.7,660.2,594.7,690.5z"/>
	// </g>
	// <g id="Scale_BL2">
	//   <path class="st3_1" :fill="color" d="M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4
	//     C82,745.5,39.5,504.3,149.5,314.7z"/>
	// </g>
	// <g id="Scale_BL3">
	//   <linearGradient id="SVGID_1_1" gradientUnits="userSpaceOnUse" x1="214.4087" y1="932.3943" x2="44.3172" y2="297.604">
	//     <stop  offset="0" style="stop-color:#FFFFFF"/>
	//     <stop  offset="0.5" style="stop-color:#7A7A7A;stop-opacity:0"/>
	//     <stop  offset="1" style="stop-color:#000000"/>
	//   </linearGradient>
	//   <path class="st4_1" d="M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4
	//     C82,745.5,39.5,504.3,149.5,314.7z"/>
	// </g>
	// <g id="Scale_BL">
	//   <path class="st2"  d="M251.5,885.5C83.3,745,40.8,503.8,150.8,314.2c-12.1-7-24.2-14-36.4-21c-0.3,0.6-0.7,1.2-1,1.7
	//     c11.5,6.7,23.1,13.3,34.6,20c-10.2,17.7-19.1,35.9-26.8,54.9c-6.2-2.5-12.4-5-18.5-7.5c-0.3,0.6-0.5,1.2-0.7,1.9
	//     c6.2,2.5,12.4,5,18.5,7.5c-7.6,19-13.9,38.2-18.9,58.1c-6.5-1.6-12.9-3.2-19.4-4.8c-0.2,0.6-0.3,1.3-0.5,1.9
	//     c6.5,1.6,12.9,3.2,19.4,4.8c-4.9,19.9-8.4,39.8-10.6,60.1c-6.6-0.7-13.3-1.4-19.9-2.1c-0.1,0.7-0.1,1.3-0.2,2
	//     c6.6,0.7,13.3,1.4,19.9,2.1c-2.1,20.3-2.8,40.6-2.1,61c-6.7,0.2-13.3,0.5-20,0.7c0,0.7,0,1.3,0.1,2c6.7-0.2,13.3-0.5,20-0.7
	//     c0.8,20.4,2.9,40.6,6.4,60.7c-13.1,2.3-26.3,4.6-39.4,6.9c0.1,0.7,0.2,1.3,0.3,2c13.1-2.3,26.3-4.6,39.4-6.9
	//     c3.6,20.1,8.5,39.8,14.8,59.3c-6.3,2.1-12.7,4.1-19,6.2c0.2,0.6,0.4,1.3,0.6,1.9c6.3-2.1,12.7-4.1,19-6.2
	//     c6.4,19.4,14,38.2,22.9,56.6c-6,2.9-12,5.8-18,8.8c0.3,0.6,0.6,1.2,0.9,1.8c6-2.9,12-5.8,18-8.8c9,18.4,19.1,35.9,30.5,52.9
	//     c-5.5,3.7-11.1,7.5-16.6,11.2c0.4,0.6,0.7,1.1,1.1,1.7c5.5-3.7,11.1-7.5,16.6-11.2c11.5,16.9,23.9,32.9,37.6,48.1
	//     c-5,4.5-9.9,8.9-14.9,13.4c0.4,0.5,0.9,1,1.3,1.5c5-4.5,9.9-8.9,14.9-13.4c13.7,15.2,28.3,29.2,43.9,42.4
	//     c-8.6,10.2-17.1,20.4-25.7,30.6c0.5,0.4,1,0.9,1.5,1.3C233.5,906.9,242.5,896.2,251.5,885.5z"/>
	// </g>
	// <g id="Scale_BR2" v-show="!cancel">
	//   <path class="st3_1" :fill="color" d="M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1
	//     C900.2,190.4,1022.6,402.5,984.1,618.3z"/>
	// </g>
	// <g id="Scale_BR3" v-show="!cancel">
	//   <linearGradient id="SVGID_2_1" gradientUnits="userSpaceOnUse" x1="968.8124" y1="649.5213" x2="803.8889" y2="34.0186">
	//     <stop  offset="0" style="stop-color:#808080;stop-opacity:1"/>
	//     <stop  offset="1" style="stop-color:#808080;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st5_1" d="M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1
	//     C900.2,190.4,1022.6,402.5,984.1,618.3z"/>
	// </g>
	// <g id="Scale_BR" v-show="!cancel">
	//   <path class="st2" d="M983,619.2c38.5-215.7-83.9-427.8-290-502.3c4.8-13.2,9.6-26.3,14.4-39.5c0.6,0.2,1.3,0.5,1.9,0.7
	//     c-4.6,12.5-9.1,25.1-13.7,37.6c19.2,7,37.7,15.3,55.8,24.8c3.1-5.9,6.3-11.8,9.4-17.7c0.6,0.3,1.2,0.6,1.8,0.9
	//     c-3.1,5.9-6.3,11.8-9.4,17.7c18,9.6,35.2,20.4,51.8,32.4c3.9-5.4,7.8-10.8,11.8-16.2c0.5,0.4,1.1,0.8,1.6,1.2
	//     c-3.9,5.4-7.8,10.8-11.8,16.2c16.5,12.1,32,25.1,46.8,39.3c4.6-4.8,9.3-9.6,13.9-14.4c0.5,0.5,1,0.9,1.4,1.4
	//     c-4.6,4.8-9.3,9.6-13.9,14.4c14.7,14.2,28.2,29.3,40.9,45.4c5.3-4.1,10.5-8.2,15.8-12.3c0.4,0.5,0.8,1,1.2,1.6
	//     c-5.3,4.1-10.5,8.2-15.8,12.3c12.6,16.1,23.9,32.9,34.1,50.6c11.5-6.7,23.1-13.3,34.6-20c0.3,0.6,0.7,1.2,1,1.7
	//     c-11.5,6.7-23.1,13.3-34.6,20c10.2,17.7,19.1,35.9,26.8,54.9c6.2-2.5,12.4-5,18.5-7.5c0.3,0.6,0.5,1.2,0.7,1.9
	//     c-6.2,2.5-12.4,5-18.5,7.5c7.6,19,13.9,38.2,18.9,58.1c6.5-1.6,12.9-3.2,19.4-4.8c0.2,0.6,0.3,1.3,0.5,1.9
	//     c-6.5,1.6-12.9,3.2-19.4,4.8c4.9,19.9,8.4,39.8,10.6,60.1c6.6-0.7,13.3-1.4,19.9-2.1c0.1,0.7,0.1,1.3,0.2,2
	//     c-6.6,0.7-13.3,1.4-19.9,2.1c2.1,20.3,2.8,40.6,2.1,61c6.7,0.2,13.3,0.5,20,0.7c0,0.7,0,1.3-0.1,2c-6.7-0.2-13.3-0.5-20-0.7
	//     c-0.8,20.4-2.9,40.6-6.4,60.7c13.1,2.3,26.3,4.6,39.4,6.9c-0.1,0.7-0.2,1.3-0.3,2C1010.6,624.1,996.8,621.7,983,619.2z"/>
	// </g>
	// <g id="Color_B01" class="hover" @click="value={h:0,s:'90%',l:'40%'},index=0">
	//   <linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="810.9808" y1="540.1049" x2="940.1153" y2="540.1049">
	//     <stop  offset="9.271834e-008" style="stop-color:#990000"/>
	//     <stop  offset="0.2" style="stop-color:#990000"/>
	//     <stop  offset="1" style="stop-color:#990000;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st3" d="M811,586.9c41,7.2,82.1,14.5,123.1,21.7c8-46.3,8-90.7,0-136.9c-41,7.2-82.1,14.5-123.1,21.7
	//     C816.4,525,816.4,555.3,811,586.9z"/>
	// </g>
	// <g id="Color_B02" @click="value={h:0.0996,s:'70%',l:'50%'},index=1">
	//   <linearGradient id="SVGID_2_" gradientUnits="userSpaceOnUse" x1="794.638" y1="447.4195" x2="915.9847" y2="403.2529">
	//     <stop  offset="0" style="stop-color:#CC7A00"/>
	//     <stop  offset="0.2" style="stop-color:#CC7A00"/>
	//     <stop  offset="1" style="stop-color:#CC7A00;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st4" d="M810.6,491.4c41-7.2,82.1-14.5,123.1-21.7c-8.3-46.3-23.4-87.9-46.8-128.7c-36.1,20.8-72.2,41.7-108.3,62.5
	//     C794.6,431.3,804.9,459.8,810.6,491.4z"/>
	// </g>
	// <g id="Color_B03" @click="value={h:0.16666666,s:'80%',l:'50%'},index=2">
	//   <linearGradient id="SVGID_3_" gradientUnits="userSpaceOnUse" x1="747.5805" y1="365.9128" x2="846.5033" y2="282.9067">
	//     <stop  offset="0" style="stop-color:#cccc00"/>
	//     <stop  offset="0.2" style="stop-color:#cccc00"/>
	//     <stop  offset="1" style="stop-color:#cccc00;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st5" d="M777.6,401.7c36.1-20.8,72.2-41.7,108.3-62.5c-23.6-40.6-52.1-74.6-88-104.9c-26.8,31.9-53.6,63.8-80.3,95.8
	//     C742,350.8,761.5,374,777.6,401.7z"/>
	// </g>
	// <g id="Color_B04" @click="value={h:0.23311,s:'50%',l:'60%'},index=3">
	//   <linearGradient id="SVGID_4_" gradientUnits="userSpaceOnUse" x1="675.4836" y1="305.4167" x2="740.0508" y2="193.583">
	//     <stop  offset="0" style="stop-color:#5c9900"/>
	//     <stop  offset="0.2" style="stop-color:#5c9900"/>
	//     <stop  offset="1" style="stop-color:#5c9900;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st6" d="M716,328.8c26.8-31.9,53.6-63.8,80.3-95.8c-36.1-30.1-74.5-52.3-118.6-68.5c-14.3,39.2-28.5,78.3-42.8,117.5
	//     C665.1,293.1,691.3,308.3,716,328.8z"/>
	// </g>
	// <g id="Color_B05" @click="value={h:0.33333333333333,s:'100%',l:'30%'},index=4">
	//   <linearGradient id="SVGID_5_" gradientUnits="userSpaceOnUse" x1="587.0449" y1="273.228" x2="609.4689" y2="146.0551">
	//     <stop  offset="0" style="stop-color:#009900"/>
	//     <stop  offset="0.2" style="stop-color:#009900"/>
	//     <stop  offset="1" style="stop-color:#009900;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st7" d="M633.1,281.3c14.3-39.2,28.5-78.3,42.8-117.5c-44.2-16-87.9-23.7-134.9-23.8c0,41.7,0,83.3,0,125
	//     C573.1,265.2,602.9,270.5,633.1,281.3z"/>
	// </g>
	// <g id="Color_B06" @click="value={h : 0.430555556,s:'70%',l:'50%'},index=5">
	//   <linearGradient id="SVGID_6_" gradientUnits="userSpaceOnUse" x1="492.9301" y1="273.228" x2="470.5061" y2="146.0549">
	//     <stop  offset="0" style="stop-color:#00cc7a"/>
	//     <stop  offset="0.2" style="stop-color:#00cc7a"/>
	//     <stop  offset="1" style="stop-color:#00cc7a;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st8" d="M539,265.1c0-41.7,0-83.3,0-125c-47,0.1-90.7,7.8-134.9,23.8c14.3,39.2,28.5,78.3,42.8,117.5
	//     C477.1,270.5,506.9,265.2,539,265.1z"/>
	// </g>
	// <g id="Color_B07" @click="value={h :0.5,s:'50%',l:'50%'},index=6">
	//   <linearGradient id="SVGID_7_" gradientUnits="userSpaceOnUse" x1="404.4905" y1="305.4172" x2="339.9231" y2="193.5832">
	//     <stop  offset="9.271834e-008" style="stop-color:#00cccc"/>
	//     <stop  offset="0.2" style="stop-color:#00cccc"/>
	//     <stop  offset="1" style="stop-color:#00FFFF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st9" d="M445,282c-14.3-39.2-28.5-78.3-42.8-117.5c-44.1,16.2-82.5,38.4-118.6,68.5c26.8,31.9,53.6,63.8,80.3,95.8
	//     C388.6,308.3,414.9,293.1,445,282z"/>
	// </g>
	// <g id="Color_B08" @click="value={h : 0.5669,s:'50%',l:'60%'},index=7">
	//   <linearGradient id="SVGID_8_" gradientUnits="userSpaceOnUse" x1="332.3944" y1="365.9128" x2="233.4712" y2="282.9063">
	//     <stop  offset="1.854367e-007" style="stop-color:#007acc"/>
	//     <stop  offset="0.2" style="stop-color:#007acc"/>
	//     <stop  offset="1" style="stop-color:#007acc;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st10" d="M362.5,330.1c-26.8-31.9-53.6-63.8-80.3-95.8c-35.9,30.3-64.4,64.3-88,104.9c36.1,20.8,72.2,41.7,108.3,62.5
	//     C318.5,374,338,350.8,362.5,330.1z"/>
	// </g>
	// <g id="Color_B09" @click="value={h : 0.66666666666,s:'60%',l:'50%'},index=8">
	//   <linearGradient id="SVGID_9_" gradientUnits="userSpaceOnUse" x1="285.3359" y1="447.4191" x2="163.9899" y2="403.2528">
	//     <stop  offset="2.781550e-007" style="stop-color:#000099"/>
	//     <stop  offset="0.2" style="stop-color:#000099"/>
	//     <stop  offset="1" style="stop-color:#000099;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st11" d="M301.3,403.5c-36.1-20.8-72.2-41.7-108.3-62.5c-23.4,40.8-38.6,82.4-46.8,128.7c41,7.2,82.1,14.5,123.1,21.7
	//     C275,459.8,285.4,431.3,301.3,403.5z"/>
	// </g>
	// <g id="Color_B10" @click="value={h : 0.7663,s:'50%',l:'40%'},index=9">
	//   <linearGradient id="SVGID_10_" gradientUnits="userSpaceOnUse" x1="268.993" y1="540.1049" x2="139.8585" y2="540.1049">
	//     <stop  offset="2.781550e-007" style="stop-color:#7a00cc"/>
	//     <stop  offset="0.2" style="stop-color:#7a00cc"/>
	//     <stop  offset="1" style="stop-color:#7a00cc;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st12" d="M269,493.3c-41-7.2-82.1-14.5-123.1-21.7c-8,46.3-8,90.7,0,136.9c41-7.2,82.1-14.5,123.1-21.7
	//     C263.5,555.3,263.5,525,269,493.3z"/>
	// </g>
	// <g id="Color_B11" @click="value={h:0.83333333333,s:'60%',l:'50%'},index=10">
	//   <linearGradient id="SVGID_11_" gradientUnits="userSpaceOnUse" x1="285.3358" y1="632.7901" x2="163.9899" y2="676.9564">
	//     <stop  offset="3.708734e-007" style="stop-color:#FF00FF"/>
	//     <stop  offset="0.2" style="stop-color:#FF00FF"/>
	//     <stop  offset="1" style="stop-color:#FF00FF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st13" d="M269.3,588.8c-41,7.2-82.1,14.5-123.1,21.7c8.3,46.3,23.4,87.9,46.8,128.7c36.1-20.8,72.2-41.7,108.3-62.5
	//     C285.4,648.9,275,620.4,269.3,588.8z"/>
	// </g>
	// <g id="Color_B12" @click="value={h:0.9,s:'50%',l:'80%'},index=11">
	//   <linearGradient id="SVGID_12_" gradientUnits="userSpaceOnUse" x1="332.3944" y1="714.2958" x2="233.4712" y2="797.3022">
	//     <stop  offset="3.708734e-007" style="stop-color:#ff99d6"/>
	//     <stop  offset="0.2" style="stop-color:#ff99d6"/>
	//     <stop  offset="1" style="stop-color:#ff99d6;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st14" d="M302.3,678.5c-36.1,20.8-72.2,41.7-108.3,62.5c23.6,40.6,52.1,74.6,88,104.9c26.8-31.9,53.6-63.8,80.3-95.8
	//     C338,729.4,318.5,706.2,302.3,678.5z"/>
	// </g>
	// <g id="Color_B13" @click="value={h:0.123,s:'62%',l:'70%'},index=12">
	//   <linearGradient id="SVGID_13_" gradientUnits="userSpaceOnUse" x1="492.9301" y1="806.9812" x2="470.5062" y2="934.1538">
	//     <stop  offset="2.737399e-007" style="stop-color:#d8b656"/>
	//     <stop  offset="0.2" style="stop-color:#d8b656"/>
	//     <stop  offset="1" style="stop-color:#d8b656;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st15" d="M446.9,798.9c-14.3,39.2-28.5,78.3-42.8,117.5c44.2,16,87.9,23.7,134.9,23.8c0-41.7,0-83.3,0-125
	//     C506.9,815,477.1,809.7,446.9,798.9z"/>
	// </g>
	// <g id="Color_B14" @click="value={h:0,s:'0%',l:'70%'},index=13">
	//   <linearGradient id="SVGID_14_" gradientUnits="userSpaceOnUse" x1="587.0449" y1="806.9812" x2="609.4688" y2="934.1536">
	//     <stop  offset="3.664582e-007" style="stop-color:#999999"/>
	//     <stop  offset="0.2" style="stop-color:#999999"/>
	//     <stop  offset="1" style="stop-color:#999999;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st16" d="M541,815.1c0,41.7,0,83.3,0,125c47-0.1,90.7-7.8,134.9-23.8c-14.3-39.2-28.5-78.3-42.8-117.5
	//     C602.9,809.7,573.1,815,541,815.1z"/>
	// </g>
	// <g id="Color_B15"  @click="value={h:0,s:'0%',l:'10%'},index=14">
	//   <linearGradient id="SVGID_15_" gradientUnits="userSpaceOnUse" x1="675.4838" y1="774.7922" x2="740.0508" y2="886.6255">
	//     <stop  offset="4.591765e-007" style="stop-color:#4d4d4d"/>
	//     <stop  offset="0.2" style="stop-color:#4d4d4d"/>
	//     <stop  offset="1" style="stop-color:#4d4d4d;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st17" d="M635,798.2c14.3,39.2,28.5,78.3,42.8,117.5c44.1-16.2,82.5-38.4,118.6-68.5c-26.8-31.9-53.6-63.8-80.3-95.8
	//     C691.3,771.9,665.1,787.1,635,798.2z"/>
	// </g>
	// <g id="Color_B16" @click="value={h:0,s:'0%',l:'100%'},index=15">
	//   <linearGradient id="SVGID_16_" gradientUnits="userSpaceOnUse" x1="747.5805" y1="714.2958" x2="846.5033" y2="797.3018">
	//     <stop  offset="3.664582e-007" style="stop-color:#e5e5e5"/>
	//     <stop  offset="0.2" style="stop-color:#e5e5e5"/>
	//     <stop  offset="1" style="stop-color:#e5e5e5;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st18" d="M717.5,750.1c26.8,31.9,53.6,63.8,80.3,95.8c35.9-30.3,64.4-64.3,88-104.9c-36.1-20.8-72.2-41.7-108.3-62.5
	//     C761.5,706.2,742,729.4,717.5,750.1z"/>
	// </g>
	// <g id="Pin_BL" :transform="'rotate(' + BLangle + ' 540 540)'">
	//   <g>
	//     <linearGradient id="SVGID_171_" gradientUnits="userSpaceOnUse" x1="57.5965" y1="530.0045" x2="20.0443" y2="530.0045">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_171_);" d="M20,532.4c0-1.8,0.1-3.6,0.1-5.4c9.6,0.6,19.3,1.2,28.9,1.9c2.8,1.4,5.7,2.8,8.5,4.1    C45.1,532.8,32.6,532.6,20,532.4z"/>
	//     <linearGradient id="SVGID_181_" gradientUnits="userSpaceOnUse" x1="77.9868" y1="540.1041" x2="19.9875" y2="540.1041">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_181_);" d="M20,543.8c0-2.5,0-4.9,0-7.4c19.3,0.3,38.7,0.6,58,0.9c0,1.9,0,3.7,0,5.6C58.7,543.2,39.3,543.5,20,543.8z"/>
	//     <linearGradient id="SVGID_191_" gradientUnits="userSpaceOnUse" x1="57.5965" y1="550.2053" x2="20.0443" y2="550.2053">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_191_);" d="M20.2,553.2c0-1.8-0.1-3.6-0.1-5.4c12.5-0.2,25-0.4,37.6-0.6c-2.8,1.4-5.7,2.8-8.5,4.1    C39.4,552,29.8,552.6,20.2,553.2z"/>
	//   </g>
	// </g>
	// <g id="Pin_BR"  v-show = "!cancel" :transform="'rotate(' + BRangle + ' 540 540)'">
	//   <g xmlns="http://www.w3.org/2000/svg">
	//     <linearGradient id="SVGID_101_" gradientUnits="userSpaceOnUse" x1="1022.4805" y1="550.2055" x2="1060.0327" y2="550.2055">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_101_)" d="M1059.9,553.2c0-1.8,0.1-3.6,0.1-5.4c-12.5-0.2-25-0.4-37.6-0.6c2.8,1.4,5.7,2.8,8.5,4.1    C1040.6,552,1050.3,552.6,1059.9,553.2z"/>
	//     <linearGradient id="SVGID_111_" gradientUnits="userSpaceOnUse" x1="1002.0901" y1="540.1044" x2="1060.0895" y2="540.1044">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_111_)" d="M1060.1,543.8c0-2.5,0-4.9,0-7.4c-19.3,0.3-38.7,0.6-58,0.9c0,1.9,0,3.7,0,5.6    C1021.4,543.2,1040.7,543.5,1060.1,543.8z"/>
	//     <linearGradient id="SVGID_121_" gradientUnits="userSpaceOnUse" x1="1022.4805" y1="530.0047" x2="1060.0327" y2="530.0047">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_121_)" d="M1060,532.4c0-1.8-0.1-3.6-0.1-5.4c-9.6,0.6-19.3,1.2-28.9,1.9c-2.8,1.4-5.7,2.8-8.5,4.1    C1035,532.8,1047.5,532.6,1060,532.4z"/>
	//   </g>
	// </g>
	// <g id="Pin_B" :transform="'rotate(' + angles[index] + ' 540 540)'">
	//   <g>
	//     <linearGradient id="SVGID_231_" gradientUnits="userSpaceOnUse" x1="875.485" y1="539.9995" x2="516.9875" y2="539.9995">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_231_)" d="M561.2,531.1c-9.7-23.2-44.2-16.3-44.2,8.9s34.5,32.1,44.2,8.9c0.2-0.4,0.3-0.8,0.5-1.2    c104.6-1.6,209.2-3.3,313.8-4.9c0-1.9,0-3.7,0-5.6c-104.6-1.6-209.2-3.3-313.8-4.9C561.5,531.9,561.4,531.5,561.2,531.1z"/>
	//     <linearGradient id="SVGID_241_" gradientUnits="userSpaceOnUse" x1="855.0947" y1="540" x2="508.9872" y2="540">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_241_)" d="M846.6,528.8c2.8,1.4,5.7,2.8,8.5,4.1c-96.9-1.5-193.8-3-290.7-4.5C552,502.4,513,511.2,513,540    c0,28.8,39,37.6,51.4,11.6c96.9-1.5,193.8-3,290.7-4.5c-2.8,1.4-5.7,2.8-8.5,4.1c-101.5,6.6-203,13.1-304.6,19.7    c-44,2.8-44-64.7,0-61.9C643.5,515.6,745,522.2,846.6,528.8z"/>
	//   </g>
	// </g>
	// <g id="Monitor_B">
	//   <radialGradient id="SVGID_21_" cx="539.9872" cy="540.1043" r="150.0408" gradientUnits="userSpaceOnUse">
	//     <stop  offset="0" style="stop-color:#000000"/>
	//     <stop  offset="1" style="stop-color:#000000;stop-opacity:0.5"/>
	//   </radialGradient>
	//   <circle class="st23" cx="540" cy="540.1" r="150"/>
	//   <linearGradient id="SVGID_22_" gradientUnits="userSpaceOnUse" x1="539.987" y1="392.0641" x2="539.987" y2="688.1447">
	//     <stop  class="pad" offset="9.271834e-008" :style="'stop-color:' + color "/>
	//     <stop  offset="1" :style="'stop-color:' + color"/>
	//   </linearGradient>
	//   <circle class="st24" cx="540" cy="540.1" r="148" @click="colorSet='diffuse'"/>
	//   <linearGradient id="SVGID_23_" gradientUnits="userSpaceOnUse" x1="539.9875" y1="683.535" x2="539.9875" y2="555.6201">
	//     <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//     <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st25" d="M540,555.6c36.6,0,94.1,17.1,94.1,64c0,46.8-57.5,64-94.1,64c-36.6,0-94.1-17.1-94.1-64
	//     C445.9,572.7,503.4,555.6,540,555.6z" @click="colorSet='shadow'"/>
	//   <linearGradient id="SVGID_24_" gradientUnits="userSpaceOnUse" x1="539.9875" y1="396.6736" x2="539.9875" y2="524.5886">
	//     <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//     <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st26" d="M540,524.6c36.6,0,94.1-17.1,94.1-64c0-46.8-57.5-64-94.1-64c-36.6,0-94.1,17.1-94.1,64
	//     C445.9,507.5,503.4,524.6,540,524.6z" @click="colorSet='highlight'"/>
	//   <linearGradient id="SVGID_25_" gradientUnits="userSpaceOnUse" x1="539.9869" y1="400.9027" x2="539.9869" y2="450.9808">
	//     <stop  offset="0" style="stop-color:#FFFFFF;stop-opacity:0.6"/>
	//     <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st27" d="M540,451c10.1,0,19.6-1.3,29.2-5c7.9-3,19.6-9.3,19.6-20.1c0-10.7-11.7-17-19.6-20.1c-9.6-3.7-19-5-29.1-5
	//     c-10.1,0-19.6,1.3-29.2,5c-7.9,3-19.6,9.3-19.6,20.1c0,10.7,11.7,17,19.6,20.1C520.4,449.7,529.9,451,540,451z"/>
	//     <text xmlns="http://www.w3.org/2000/svg" transform="matrix(1 0 0 1 484.3381 482)">
	//       <tspan x="0" y="0" style="font-size:36px;font-family:'HYg1gj'" v-text="change.name"></tspan>
	//       <tspan x="-40" y="130" style="font-size:120px;font-family:'HYg1gj'" v-text="change.value"></tspan>
	//       <tspan x="-20" y="120" style="font-size:36px;font-family:'HYg1gj'" v-text="change.hover"></tspan>
	//     </text>
	// </g>
	// <g id="Color_P">
	// </g>
	// <g id="Metrial_Matt"  @click="material='matte'" @mouseover="save=change,change={hover:'哑光'}" @mouseout="change=save">
	//   <g>
	//     <path class="st2" d="M451.8,982.1c-1.4-16.5-16-28.7-32.5-27.3c-16.5,1.4-28.7,16-27.3,32.5c1.4,16.5,16,28.7,32.5,27.3
	//       C441,1013.1,453.2,998.6,451.8,982.1z M424.3,1012.6c-15.4,1.3-29-10-30.3-25.5c-1.3-15.4,10-29,25.5-30.3
	//       c15.4-1.3,29,10,30.3,25.5C451.1,997.7,439.7,1011.2,424.3,1012.6z"/>
	//     <linearGradient id="SVGID_26_" gradientUnits="userSpaceOnUse" x1="421.8964" y1="956.6859" x2="421.8964" y2="1012.6892">
	//       <stop  offset="9.271834e-008" style="stop-color:#808080;stop-opacity:0.9"/>
	//       <stop  offset="1" style="stop-color:#1A1A1A;stop-opacity:0.9"/>
	//     </linearGradient>
	//     <circle class="st28" cx="421.9" cy="984.7" r="28"/>
	//   </g>
	// </g>
	// <g id="Metrial_Paint" @click="material = 'normal'" @mouseover="save=change,change={hover:'普通漆'}" @mouseout="change=save">
	//   <g>
	//     <path class="st2" d="M529.9,990.7c-4.3-16-20.7-25.5-36.7-21.2c-16,4.3-25.5,20.7-21.2,36.7c4.3,16,20.7,25.5,36.7,21.2
	//       C524.7,1023.1,534.2,1006.7,529.9,990.7z M508.1,1025.5c-14.9,4-30.3-4.9-34.3-19.8c-4-14.9,4.9-30.3,19.8-34.3
	//       c14.9-4,30.3,4.9,34.3,19.8C531.9,1006.1,523.1,1021.5,508.1,1025.5z"/>
	//     <linearGradient id="SVGID_27_" gradientUnits="userSpaceOnUse" x1="500.8916" y1="970.433" x2="500.8916" y2="1026.4468">
	//       <stop  offset="9.271834e-008" style="stop-color:#808080;stop-opacity:0.9"/>
	//       <stop  offset="1" style="stop-color:#1A1A1A;stop-opacity:0.9"/>
	//     </linearGradient>
	//     <circle class="st29" cx="500.9" cy="998.4" r="28"/>
	//     <linearGradient id="SVGID_28_" gradientUnits="userSpaceOnUse" x1="500.892" y1="971.3044" x2="500.892" y2="990.4042">
	//       <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//       <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st30" d="M500.9,990.4c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5s-16.6,1.7-16.6,9.5
	//       C484.3,988.7,495.3,990.4,500.9,990.4z"/>
	//   </g>
	// </g>
	// <g id="Material_Electroplate"  @click="material = 'electroplate'" @mouseover="save=change,change={hover:'电镀漆'}" @mouseout="change=save">
	//   <g>
	//     <linearGradient id="SVGID_29_" gradientUnits="userSpaceOnUse" x1="581.0947" y1="970.2589" x2="581.0947" y2="1026.2723">
	//       <stop  offset="9.271834e-008" style="stop-color:#808080;stop-opacity:0.9"/>
	//       <stop  offset="1" style="stop-color:#1A1A1A;stop-opacity:0.9"/>
	//     </linearGradient>
	//     <circle class="st31" cx="581.1" cy="998.3" r="28"/>
	//     <linearGradient id="SVGID_30_" gradientUnits="userSpaceOnUse" x1="581.0749" y1="971.1303" x2="581.0749" y2="995.3297">
	//       <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//       <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st32" d="M581.1,995.3c6.9,0,17.8-3.2,17.8-12.1s-10.9-12.1-17.8-12.1c-6.9,0-17.8,3.2-17.8,12.1
	//       S574.2,995.3,581.1,995.3z"/>
	//     <linearGradient id="SVGID_31_" gradientUnits="userSpaceOnUse" x1="581.0755" y1="971.9307" x2="581.0755" y2="981.5522">
	//       <stop  offset="0" style="stop-color:#FFFFFF;stop-opacity:0.6"/>
	//       <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st33" d="M581.1,981.4c4.2,0,9.2,1.5,9.2-4.7c0-3.9-5-4.7-9.2-4.7c-4.2,0-9.2,1-9.2,4.7
	//       C571.9,982.9,576.9,981.4,581.1,981.4z"/>
	//     <path class="st2" d="M608.3,985.6c-7-15-24.9-21.5-39.9-14.5c-15,7-21.5,24.9-14.5,39.9c7,15,24.9,21.5,39.9,14.5
	//       C608.8,1018.5,615.3,1000.6,608.3,985.6z M592.9,1023.6c-14,6.5-30.7,0.5-37.2-13.5c-6.5-14-0.5-30.7,13.5-37.2
	//       c14-6.5,30.7-0.5,37.2,13.5C613,1000.4,606.9,1017.1,592.9,1023.6z"/>
	//   </g>
	// </g>
	// <!--g id="Material_Frosting"  @click="material = 'matting'" @mouseover="save=change,change={hover:'磨砂'}" @mouseout="change=save">
	//   <g>
	//     <path class="st2" d="M684.6,967c-9.5-13.6-28.2-16.9-41.8-7.4c-13.6,9.5-16.9,28.2-7.4,41.8c9.5,13.6,28.2,16.9,41.8,7.4
	//       C690.8,999.2,694.1,980.5,684.6,967z M676.1,1007.1c-12.7,8.9-30.1,5.8-39-6.9c-8.9-12.7-5.8-30.1,6.9-39
	//       c12.7-8.9,30.1-5.8,39,6.9C691.8,980.8,688.7,998.2,676.1,1007.1z"/>
	//     <g>
	//       <defs>
	//         <circle id="SVGID_32_" cx="660" cy="984.2" r="28"/>
	//       </defs>
	//       <clipPath id="SVGID_33_">
	//         <use xlink:href="#SVGID_32_"  style="overflow:visible;"/>
	//       </clipPath>
	//       <g class="st34">

	//           <image style="overflow:visible;" width="200" height="200" xlink:href="materials/matting.png" transform="matrix(0.4233 0 0 0.4233 617.6789 942.357)">
	//         </image>
	//       </g>
	//     </g>
	//     <linearGradient id="SVGID_34_" gradientUnits="userSpaceOnUse" x1="660.0095" y1="957.0345" x2="660.0095" y2="976.1343">
	//       <stop  offset="0" style="stop-color:#FFFFFF;stop-opacity:0.2"/>
	//       <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st35" d="M660,976.1c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5
	//       C643.4,974.4,654.4,976.1,660,976.1z"/>
	//   </g>
	// </g-->
	// <!--g id="Material_Brushed"  @click="material = 'carbon'" @mouseover="save=change,change={hover:'碳纤维'}" @mouseout="change=save">
	//   <g>
	//     <g>
	//       <defs>
	//         <circle id="SVGID_35_" cx="735.3" cy="956.6" r="28"/>
	//       </defs>
	//       <clipPath id="SVGID_36_">
	//         <use xlink:href="#SVGID_35_"  style="overflow:visible;"/>
	//       </clipPath>
	//       <g class="st36">

	//           <image style="overflow:visible;" width="200" height="200" xlink:href="materials/carbon.png" transform="matrix(0.6852 0 0 0.6852 666.7819 888.5193)">
	//         </image>
	//       </g>
	//     </g>
	//     <path class="st2" d="M756.5,935.4c-11.7-11.7-30.7-11.7-42.4,0c-11.7,11.7-11.7,30.7,0,42.4c11.7,11.7,30.7,11.7,42.4,0
	//       C768.2,966.1,768.2,947.1,756.5,935.4z M755.1,976.4c-10.9,10.9-28.7,10.9-39.6,0c-10.9-10.9-10.9-28.7,0-39.6
	//       c10.9-10.9,28.7-10.9,39.6,0C766,947.7,766,965.4,755.1,976.4z"/>
	//     <linearGradient id="SVGID_37_" gradientUnits="userSpaceOnUse" x1="735.2972" y1="929.4463" x2="735.2972" y2="948.5473">
	//       <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//       <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st37" d="M735.3,948.5c5.6,0,16.6-1.7,16.6-9.6c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5
	//       C718.7,946.8,729.7,948.5,735.3,948.5z"/>
	//   </g>
	// </g-->
	// <!--g id="Material_Carbonfibre"  @click="material = 'drawbench'" @mouseover="save=change,change={hover:'拉丝'}" @mouseout="change=save">
	//   <g>
	//     <g>
	//       <defs>
	//         <circle id="SVGID_38_" cx="804.6" cy="916.3" r="28"/>
	//       </defs>
	//       <clipPath id="SVGID_39_">
	//         <use xlink:href="#SVGID_38_"  style="overflow:visible;"/>
	//       </clipPath>
	//       <g class="st38">

	//           <image style="overflow:visible;" width="200" height="200" xlink:href="materials/drawbench.png" transform="matrix(0.6029 0 0 0.6029 744.3639 853.8486)">
	//         </image>
	//       </g>
	//     </g>
	//     <path class="st2" d="M821.9,891.8c-13.6-9.5-32.3-6.2-41.8,7.4c-9.5,13.6-6.2,32.3,7.4,41.8c13.6,9.5,32.3,6.2,41.8-7.4
	//       C838.7,920,835.4,901.3,821.9,891.8z M827.6,932.4c-8.9,12.7-26.3,15.7-39,6.9c-12.7-8.9-15.7-26.3-6.9-39
	//       c8.9-12.7,26.3-15.7,39-6.9C833.4,902.3,836.5,919.7,827.6,932.4z"/>
	//     <linearGradient id="SVGID_40_" gradientUnits="userSpaceOnUse" x1="804.6505" y1="889.2046" x2="804.6505" y2="908.3044">
	//       <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//       <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st39" d="M804.7,908.3c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5
	//       C788.1,906.6,799.1,908.3,804.7,908.3z"/>
	//   </g>
	// </g-->
	// <g id="Material_Chameleon"  @click="material = 'discolor'" @mouseover="save=change,change={hover:'变色'}" @mouseout="change=save">
	//   <g>
	//     <linearGradient id="SVGID_41_" gradientUnits="userSpaceOnUse" x1="865.9626" y1="836.6588" x2="865.9626" y2="892.6722">
	//       <stop  offset="0" style="stop-color:#FFFFFF;stop-opacity:0.8"/>
	//       <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//     </linearGradient>
	//     <circle class="st40" cx="866" cy="864.7" r="28"/>
	//     <linearGradient id="SVGID_42_" gradientUnits="userSpaceOnUse" x1="865.9626" y1="891.8015" x2="865.9626" y2="872.7005">
	//       <stop  offset="0" style="stop-color:#0000FF;stop-opacity:0.5"/>
	//       <stop  offset="1" style="stop-color:#0000FF;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st41" d="M866,872.7c5.6,0,16.6,1.7,16.6,9.6c0,7.8-11,9.5-16.6,9.5c-5.6,0-16.6-1.7-16.6-9.5
	//       C849.4,874.4,860.4,872.7,866,872.7z"/>
	//     <path class="st2" d="M878.6,837.5c-15-7-32.9-0.5-39.9,14.5c-7,15-0.5,32.9,14.5,39.9c15,7,32.9,0.5,39.9-14.5
	//       C900.2,862.3,893.7,844.5,878.6,837.5z M891.3,876.5c-6.5,14-23.2,20.1-37.2,13.5c-14-6.5-20.1-23.2-13.5-37.2
	//       c6.5-14,23.2-20.1,37.2-13.5C891.8,845.8,897.9,862.5,891.3,876.5z"/>
	//     <linearGradient id="SVGID_43_" gradientUnits="userSpaceOnUse" x1="865.9626" y1="837.5306" x2="865.9626" y2="856.6304">
	//       <stop  offset="0" style="stop-color:#FF0000;stop-opacity:0.5"/>
	//       <stop  offset="1" style="stop-color:#FF0000;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st42" d="M866,856.6c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5S860.4,856.6,866,856.6z
	//       "/>
	//   </g>
	// </g>
	// <g id="To_Pro" @click="current = 'pro'" @mouseover="save=change,change={hover:'高级模式'}" @mouseout="change=save">
	//   <g>
	//     <path class="st2" d="M925.1,774.2c-16-4.3-32.5,5.2-36.7,21.2c-4.3,16,5.2,32.5,21.2,36.7c16,4.3,32.5-5.2,36.7-21.2
	//       C950.6,794.9,941.1,778.4,925.1,774.2z M944.4,810.4c-4,14.9-19.4,23.8-34.3,19.8c-14.9-4-23.8-19.4-19.8-34.3
	//       c4-14.9,19.4-23.8,34.3-19.8C939.6,780.1,948.4,795.4,944.4,810.4z"/>
	//     <g>
	//       <defs>
	//         <circle id="SVGID_44_" cx="917.4" cy="803.1" r="28"/>
	//       </defs>
	//       <clipPath id="SVGID_45_">
	//         <use xlink:href="#SVGID_44_"  style="overflow:visible;"/>
	//       </clipPath>
	//       <g class="st43">

	//           <image style="overflow:visible;" width="851" height="850" xlink:href="hue-ring.png" transform="matrix(5.837880e-002 5.837880e-002 -5.837880e-002 5.837880e-002 917.3402 753.4789)">
	//         </image>
	//       </g>
	//     </g>
	//   </g>
	// </g>
	// <g id="Temp_Color_01"  @click="value = colorpad[0]"  @mouseover="save=change,change={hover:'历史记录'}" @mouseout="change=save">
	//   <g>
	//     <path class="st2" d="M226.7,188.4c-15-7-32.9-0.5-39.9,14.5c-7,15-0.5,32.9,14.5,39.9c15,7,32.9,0.5,39.9-14.5
	//       C248.2,213.2,241.7,195.4,226.7,188.4z M239.4,227.4c-6.5,14-23.2,20.1-37.2,13.5c-14-6.5-20.1-23.2-13.5-37.2
	//       c6.5-14,23.2-20.1,37.2-13.5C239.9,196.7,245.9,213.4,239.4,227.4z"/>
	//     <linearGradient id="SVGID_46_" gradientUnits="userSpaceOnUse" x1="214.0118" y1="187.5365" x2="214.0118" y2="243.5498">
	//       <stop  offset="3.708734e-007" :style="'stop-color:'+toHex(colorpad[0])"/>
	//       <stop  offset="1" :style="'stop-color:'+toHex(colorpad[0])+';stop-opacity:0.5'"/>
	//     </linearGradient>
	//     <circle class="st44" cx="214" cy="215.5" r="28"/>
	//   </g>
	// </g>
	// <g id="Temp_Color_02"  @click="value = colorpad[1]"  @mouseover="save=change,change={hover:'历史记录'}" @mouseout="change=save">
	//   <g>
	//     <path class="st2" d="M292.5,139.3c-13.6-9.5-32.3-6.2-41.8,7.4c-9.5,13.6-6.2,32.3,7.4,41.8c13.6,9.5,32.3,6.2,41.8-7.4
	//       C309.4,167.5,306.1,148.8,292.5,139.3z M298.3,179.9c-8.9,12.7-26.3,15.7-39,6.9c-12.7-8.9-15.7-26.3-6.9-39
	//       c8.9-12.7,26.3-15.7,39-6.9C304.1,149.8,307.1,167.3,298.3,179.9z"/>
	//     <linearGradient id="SVGID_47_" gradientUnits="userSpaceOnUse" x1="275.3235" y1="135.8667" x2="275.3235" y2="191.8716">
	//       <stop  offset="0" :style="'stop-color:'+toHex(colorpad[1])"/>
	//       <stop  offset="1" :style="'stop-color:'+toHex(colorpad[1])+';stop-opacity:0.5'"/>
	//     </linearGradient>
	//     <circle class="st45" cx="275.3" cy="163.9" r="28"/>
	//   </g>
	// </g>
	// <g id="Temp_Color_03"  @click="value= colorpad[2]"  @mouseover="save=change,change={hover:'历史记录'}" @mouseout="change=save">
	//   <g>
	//     <path class="st2" d="M365.9,102.4c-11.7-11.7-30.7-11.7-42.4,0c-11.7,11.7-11.7,30.7,0,42.4c11.7,11.7,30.7,11.7,42.4,0
	//       C377.6,133.1,377.6,114.1,365.9,102.4z M364.5,143.4c-10.9,10.9-28.7,10.9-39.6,0c-10.9-10.9-10.9-28.7,0-39.6
	//       c10.9-10.9,28.7-10.9,39.6,0C375.4,114.8,375.4,132.5,364.5,143.4z"/>
	//     <linearGradient id="SVGID_48_" gradientUnits="userSpaceOnUse" x1="344.6773" y1="95.6269" x2="344.6773" y2="151.6267">
	//       <stop  offset="2.737399e-007" :style="'stop-color:'+toHex(colorpad[2])"/>
	//       <stop  offset="1" :style="'stop-color:'+toHex(colorpad[2])+';stop-opacity:0.5'"/>
	//     </linearGradient>
	//     <circle class="st46" cx="344.7" cy="123.6" r="28"/>
	//   </g>
	// </g>
	// <g id="Temp_Color_04"  @click="value = colorpad[3]"  @mouseover="save=change,change={hover:'历史记录'}" @mouseout="change=save">
	//   <g>
	//     <path class="st2" d="M444.5,78.8c-9.5-13.6-28.2-16.9-41.8-7.4c-13.6,9.5-16.9,28.2-7.4,41.8c9.5,13.6,28.2,16.9,41.8,7.4
	//       C450.7,111.1,454,92.4,444.5,78.8z M436,119c-12.7,8.9-30.1,5.8-39-6.9c-8.9-12.7-5.8-30.1,6.9-39c12.7-8.9,30.1-5.8,39,6.9
	//       C451.8,92.6,448.7,110.1,436,119z"/>
	//     <linearGradient id="SVGID_49_" gradientUnits="userSpaceOnUse" x1="419.9649" y1="68.0361" x2="419.9649" y2="124.041">
	//       <stop  offset="3.708734e-007" :style="'stop-color:'+toHex(colorpad[3])"/>
	//       <stop  offset="1" :style="'stop-color:'+toHex(colorpad[3])+';stop-opacity:0.5'"/>
	//     </linearGradient>
	//     <circle class="st47" cx="420" cy="96" r="28"/>
	//   </g>
	// </g>
	// <g id="Temp_Color_05"  @click="value = colorpad[4]"  @mouseover="save=change,change={hover:'历史记录'}" @mouseout="change=save">
	//   <g>
	//     <path class="st2" d="M526.1,69.3c-7-15-24.9-21.5-39.9-14.5c-15,7-21.5,24.9-14.5,39.9c7,15,24.9,21.5,39.9,14.5
	//       C526.6,102.1,533.1,84.3,526.1,69.3z M510.7,107.3c-14,6.5-30.7,0.5-37.2-13.5c-6.5-14-0.5-30.7,13.5-37.2
	//       c14-6.5,30.7-0.5,37.2,13.5C530.8,84.1,524.7,100.8,510.7,107.3z"/>
	//     <linearGradient id="SVGID_50_" gradientUnits="userSpaceOnUse" x1="498.8995" y1="53.9367" x2="498.8995" y2="109.9501">
	//       <stop  offset="2.737399e-007" :style="'stop-color:'+toHex(colorpad[4])"/>
	//       <stop  offset="1" :style="'stop-color:'+toHex(colorpad[4])+';stop-opacity:0.5'"/>
	//     </linearGradient>
	//     <circle class="st48" cx="498.9" cy="81.9" r="28"/>
	//   </g>
	// </g>
	// <g id="Temp_Color_06"  @click="value = colorpad[5]"  @mouseover="save=change,change={hover:'历史记录'}" @mouseout="change=save">
	//   <g>
	//     <path class="st2" d="M608.1,74c-4.3-16-20.7-25.5-36.7-21.2c-16,4.3-25.5,20.7-21.2,36.7s20.7,25.5,36.7,21.2
	//       C602.9,106.5,612.3,90,608.1,74z M586.3,108.8c-14.9,4-30.3-4.9-34.3-19.8c-4-14.9,4.9-30.3,19.8-34.3c14.9-4,30.3,4.9,34.3,19.8
	//       C610.1,89.5,601.3,104.8,586.3,108.8z"/>
	//     <linearGradient id="SVGID_51_" gradientUnits="userSpaceOnUse" x1="579.0825" y1="53.7619" x2="579.0825" y2="109.776">
	//       <stop  offset="3.708734e-007" :style="'stop-color:'+toHex(colorpad[5])"/>
	//       <stop  offset="1" :style="'stop-color:'+toHex(colorpad[5])+';stop-opacity:0.5'"/>
	//     </linearGradient>
	//     <circle class="st49" cx="579.1" cy="81.8" r="28"/>
	//   </g>
	// </g>
	// </template>
	// <style>
	// .v-colors .color path {
	//   stroke: #888;
	//   cursor: pointer;
	// }
	//   #regular .st4_1{fill:url(#SVGID_1_1);}
	//   #regular .st5_1{fill:url(#SVGID_2_1);}
	//   #regular .st0{display:none;}
	//   #regular .st1{display:inline;fill:#333333;}
	//   #regular .st2{fill:#F5D96C;}
	//   #regular .st3{fill:url(#SVGID_1_);}
	//   #regular .st4{fill:url(#SVGID_2_);}
	//   #regular .st5{fill:url(#SVGID_3_);}
	//   #regular .st6{fill:url(#SVGID_4_);}
	//   #regular .st7{fill:url(#SVGID_5_);}
	//   #regular .st8{fill:url(#SVGID_6_);}
	//   #regular .st9{fill:url(#SVGID_7_);}
	//   #regular .st10{fill:url(#SVGID_8_);}
	//   #regular .st11{fill:url(#SVGID_9_);}
	//   #regular .st12{fill:url(#SVGID_10_);}
	//   #regular .st13{fill:url(#SVGID_11_);}
	//   #regular .st14{fill:url(#SVGID_12_);}
	//   #regular .st15{fill:url(#SVGID_13_);}
	//   #regular .st16{fill:url(#SVGID_14_);}
	//   #regular .st17{fill:url(#SVGID_15_);}
	//   #regular .st18{fill:url(#SVGID_16_);}
	//   #regular .st19{fill:url(#SVGID_17_);}
	//   #regular .st20{fill:url(#SVGID_18_);}
	//   #regular .st21{fill:none;stroke:url(#SVGID_19_);stroke-miterlimit:10;}
	//   #regular .st22{fill:url(#SVGID_20_);}
	//   #regular .st23{fill:url(#SVGID_21_);}
	//   #regular .st24{fill:url(#SVGID_22_);}
	//   #regular .st25{fill:url(#SVGID_23_);}
	//   #regular .st26{fill:url(#SVGID_24_);}
	//   #regular .st27{fill:url(#SVGID_25_);}
	//   #regular .st28{fill:url(#SVGID_26_);}
	//   #regular .st29{fill:url(#SVGID_27_);}
	//   #regular .st30{fill:url(#SVGID_28_);}
	//   #regular .st31{fill:url(#SVGID_29_);}
	//   #regular .st32{fill:url(#SVGID_30_);}
	//   #regular .st33{fill:url(#SVGID_31_);}
	//   #regular .st34{clip-path:url(#SVGID_33_);}
	//   #regular .st35{fill:url(#SVGID_34_);}
	//   #regular .st36{clip-path:url(#SVGID_36_);}
	//   #regular .st37{fill:url(#SVGID_37_);}
	//   #regular .st38{clip-path:url(#SVGID_39_);}
	//   #regular .st39{fill:url(#SVGID_40_);}
	//   #regular .st40{fill:url(#SVGID_41_);}
	//   #regular .st41{fill:url(#SVGID_42_);}
	//   #regular .st42{fill:url(#SVGID_43_);}
	//   #regular .st43{clip-path:url(#SVGID_45_);}
	//   #regular .st44{opacity:0.5;fill:url(#SVGID_46_);}
	//   #regular .st45{opacity:0.5;fill:url(#SVGID_47_);}
	//   #regular .st46{opacity:0.5;fill:url(#SVGID_48_);}
	//   #regular .st47{opacity:0.5;fill:url(#SVGID_49_);}
	//   #regular .st48{opacity:0.5;fill:url(#SVGID_50_);}
	//   #regular .st49{opacity:0.5;fill:url(#SVGID_51_);}
	//   #regular .st00{
	//     fill: none;
	//     stroke: #F5D96C;
	//     stroke-width: 2;
	//     stroke-miterlimit: 10;
	//   }
	//   .font{
	//     font-size: 36px;
	//     font-family: 'MicrosoftYaHei';
	//     fill:#F5D96C;
	//   }
	// </style>
	// <script>
	var THREE = __webpack_require__(26);

	module.exports = {
	  props: ['value', 'BRangle', 'BLangle', 'current', 'colorpad', 'material', 'spec', 'cancel'],
	  data: function data() {
	    return {
	      color: "",
	      angles: [0, 340, 320, 300, 280, 260, 240, 220, 200, 180, 160, 140, 100, 80, 60, 40],
	      index: 6,
	      colorSet: 'diffuse',
	      change: { name: '调色板' },
	      save: {}
	    };
	  },
	  computed: {
	    'color': function color() {
	      var h = this.value.h;
	      var s = this.value.s;
	      var l = this.value.l;
	      var color = new THREE.Color("hsl(" + h + "," + s + "," + l + ")");
	      return '#' + color.getHexString();
	    }
	  },
	  methods: {
	    toHex: function toHex(value) {
	      var h = value.h;
	      var s = value.s;
	      var l = value.l;
	      var color = new THREE.Color("hsl(" + h + "," + s + "," + l + ")");
	      return '#' + color.getHexString();
	    }
	  },
	  watch: {
	    value: function value(_value) {
	      var h = _value.h;
	      var s = _value.s;
	      var l = _value.l;
	      this.deg = h * 360;
	      this.BRangle = 10 - Number(s.substring(0, s.length - 1)) * 8 / 10;
	      this.BLangle = 30 - Number(l.substring(0, l.length - 1)) * 8 / 10;
	    },
	    index: function index(value) {
	      if (value == 12 || value == 13 || value == 14 || value == 15) {
	        this.cancel = true;
	      } else {
	        this.cancel = false;
	      }
	    },
	    BRangle: function BRangle(value) {
	      if (!this.cancel) {
	        this.value = { h: this.value.h, s: (10 - value) * 10 / 8 + '%', l: this.value.l };
	        this.change = { name: '饱和度', value: (10 - value) * 10 / 8 };
	      }
	    },
	    BLangle: function BLangle(value) {
	      this.value = { h: this.value.h, s: this.value.s, l: (30 - value) * 10 / 8 + '%' };
	      this.change = { name: '明度', value: (30 - value) * 10 / 8 };
	    }
	  }
	};
	// </script>

/***/ },
/* 121 */
/***/ function(module, exports) {

	module.exports = "<g id=\"Scale_B\">\n  <path class=\"st2\" d=\"M457.8,768.8c-0.6-0.2-1.3-0.5-1.9-0.7c-2.5,6.9-5,13.8-7.5,20.7c121.4,44.7,257.3-4.8,321.6-117\n    c-6.4-3.7-12.7-7.3-19.1-11c-0.3,0.6-0.7,1.2-1,1.7c5.8,3.3,11.5,6.7,17.3,10c-15.4,26.5-34,48.7-57.4,68.5\n    c-4.3-5.1-8.6-10.2-12.9-15.3c-0.5,0.4-1,0.9-1.5,1.3c4.3,5.1,8.6,10.2,12.9,15.3c-23.6,19.6-48.6,34.1-77.4,44.7\n    c-2.3-6.3-4.6-12.5-6.8-18.8c-0.6,0.2-1.3,0.5-1.9,0.7c2.3,6.3,4.6,12.5,6.8,18.8c-28.8,10.4-57.4,15.4-88,15.5c0-6.7,0-13.3,0-20\n    c-0.7,0-1.3,0-2,0c0,6.7,0,13.3,0,20c-30.6-0.1-59.2-5.1-88-15.5C453.3,781.3,455.5,775.1,457.8,768.8z\"/>\n  <path class=\"st2\" d=\"M384.6,726.9c-4.3,5.1-8.6,10.2-12.9,15.3c-0.4,0.5-0.9,1-1.3,1.5C213.3,612.9,257.2,361,449.4,291.1\n    c192.1-69.9,387.7,94.8,351.4,296c-7.2-1.3-14.4-2.5-21.7-3.8c0.1-0.7,0.2-1.3,0.3-2c6.6,1.2,13.1,2.3,19.7,3.5\n    c5.2-30.2,5.2-59.2,0-89.4c-6.6,1.2-13.1,2.3-19.7,3.5c-0.1-0.7-0.2-1.3-0.3-2c6.6-1.2,13.1-2.3,19.7-3.5\n    c-5.4-30.2-15.3-57.4-30.6-84c-5.8,3.3-11.5,6.7-17.3,10c-0.3-0.6-0.7-1.2-1-1.7c5.8-3.3,11.5-6.7,17.3-10\n    c-15.4-26.5-34-48.7-57.4-68.5c-4.3,5.1-8.6,10.2-12.9,15.3c-0.5-0.4-1-0.9-1.5-1.3c4.3-5.1,8.6-10.2,12.9-15.3\n    c-23.6-19.6-48.6-34.1-77.4-44.7c-2.3,6.3-4.6,12.5-6.8,18.8c-0.6-0.2-1.3-0.5-1.9-0.7c2.3-6.3,4.6-12.5,6.8-18.8\n    c-28.8-10.4-57.4-15.4-88-15.5c0,6.7,0,13.3,0,20c-0.7,0-1.3,0-2,0c0-6.7,0-13.3,0-20c-30.6,0.1-59.2,5.1-88,15.5\n    c2.3,6.3,4.6,12.5,6.8,18.8c-0.6,0.2-1.3,0.5-1.9,0.7c-2.3-6.3-4.6-12.5-6.8-18.8c-28.8,10.6-53.8,25.1-77.4,44.7\n    c4.3,5.1,8.6,10.2,12.9,15.3c-0.5,0.4-1,0.9-1.5,1.3c-4.3-5.1-8.6-10.2-12.9-15.3c-23.4,19.8-42,42-57.4,68.5\n    c5.8,3.3,11.5,6.7,17.3,10c-0.3,0.6-0.7,1.2-1,1.7c-5.8-3.3-11.5-6.7-17.3-10c-15.2,26.6-25.1,53.8-30.6,84\n    c6.6,1.2,13.1,2.3,19.7,3.5c-0.1,0.7-0.2,1.3-0.3,2c-6.6-1.2-13.1-2.3-19.7-3.5c-5.2,30.2-5.2,59.2,0,89.4\n    c6.6-1.2,13.1-2.3,19.7-3.5c0.1,0.7,0.2,1.3,0.3,2c-6.6,1.2-13.1,2.3-19.7,3.5c5.4,30.2,15.3,57.4,30.6,84\n    c5.8-3.3,11.5-6.7,17.3-10c0.3,0.6,0.7,1.2,1,1.7c-5.8,3.3-11.5,6.7-17.3,10c15.4,26.5,34,48.7,57.4,68.5\n    c4.3-5.1,8.6-10.2,12.9-15.3C383.5,726,384,726.5,384.6,726.9z\"/>\n  <path class=\"st2\" d=\"M692.2,484.7c-30.6-84.1-123.6-127.4-207.6-96.8c-84.1,30.6-127.4,123.6-96.8,207.6\n    c30.6,84.1,123.6,127.4,207.6,96.8C679.5,661.7,722.8,568.8,692.2,484.7z M594.7,690.5c-83,30.2-174.9-12.6-205.1-95.6\n    c-30.2-83,12.6-174.9,95.6-205.1c83-30.2,174.9,12.6,205.1,95.6C720.6,568.4,677.7,660.2,594.7,690.5z\"/>\n</g>\n<g id=\"Scale_BL2\">\n  <path class=\"st3_1\" :fill=\"color\" d=\"M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4\n    C82,745.5,39.5,504.3,149.5,314.7z\"/>\n</g>\n<g id=\"Scale_BL3\">\n  <linearGradient id=\"SVGID_1_1\" gradientUnits=\"userSpaceOnUse\" x1=\"214.4087\" y1=\"932.3943\" x2=\"44.3172\" y2=\"297.604\">\n    <stop  offset=\"0\" style=\"stop-color:#FFFFFF\"/>\n    <stop  offset=\"0.5\" style=\"stop-color:#7A7A7A;stop-opacity:0\"/>\n    <stop  offset=\"1\" style=\"stop-color:#000000\"/>\n  </linearGradient>\n  <path class=\"st4_1\" d=\"M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4\n    C82,745.5,39.5,504.3,149.5,314.7z\"/>\n</g>\n<g id=\"Scale_BL\">\n  <path class=\"st2\"  d=\"M251.5,885.5C83.3,745,40.8,503.8,150.8,314.2c-12.1-7-24.2-14-36.4-21c-0.3,0.6-0.7,1.2-1,1.7\n    c11.5,6.7,23.1,13.3,34.6,20c-10.2,17.7-19.1,35.9-26.8,54.9c-6.2-2.5-12.4-5-18.5-7.5c-0.3,0.6-0.5,1.2-0.7,1.9\n    c6.2,2.5,12.4,5,18.5,7.5c-7.6,19-13.9,38.2-18.9,58.1c-6.5-1.6-12.9-3.2-19.4-4.8c-0.2,0.6-0.3,1.3-0.5,1.9\n    c6.5,1.6,12.9,3.2,19.4,4.8c-4.9,19.9-8.4,39.8-10.6,60.1c-6.6-0.7-13.3-1.4-19.9-2.1c-0.1,0.7-0.1,1.3-0.2,2\n    c6.6,0.7,13.3,1.4,19.9,2.1c-2.1,20.3-2.8,40.6-2.1,61c-6.7,0.2-13.3,0.5-20,0.7c0,0.7,0,1.3,0.1,2c6.7-0.2,13.3-0.5,20-0.7\n    c0.8,20.4,2.9,40.6,6.4,60.7c-13.1,2.3-26.3,4.6-39.4,6.9c0.1,0.7,0.2,1.3,0.3,2c13.1-2.3,26.3-4.6,39.4-6.9\n    c3.6,20.1,8.5,39.8,14.8,59.3c-6.3,2.1-12.7,4.1-19,6.2c0.2,0.6,0.4,1.3,0.6,1.9c6.3-2.1,12.7-4.1,19-6.2\n    c6.4,19.4,14,38.2,22.9,56.6c-6,2.9-12,5.8-18,8.8c0.3,0.6,0.6,1.2,0.9,1.8c6-2.9,12-5.8,18-8.8c9,18.4,19.1,35.9,30.5,52.9\n    c-5.5,3.7-11.1,7.5-16.6,11.2c0.4,0.6,0.7,1.1,1.1,1.7c5.5-3.7,11.1-7.5,16.6-11.2c11.5,16.9,23.9,32.9,37.6,48.1\n    c-5,4.5-9.9,8.9-14.9,13.4c0.4,0.5,0.9,1,1.3,1.5c5-4.5,9.9-8.9,14.9-13.4c13.7,15.2,28.3,29.2,43.9,42.4\n    c-8.6,10.2-17.1,20.4-25.7,30.6c0.5,0.4,1,0.9,1.5,1.3C233.5,906.9,242.5,896.2,251.5,885.5z\"/>\n</g>\n<g id=\"Scale_BR2\" v-show=\"!cancel\">\n  <path class=\"st3_1\" :fill=\"color\" d=\"M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1\n    C900.2,190.4,1022.6,402.5,984.1,618.3z\"/>\n</g>\n<g id=\"Scale_BR3\" v-show=\"!cancel\">\n  <linearGradient id=\"SVGID_2_1\" gradientUnits=\"userSpaceOnUse\" x1=\"968.8124\" y1=\"649.5213\" x2=\"803.8889\" y2=\"34.0186\">\n    <stop  offset=\"0\" style=\"stop-color:#808080;stop-opacity:1\"/>\n    <stop  offset=\"1\" style=\"stop-color:#808080;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st5_1\" d=\"M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1\n    C900.2,190.4,1022.6,402.5,984.1,618.3z\"/>\n</g>\n<g id=\"Scale_BR\" v-show=\"!cancel\">\n  <path class=\"st2\" d=\"M983,619.2c38.5-215.7-83.9-427.8-290-502.3c4.8-13.2,9.6-26.3,14.4-39.5c0.6,0.2,1.3,0.5,1.9,0.7\n    c-4.6,12.5-9.1,25.1-13.7,37.6c19.2,7,37.7,15.3,55.8,24.8c3.1-5.9,6.3-11.8,9.4-17.7c0.6,0.3,1.2,0.6,1.8,0.9\n    c-3.1,5.9-6.3,11.8-9.4,17.7c18,9.6,35.2,20.4,51.8,32.4c3.9-5.4,7.8-10.8,11.8-16.2c0.5,0.4,1.1,0.8,1.6,1.2\n    c-3.9,5.4-7.8,10.8-11.8,16.2c16.5,12.1,32,25.1,46.8,39.3c4.6-4.8,9.3-9.6,13.9-14.4c0.5,0.5,1,0.9,1.4,1.4\n    c-4.6,4.8-9.3,9.6-13.9,14.4c14.7,14.2,28.2,29.3,40.9,45.4c5.3-4.1,10.5-8.2,15.8-12.3c0.4,0.5,0.8,1,1.2,1.6\n    c-5.3,4.1-10.5,8.2-15.8,12.3c12.6,16.1,23.9,32.9,34.1,50.6c11.5-6.7,23.1-13.3,34.6-20c0.3,0.6,0.7,1.2,1,1.7\n    c-11.5,6.7-23.1,13.3-34.6,20c10.2,17.7,19.1,35.9,26.8,54.9c6.2-2.5,12.4-5,18.5-7.5c0.3,0.6,0.5,1.2,0.7,1.9\n    c-6.2,2.5-12.4,5-18.5,7.5c7.6,19,13.9,38.2,18.9,58.1c6.5-1.6,12.9-3.2,19.4-4.8c0.2,0.6,0.3,1.3,0.5,1.9\n    c-6.5,1.6-12.9,3.2-19.4,4.8c4.9,19.9,8.4,39.8,10.6,60.1c6.6-0.7,13.3-1.4,19.9-2.1c0.1,0.7,0.1,1.3,0.2,2\n    c-6.6,0.7-13.3,1.4-19.9,2.1c2.1,20.3,2.8,40.6,2.1,61c6.7,0.2,13.3,0.5,20,0.7c0,0.7,0,1.3-0.1,2c-6.7-0.2-13.3-0.5-20-0.7\n    c-0.8,20.4-2.9,40.6-6.4,60.7c13.1,2.3,26.3,4.6,39.4,6.9c-0.1,0.7-0.2,1.3-0.3,2C1010.6,624.1,996.8,621.7,983,619.2z\"/>\n</g>\n<g id=\"Color_B01\" class=\"hover\" @click=\"value={h:0,s:'90%',l:'40%'},index=0\">\n  <linearGradient id=\"SVGID_1_\" gradientUnits=\"userSpaceOnUse\" x1=\"810.9808\" y1=\"540.1049\" x2=\"940.1153\" y2=\"540.1049\">\n    <stop  offset=\"9.271834e-008\" style=\"stop-color:#990000\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#990000\"/>\n    <stop  offset=\"1\" style=\"stop-color:#990000;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st3\" d=\"M811,586.9c41,7.2,82.1,14.5,123.1,21.7c8-46.3,8-90.7,0-136.9c-41,7.2-82.1,14.5-123.1,21.7\n    C816.4,525,816.4,555.3,811,586.9z\"/>\n</g>\n<g id=\"Color_B02\" @click=\"value={h:0.0996,s:'70%',l:'50%'},index=1\">\n  <linearGradient id=\"SVGID_2_\" gradientUnits=\"userSpaceOnUse\" x1=\"794.638\" y1=\"447.4195\" x2=\"915.9847\" y2=\"403.2529\">\n    <stop  offset=\"0\" style=\"stop-color:#CC7A00\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#CC7A00\"/>\n    <stop  offset=\"1\" style=\"stop-color:#CC7A00;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st4\" d=\"M810.6,491.4c41-7.2,82.1-14.5,123.1-21.7c-8.3-46.3-23.4-87.9-46.8-128.7c-36.1,20.8-72.2,41.7-108.3,62.5\n    C794.6,431.3,804.9,459.8,810.6,491.4z\"/>\n</g>\n<g id=\"Color_B03\" @click=\"value={h:0.16666666,s:'80%',l:'50%'},index=2\">\n  <linearGradient id=\"SVGID_3_\" gradientUnits=\"userSpaceOnUse\" x1=\"747.5805\" y1=\"365.9128\" x2=\"846.5033\" y2=\"282.9067\">\n    <stop  offset=\"0\" style=\"stop-color:#cccc00\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#cccc00\"/>\n    <stop  offset=\"1\" style=\"stop-color:#cccc00;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st5\" d=\"M777.6,401.7c36.1-20.8,72.2-41.7,108.3-62.5c-23.6-40.6-52.1-74.6-88-104.9c-26.8,31.9-53.6,63.8-80.3,95.8\n    C742,350.8,761.5,374,777.6,401.7z\"/>\n</g>\n<g id=\"Color_B04\" @click=\"value={h:0.23311,s:'50%',l:'60%'},index=3\">\n  <linearGradient id=\"SVGID_4_\" gradientUnits=\"userSpaceOnUse\" x1=\"675.4836\" y1=\"305.4167\" x2=\"740.0508\" y2=\"193.583\">\n    <stop  offset=\"0\" style=\"stop-color:#5c9900\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#5c9900\"/>\n    <stop  offset=\"1\" style=\"stop-color:#5c9900;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st6\" d=\"M716,328.8c26.8-31.9,53.6-63.8,80.3-95.8c-36.1-30.1-74.5-52.3-118.6-68.5c-14.3,39.2-28.5,78.3-42.8,117.5\n    C665.1,293.1,691.3,308.3,716,328.8z\"/>\n</g>\n<g id=\"Color_B05\" @click=\"value={h:0.33333333333333,s:'100%',l:'30%'},index=4\">\n  <linearGradient id=\"SVGID_5_\" gradientUnits=\"userSpaceOnUse\" x1=\"587.0449\" y1=\"273.228\" x2=\"609.4689\" y2=\"146.0551\">\n    <stop  offset=\"0\" style=\"stop-color:#009900\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#009900\"/>\n    <stop  offset=\"1\" style=\"stop-color:#009900;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st7\" d=\"M633.1,281.3c14.3-39.2,28.5-78.3,42.8-117.5c-44.2-16-87.9-23.7-134.9-23.8c0,41.7,0,83.3,0,125\n    C573.1,265.2,602.9,270.5,633.1,281.3z\"/>\n</g>\n<g id=\"Color_B06\" @click=\"value={h : 0.430555556,s:'70%',l:'50%'},index=5\">\n  <linearGradient id=\"SVGID_6_\" gradientUnits=\"userSpaceOnUse\" x1=\"492.9301\" y1=\"273.228\" x2=\"470.5061\" y2=\"146.0549\">\n    <stop  offset=\"0\" style=\"stop-color:#00cc7a\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#00cc7a\"/>\n    <stop  offset=\"1\" style=\"stop-color:#00cc7a;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st8\" d=\"M539,265.1c0-41.7,0-83.3,0-125c-47,0.1-90.7,7.8-134.9,23.8c14.3,39.2,28.5,78.3,42.8,117.5\n    C477.1,270.5,506.9,265.2,539,265.1z\"/>\n</g>\n<g id=\"Color_B07\" @click=\"value={h :0.5,s:'50%',l:'50%'},index=6\">\n  <linearGradient id=\"SVGID_7_\" gradientUnits=\"userSpaceOnUse\" x1=\"404.4905\" y1=\"305.4172\" x2=\"339.9231\" y2=\"193.5832\">\n    <stop  offset=\"9.271834e-008\" style=\"stop-color:#00cccc\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#00cccc\"/>\n    <stop  offset=\"1\" style=\"stop-color:#00FFFF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st9\" d=\"M445,282c-14.3-39.2-28.5-78.3-42.8-117.5c-44.1,16.2-82.5,38.4-118.6,68.5c26.8,31.9,53.6,63.8,80.3,95.8\n    C388.6,308.3,414.9,293.1,445,282z\"/>\n</g>\n<g id=\"Color_B08\" @click=\"value={h : 0.5669,s:'50%',l:'60%'},index=7\">\n  <linearGradient id=\"SVGID_8_\" gradientUnits=\"userSpaceOnUse\" x1=\"332.3944\" y1=\"365.9128\" x2=\"233.4712\" y2=\"282.9063\">\n    <stop  offset=\"1.854367e-007\" style=\"stop-color:#007acc\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#007acc\"/>\n    <stop  offset=\"1\" style=\"stop-color:#007acc;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st10\" d=\"M362.5,330.1c-26.8-31.9-53.6-63.8-80.3-95.8c-35.9,30.3-64.4,64.3-88,104.9c36.1,20.8,72.2,41.7,108.3,62.5\n    C318.5,374,338,350.8,362.5,330.1z\"/>\n</g>\n<g id=\"Color_B09\" @click=\"value={h : 0.66666666666,s:'60%',l:'50%'},index=8\">\n  <linearGradient id=\"SVGID_9_\" gradientUnits=\"userSpaceOnUse\" x1=\"285.3359\" y1=\"447.4191\" x2=\"163.9899\" y2=\"403.2528\">\n    <stop  offset=\"2.781550e-007\" style=\"stop-color:#000099\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#000099\"/>\n    <stop  offset=\"1\" style=\"stop-color:#000099;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st11\" d=\"M301.3,403.5c-36.1-20.8-72.2-41.7-108.3-62.5c-23.4,40.8-38.6,82.4-46.8,128.7c41,7.2,82.1,14.5,123.1,21.7\n    C275,459.8,285.4,431.3,301.3,403.5z\"/>\n</g>\n<g id=\"Color_B10\" @click=\"value={h : 0.7663,s:'50%',l:'40%'},index=9\">\n  <linearGradient id=\"SVGID_10_\" gradientUnits=\"userSpaceOnUse\" x1=\"268.993\" y1=\"540.1049\" x2=\"139.8585\" y2=\"540.1049\">\n    <stop  offset=\"2.781550e-007\" style=\"stop-color:#7a00cc\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#7a00cc\"/>\n    <stop  offset=\"1\" style=\"stop-color:#7a00cc;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st12\" d=\"M269,493.3c-41-7.2-82.1-14.5-123.1-21.7c-8,46.3-8,90.7,0,136.9c41-7.2,82.1-14.5,123.1-21.7\n    C263.5,555.3,263.5,525,269,493.3z\"/>\n</g>\n<g id=\"Color_B11\" @click=\"value={h:0.83333333333,s:'60%',l:'50%'},index=10\">\n  <linearGradient id=\"SVGID_11_\" gradientUnits=\"userSpaceOnUse\" x1=\"285.3358\" y1=\"632.7901\" x2=\"163.9899\" y2=\"676.9564\">\n    <stop  offset=\"3.708734e-007\" style=\"stop-color:#FF00FF\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#FF00FF\"/>\n    <stop  offset=\"1\" style=\"stop-color:#FF00FF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st13\" d=\"M269.3,588.8c-41,7.2-82.1,14.5-123.1,21.7c8.3,46.3,23.4,87.9,46.8,128.7c36.1-20.8,72.2-41.7,108.3-62.5\n    C285.4,648.9,275,620.4,269.3,588.8z\"/>\n</g>\n<g id=\"Color_B12\" @click=\"value={h:0.9,s:'50%',l:'80%'},index=11\">\n  <linearGradient id=\"SVGID_12_\" gradientUnits=\"userSpaceOnUse\" x1=\"332.3944\" y1=\"714.2958\" x2=\"233.4712\" y2=\"797.3022\">\n    <stop  offset=\"3.708734e-007\" style=\"stop-color:#ff99d6\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#ff99d6\"/>\n    <stop  offset=\"1\" style=\"stop-color:#ff99d6;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st14\" d=\"M302.3,678.5c-36.1,20.8-72.2,41.7-108.3,62.5c23.6,40.6,52.1,74.6,88,104.9c26.8-31.9,53.6-63.8,80.3-95.8\n    C338,729.4,318.5,706.2,302.3,678.5z\"/>\n</g>\n<g id=\"Color_B13\" @click=\"value={h:0.123,s:'62%',l:'70%'},index=12\">\n  <linearGradient id=\"SVGID_13_\" gradientUnits=\"userSpaceOnUse\" x1=\"492.9301\" y1=\"806.9812\" x2=\"470.5062\" y2=\"934.1538\">\n    <stop  offset=\"2.737399e-007\" style=\"stop-color:#d8b656\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#d8b656\"/>\n    <stop  offset=\"1\" style=\"stop-color:#d8b656;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st15\" d=\"M446.9,798.9c-14.3,39.2-28.5,78.3-42.8,117.5c44.2,16,87.9,23.7,134.9,23.8c0-41.7,0-83.3,0-125\n    C506.9,815,477.1,809.7,446.9,798.9z\"/>\n</g>\n<g id=\"Color_B14\" @click=\"value={h:0,s:'0%',l:'70%'},index=13\">\n  <linearGradient id=\"SVGID_14_\" gradientUnits=\"userSpaceOnUse\" x1=\"587.0449\" y1=\"806.9812\" x2=\"609.4688\" y2=\"934.1536\">\n    <stop  offset=\"3.664582e-007\" style=\"stop-color:#999999\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#999999\"/>\n    <stop  offset=\"1\" style=\"stop-color:#999999;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st16\" d=\"M541,815.1c0,41.7,0,83.3,0,125c47-0.1,90.7-7.8,134.9-23.8c-14.3-39.2-28.5-78.3-42.8-117.5\n    C602.9,809.7,573.1,815,541,815.1z\"/>\n</g>\n<g id=\"Color_B15\"  @click=\"value={h:0,s:'0%',l:'10%'},index=14\">\n  <linearGradient id=\"SVGID_15_\" gradientUnits=\"userSpaceOnUse\" x1=\"675.4838\" y1=\"774.7922\" x2=\"740.0508\" y2=\"886.6255\">\n    <stop  offset=\"4.591765e-007\" style=\"stop-color:#4d4d4d\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#4d4d4d\"/>\n    <stop  offset=\"1\" style=\"stop-color:#4d4d4d;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st17\" d=\"M635,798.2c14.3,39.2,28.5,78.3,42.8,117.5c44.1-16.2,82.5-38.4,118.6-68.5c-26.8-31.9-53.6-63.8-80.3-95.8\n    C691.3,771.9,665.1,787.1,635,798.2z\"/>\n</g>\n<g id=\"Color_B16\" @click=\"value={h:0,s:'0%',l:'100%'},index=15\">\n  <linearGradient id=\"SVGID_16_\" gradientUnits=\"userSpaceOnUse\" x1=\"747.5805\" y1=\"714.2958\" x2=\"846.5033\" y2=\"797.3018\">\n    <stop  offset=\"3.664582e-007\" style=\"stop-color:#e5e5e5\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#e5e5e5\"/>\n    <stop  offset=\"1\" style=\"stop-color:#e5e5e5;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st18\" d=\"M717.5,750.1c26.8,31.9,53.6,63.8,80.3,95.8c35.9-30.3,64.4-64.3,88-104.9c-36.1-20.8-72.2-41.7-108.3-62.5\n    C761.5,706.2,742,729.4,717.5,750.1z\"/>\n</g>\n<g id=\"Pin_BL\" :transform=\"'rotate(' + BLangle + ' 540 540)'\">\n  <g>\n    <linearGradient id=\"SVGID_171_\" gradientUnits=\"userSpaceOnUse\" x1=\"57.5965\" y1=\"530.0045\" x2=\"20.0443\" y2=\"530.0045\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_171_);\" d=\"M20,532.4c0-1.8,0.1-3.6,0.1-5.4c9.6,0.6,19.3,1.2,28.9,1.9c2.8,1.4,5.7,2.8,8.5,4.1    C45.1,532.8,32.6,532.6,20,532.4z\"/>\n    <linearGradient id=\"SVGID_181_\" gradientUnits=\"userSpaceOnUse\" x1=\"77.9868\" y1=\"540.1041\" x2=\"19.9875\" y2=\"540.1041\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_181_);\" d=\"M20,543.8c0-2.5,0-4.9,0-7.4c19.3,0.3,38.7,0.6,58,0.9c0,1.9,0,3.7,0,5.6C58.7,543.2,39.3,543.5,20,543.8z\"/>\n    <linearGradient id=\"SVGID_191_\" gradientUnits=\"userSpaceOnUse\" x1=\"57.5965\" y1=\"550.2053\" x2=\"20.0443\" y2=\"550.2053\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_191_);\" d=\"M20.2,553.2c0-1.8-0.1-3.6-0.1-5.4c12.5-0.2,25-0.4,37.6-0.6c-2.8,1.4-5.7,2.8-8.5,4.1    C39.4,552,29.8,552.6,20.2,553.2z\"/>\n  </g>\n</g>\n<g id=\"Pin_BR\"  v-show = \"!cancel\" :transform=\"'rotate(' + BRangle + ' 540 540)'\">\n  <g xmlns=\"http://www.w3.org/2000/svg\">\n    <linearGradient id=\"SVGID_101_\" gradientUnits=\"userSpaceOnUse\" x1=\"1022.4805\" y1=\"550.2055\" x2=\"1060.0327\" y2=\"550.2055\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_101_)\" d=\"M1059.9,553.2c0-1.8,0.1-3.6,0.1-5.4c-12.5-0.2-25-0.4-37.6-0.6c2.8,1.4,5.7,2.8,8.5,4.1    C1040.6,552,1050.3,552.6,1059.9,553.2z\"/>\n    <linearGradient id=\"SVGID_111_\" gradientUnits=\"userSpaceOnUse\" x1=\"1002.0901\" y1=\"540.1044\" x2=\"1060.0895\" y2=\"540.1044\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_111_)\" d=\"M1060.1,543.8c0-2.5,0-4.9,0-7.4c-19.3,0.3-38.7,0.6-58,0.9c0,1.9,0,3.7,0,5.6    C1021.4,543.2,1040.7,543.5,1060.1,543.8z\"/>\n    <linearGradient id=\"SVGID_121_\" gradientUnits=\"userSpaceOnUse\" x1=\"1022.4805\" y1=\"530.0047\" x2=\"1060.0327\" y2=\"530.0047\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_121_)\" d=\"M1060,532.4c0-1.8-0.1-3.6-0.1-5.4c-9.6,0.6-19.3,1.2-28.9,1.9c-2.8,1.4-5.7,2.8-8.5,4.1    C1035,532.8,1047.5,532.6,1060,532.4z\"/>\n  </g>\n</g>\n<g id=\"Pin_B\" :transform=\"'rotate(' + angles[index] + ' 540 540)'\">\n  <g>\n    <linearGradient id=\"SVGID_231_\" gradientUnits=\"userSpaceOnUse\" x1=\"875.485\" y1=\"539.9995\" x2=\"516.9875\" y2=\"539.9995\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_231_)\" d=\"M561.2,531.1c-9.7-23.2-44.2-16.3-44.2,8.9s34.5,32.1,44.2,8.9c0.2-0.4,0.3-0.8,0.5-1.2    c104.6-1.6,209.2-3.3,313.8-4.9c0-1.9,0-3.7,0-5.6c-104.6-1.6-209.2-3.3-313.8-4.9C561.5,531.9,561.4,531.5,561.2,531.1z\"/>\n    <linearGradient id=\"SVGID_241_\" gradientUnits=\"userSpaceOnUse\" x1=\"855.0947\" y1=\"540\" x2=\"508.9872\" y2=\"540\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_241_)\" d=\"M846.6,528.8c2.8,1.4,5.7,2.8,8.5,4.1c-96.9-1.5-193.8-3-290.7-4.5C552,502.4,513,511.2,513,540    c0,28.8,39,37.6,51.4,11.6c96.9-1.5,193.8-3,290.7-4.5c-2.8,1.4-5.7,2.8-8.5,4.1c-101.5,6.6-203,13.1-304.6,19.7    c-44,2.8-44-64.7,0-61.9C643.5,515.6,745,522.2,846.6,528.8z\"/>\n  </g>\n</g>\n<g id=\"Monitor_B\">\n  <radialGradient id=\"SVGID_21_\" cx=\"539.9872\" cy=\"540.1043\" r=\"150.0408\" gradientUnits=\"userSpaceOnUse\">\n    <stop  offset=\"0\" style=\"stop-color:#000000\"/>\n    <stop  offset=\"1\" style=\"stop-color:#000000;stop-opacity:0.5\"/>\n  </radialGradient>\n  <circle class=\"st23\" cx=\"540\" cy=\"540.1\" r=\"150\"/>\n  <linearGradient id=\"SVGID_22_\" gradientUnits=\"userSpaceOnUse\" x1=\"539.987\" y1=\"392.0641\" x2=\"539.987\" y2=\"688.1447\">\n    <stop  class=\"pad\" offset=\"9.271834e-008\" :style=\"'stop-color:' + color \"/>\n    <stop  offset=\"1\" :style=\"'stop-color:' + color\"/>\n  </linearGradient>\n  <circle class=\"st24\" cx=\"540\" cy=\"540.1\" r=\"148\" @click=\"colorSet='diffuse'\"/>\n  <linearGradient id=\"SVGID_23_\" gradientUnits=\"userSpaceOnUse\" x1=\"539.9875\" y1=\"683.535\" x2=\"539.9875\" y2=\"555.6201\">\n    <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n    <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st25\" d=\"M540,555.6c36.6,0,94.1,17.1,94.1,64c0,46.8-57.5,64-94.1,64c-36.6,0-94.1-17.1-94.1-64\n    C445.9,572.7,503.4,555.6,540,555.6z\" @click=\"colorSet='shadow'\"/>\n  <linearGradient id=\"SVGID_24_\" gradientUnits=\"userSpaceOnUse\" x1=\"539.9875\" y1=\"396.6736\" x2=\"539.9875\" y2=\"524.5886\">\n    <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n    <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st26\" d=\"M540,524.6c36.6,0,94.1-17.1,94.1-64c0-46.8-57.5-64-94.1-64c-36.6,0-94.1,17.1-94.1,64\n    C445.9,507.5,503.4,524.6,540,524.6z\" @click=\"colorSet='highlight'\"/>\n  <linearGradient id=\"SVGID_25_\" gradientUnits=\"userSpaceOnUse\" x1=\"539.9869\" y1=\"400.9027\" x2=\"539.9869\" y2=\"450.9808\">\n    <stop  offset=\"0\" style=\"stop-color:#FFFFFF;stop-opacity:0.6\"/>\n    <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st27\" d=\"M540,451c10.1,0,19.6-1.3,29.2-5c7.9-3,19.6-9.3,19.6-20.1c0-10.7-11.7-17-19.6-20.1c-9.6-3.7-19-5-29.1-5\n    c-10.1,0-19.6,1.3-29.2,5c-7.9,3-19.6,9.3-19.6,20.1c0,10.7,11.7,17,19.6,20.1C520.4,449.7,529.9,451,540,451z\"/>\n    <text xmlns=\"http://www.w3.org/2000/svg\" transform=\"matrix(1 0 0 1 484.3381 482)\">\n      <tspan x=\"0\" y=\"0\" style=\"font-size:36px;font-family:'HYg1gj'\" v-text=\"change.name\"></tspan>\n      <tspan x=\"-40\" y=\"130\" style=\"font-size:120px;font-family:'HYg1gj'\" v-text=\"change.value\"></tspan>\n      <tspan x=\"-20\" y=\"120\" style=\"font-size:36px;font-family:'HYg1gj'\" v-text=\"change.hover\"></tspan>\n    </text>\n</g>\n<g id=\"Color_P\">\n</g>\n<g id=\"Metrial_Matt\"  @click=\"material='matte'\" @mouseover=\"save=change,change={hover:'哑光'}\" @mouseout=\"change=save\">\n  <g>\n    <path class=\"st2\" d=\"M451.8,982.1c-1.4-16.5-16-28.7-32.5-27.3c-16.5,1.4-28.7,16-27.3,32.5c1.4,16.5,16,28.7,32.5,27.3\n      C441,1013.1,453.2,998.6,451.8,982.1z M424.3,1012.6c-15.4,1.3-29-10-30.3-25.5c-1.3-15.4,10-29,25.5-30.3\n      c15.4-1.3,29,10,30.3,25.5C451.1,997.7,439.7,1011.2,424.3,1012.6z\"/>\n    <linearGradient id=\"SVGID_26_\" gradientUnits=\"userSpaceOnUse\" x1=\"421.8964\" y1=\"956.6859\" x2=\"421.8964\" y2=\"1012.6892\">\n      <stop  offset=\"9.271834e-008\" style=\"stop-color:#808080;stop-opacity:0.9\"/>\n      <stop  offset=\"1\" style=\"stop-color:#1A1A1A;stop-opacity:0.9\"/>\n    </linearGradient>\n    <circle class=\"st28\" cx=\"421.9\" cy=\"984.7\" r=\"28\"/>\n  </g>\n</g>\n<g id=\"Metrial_Paint\" @click=\"material = 'normal'\" @mouseover=\"save=change,change={hover:'普通漆'}\" @mouseout=\"change=save\">\n  <g>\n    <path class=\"st2\" d=\"M529.9,990.7c-4.3-16-20.7-25.5-36.7-21.2c-16,4.3-25.5,20.7-21.2,36.7c4.3,16,20.7,25.5,36.7,21.2\n      C524.7,1023.1,534.2,1006.7,529.9,990.7z M508.1,1025.5c-14.9,4-30.3-4.9-34.3-19.8c-4-14.9,4.9-30.3,19.8-34.3\n      c14.9-4,30.3,4.9,34.3,19.8C531.9,1006.1,523.1,1021.5,508.1,1025.5z\"/>\n    <linearGradient id=\"SVGID_27_\" gradientUnits=\"userSpaceOnUse\" x1=\"500.8916\" y1=\"970.433\" x2=\"500.8916\" y2=\"1026.4468\">\n      <stop  offset=\"9.271834e-008\" style=\"stop-color:#808080;stop-opacity:0.9\"/>\n      <stop  offset=\"1\" style=\"stop-color:#1A1A1A;stop-opacity:0.9\"/>\n    </linearGradient>\n    <circle class=\"st29\" cx=\"500.9\" cy=\"998.4\" r=\"28\"/>\n    <linearGradient id=\"SVGID_28_\" gradientUnits=\"userSpaceOnUse\" x1=\"500.892\" y1=\"971.3044\" x2=\"500.892\" y2=\"990.4042\">\n      <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st30\" d=\"M500.9,990.4c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5s-16.6,1.7-16.6,9.5\n      C484.3,988.7,495.3,990.4,500.9,990.4z\"/>\n  </g>\n</g>\n<g id=\"Material_Electroplate\"  @click=\"material = 'electroplate'\" @mouseover=\"save=change,change={hover:'电镀漆'}\" @mouseout=\"change=save\">\n  <g>\n    <linearGradient id=\"SVGID_29_\" gradientUnits=\"userSpaceOnUse\" x1=\"581.0947\" y1=\"970.2589\" x2=\"581.0947\" y2=\"1026.2723\">\n      <stop  offset=\"9.271834e-008\" style=\"stop-color:#808080;stop-opacity:0.9\"/>\n      <stop  offset=\"1\" style=\"stop-color:#1A1A1A;stop-opacity:0.9\"/>\n    </linearGradient>\n    <circle class=\"st31\" cx=\"581.1\" cy=\"998.3\" r=\"28\"/>\n    <linearGradient id=\"SVGID_30_\" gradientUnits=\"userSpaceOnUse\" x1=\"581.0749\" y1=\"971.1303\" x2=\"581.0749\" y2=\"995.3297\">\n      <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st32\" d=\"M581.1,995.3c6.9,0,17.8-3.2,17.8-12.1s-10.9-12.1-17.8-12.1c-6.9,0-17.8,3.2-17.8,12.1\n      S574.2,995.3,581.1,995.3z\"/>\n    <linearGradient id=\"SVGID_31_\" gradientUnits=\"userSpaceOnUse\" x1=\"581.0755\" y1=\"971.9307\" x2=\"581.0755\" y2=\"981.5522\">\n      <stop  offset=\"0\" style=\"stop-color:#FFFFFF;stop-opacity:0.6\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st33\" d=\"M581.1,981.4c4.2,0,9.2,1.5,9.2-4.7c0-3.9-5-4.7-9.2-4.7c-4.2,0-9.2,1-9.2,4.7\n      C571.9,982.9,576.9,981.4,581.1,981.4z\"/>\n    <path class=\"st2\" d=\"M608.3,985.6c-7-15-24.9-21.5-39.9-14.5c-15,7-21.5,24.9-14.5,39.9c7,15,24.9,21.5,39.9,14.5\n      C608.8,1018.5,615.3,1000.6,608.3,985.6z M592.9,1023.6c-14,6.5-30.7,0.5-37.2-13.5c-6.5-14-0.5-30.7,13.5-37.2\n      c14-6.5,30.7-0.5,37.2,13.5C613,1000.4,606.9,1017.1,592.9,1023.6z\"/>\n  </g>\n</g>\n<!--g id=\"Material_Frosting\"  @click=\"material = 'matting'\" @mouseover=\"save=change,change={hover:'磨砂'}\" @mouseout=\"change=save\">\n  <g>\n    <path class=\"st2\" d=\"M684.6,967c-9.5-13.6-28.2-16.9-41.8-7.4c-13.6,9.5-16.9,28.2-7.4,41.8c9.5,13.6,28.2,16.9,41.8,7.4\n      C690.8,999.2,694.1,980.5,684.6,967z M676.1,1007.1c-12.7,8.9-30.1,5.8-39-6.9c-8.9-12.7-5.8-30.1,6.9-39\n      c12.7-8.9,30.1-5.8,39,6.9C691.8,980.8,688.7,998.2,676.1,1007.1z\"/>\n    <g>\n      <defs>\n        <circle id=\"SVGID_32_\" cx=\"660\" cy=\"984.2\" r=\"28\"/>\n      </defs>\n      <clipPath id=\"SVGID_33_\">\n        <use xlink:href=\"#SVGID_32_\"  style=\"overflow:visible;\"/>\n      </clipPath>\n      <g class=\"st34\">\n\n          <image style=\"overflow:visible;\" width=\"200\" height=\"200\" xlink:href=\"materials/matting.png\" transform=\"matrix(0.4233 0 0 0.4233 617.6789 942.357)\">\n        </image>\n      </g>\n    </g>\n    <linearGradient id=\"SVGID_34_\" gradientUnits=\"userSpaceOnUse\" x1=\"660.0095\" y1=\"957.0345\" x2=\"660.0095\" y2=\"976.1343\">\n      <stop  offset=\"0\" style=\"stop-color:#FFFFFF;stop-opacity:0.2\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st35\" d=\"M660,976.1c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5\n      C643.4,974.4,654.4,976.1,660,976.1z\"/>\n  </g>\n</g-->\n<!--g id=\"Material_Brushed\"  @click=\"material = 'carbon'\" @mouseover=\"save=change,change={hover:'碳纤维'}\" @mouseout=\"change=save\">\n  <g>\n    <g>\n      <defs>\n        <circle id=\"SVGID_35_\" cx=\"735.3\" cy=\"956.6\" r=\"28\"/>\n      </defs>\n      <clipPath id=\"SVGID_36_\">\n        <use xlink:href=\"#SVGID_35_\"  style=\"overflow:visible;\"/>\n      </clipPath>\n      <g class=\"st36\">\n\n          <image style=\"overflow:visible;\" width=\"200\" height=\"200\" xlink:href=\"materials/carbon.png\" transform=\"matrix(0.6852 0 0 0.6852 666.7819 888.5193)\">\n        </image>\n      </g>\n    </g>\n    <path class=\"st2\" d=\"M756.5,935.4c-11.7-11.7-30.7-11.7-42.4,0c-11.7,11.7-11.7,30.7,0,42.4c11.7,11.7,30.7,11.7,42.4,0\n      C768.2,966.1,768.2,947.1,756.5,935.4z M755.1,976.4c-10.9,10.9-28.7,10.9-39.6,0c-10.9-10.9-10.9-28.7,0-39.6\n      c10.9-10.9,28.7-10.9,39.6,0C766,947.7,766,965.4,755.1,976.4z\"/>\n    <linearGradient id=\"SVGID_37_\" gradientUnits=\"userSpaceOnUse\" x1=\"735.2972\" y1=\"929.4463\" x2=\"735.2972\" y2=\"948.5473\">\n      <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st37\" d=\"M735.3,948.5c5.6,0,16.6-1.7,16.6-9.6c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5\n      C718.7,946.8,729.7,948.5,735.3,948.5z\"/>\n  </g>\n</g-->\n<!--g id=\"Material_Carbonfibre\"  @click=\"material = 'drawbench'\" @mouseover=\"save=change,change={hover:'拉丝'}\" @mouseout=\"change=save\">\n  <g>\n    <g>\n      <defs>\n        <circle id=\"SVGID_38_\" cx=\"804.6\" cy=\"916.3\" r=\"28\"/>\n      </defs>\n      <clipPath id=\"SVGID_39_\">\n        <use xlink:href=\"#SVGID_38_\"  style=\"overflow:visible;\"/>\n      </clipPath>\n      <g class=\"st38\">\n\n          <image style=\"overflow:visible;\" width=\"200\" height=\"200\" xlink:href=\"materials/drawbench.png\" transform=\"matrix(0.6029 0 0 0.6029 744.3639 853.8486)\">\n        </image>\n      </g>\n    </g>\n    <path class=\"st2\" d=\"M821.9,891.8c-13.6-9.5-32.3-6.2-41.8,7.4c-9.5,13.6-6.2,32.3,7.4,41.8c13.6,9.5,32.3,6.2,41.8-7.4\n      C838.7,920,835.4,901.3,821.9,891.8z M827.6,932.4c-8.9,12.7-26.3,15.7-39,6.9c-12.7-8.9-15.7-26.3-6.9-39\n      c8.9-12.7,26.3-15.7,39-6.9C833.4,902.3,836.5,919.7,827.6,932.4z\"/>\n    <linearGradient id=\"SVGID_40_\" gradientUnits=\"userSpaceOnUse\" x1=\"804.6505\" y1=\"889.2046\" x2=\"804.6505\" y2=\"908.3044\">\n      <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st39\" d=\"M804.7,908.3c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5\n      C788.1,906.6,799.1,908.3,804.7,908.3z\"/>\n  </g>\n</g-->\n<g id=\"Material_Chameleon\"  @click=\"material = 'discolor'\" @mouseover=\"save=change,change={hover:'变色'}\" @mouseout=\"change=save\">\n  <g>\n    <linearGradient id=\"SVGID_41_\" gradientUnits=\"userSpaceOnUse\" x1=\"865.9626\" y1=\"836.6588\" x2=\"865.9626\" y2=\"892.6722\">\n      <stop  offset=\"0\" style=\"stop-color:#FFFFFF;stop-opacity:0.8\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n    </linearGradient>\n    <circle class=\"st40\" cx=\"866\" cy=\"864.7\" r=\"28\"/>\n    <linearGradient id=\"SVGID_42_\" gradientUnits=\"userSpaceOnUse\" x1=\"865.9626\" y1=\"891.8015\" x2=\"865.9626\" y2=\"872.7005\">\n      <stop  offset=\"0\" style=\"stop-color:#0000FF;stop-opacity:0.5\"/>\n      <stop  offset=\"1\" style=\"stop-color:#0000FF;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st41\" d=\"M866,872.7c5.6,0,16.6,1.7,16.6,9.6c0,7.8-11,9.5-16.6,9.5c-5.6,0-16.6-1.7-16.6-9.5\n      C849.4,874.4,860.4,872.7,866,872.7z\"/>\n    <path class=\"st2\" d=\"M878.6,837.5c-15-7-32.9-0.5-39.9,14.5c-7,15-0.5,32.9,14.5,39.9c15,7,32.9,0.5,39.9-14.5\n      C900.2,862.3,893.7,844.5,878.6,837.5z M891.3,876.5c-6.5,14-23.2,20.1-37.2,13.5c-14-6.5-20.1-23.2-13.5-37.2\n      c6.5-14,23.2-20.1,37.2-13.5C891.8,845.8,897.9,862.5,891.3,876.5z\"/>\n    <linearGradient id=\"SVGID_43_\" gradientUnits=\"userSpaceOnUse\" x1=\"865.9626\" y1=\"837.5306\" x2=\"865.9626\" y2=\"856.6304\">\n      <stop  offset=\"0\" style=\"stop-color:#FF0000;stop-opacity:0.5\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FF0000;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st42\" d=\"M866,856.6c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5S860.4,856.6,866,856.6z\n      \"/>\n  </g>\n</g>\n<g id=\"To_Pro\" @click=\"current = 'pro'\" @mouseover=\"save=change,change={hover:'高级模式'}\" @mouseout=\"change=save\">\n  <g>\n    <path class=\"st2\" d=\"M925.1,774.2c-16-4.3-32.5,5.2-36.7,21.2c-4.3,16,5.2,32.5,21.2,36.7c16,4.3,32.5-5.2,36.7-21.2\n      C950.6,794.9,941.1,778.4,925.1,774.2z M944.4,810.4c-4,14.9-19.4,23.8-34.3,19.8c-14.9-4-23.8-19.4-19.8-34.3\n      c4-14.9,19.4-23.8,34.3-19.8C939.6,780.1,948.4,795.4,944.4,810.4z\"/>\n    <g>\n      <defs>\n        <circle id=\"SVGID_44_\" cx=\"917.4\" cy=\"803.1\" r=\"28\"/>\n      </defs>\n      <clipPath id=\"SVGID_45_\">\n        <use xlink:href=\"#SVGID_44_\"  style=\"overflow:visible;\"/>\n      </clipPath>\n      <g class=\"st43\">\n\n          <image style=\"overflow:visible;\" width=\"851\" height=\"850\" xlink:href=\"hue-ring.png\" transform=\"matrix(5.837880e-002 5.837880e-002 -5.837880e-002 5.837880e-002 917.3402 753.4789)\">\n        </image>\n      </g>\n    </g>\n  </g>\n</g>\n<g id=\"Temp_Color_01\"  @click=\"value = colorpad[0]\"  @mouseover=\"save=change,change={hover:'历史记录'}\" @mouseout=\"change=save\">\n  <g>\n    <path class=\"st2\" d=\"M226.7,188.4c-15-7-32.9-0.5-39.9,14.5c-7,15-0.5,32.9,14.5,39.9c15,7,32.9,0.5,39.9-14.5\n      C248.2,213.2,241.7,195.4,226.7,188.4z M239.4,227.4c-6.5,14-23.2,20.1-37.2,13.5c-14-6.5-20.1-23.2-13.5-37.2\n      c6.5-14,23.2-20.1,37.2-13.5C239.9,196.7,245.9,213.4,239.4,227.4z\"/>\n    <linearGradient id=\"SVGID_46_\" gradientUnits=\"userSpaceOnUse\" x1=\"214.0118\" y1=\"187.5365\" x2=\"214.0118\" y2=\"243.5498\">\n      <stop  offset=\"3.708734e-007\" :style=\"'stop-color:'+toHex(colorpad[0])\"/>\n      <stop  offset=\"1\" :style=\"'stop-color:'+toHex(colorpad[0])+';stop-opacity:0.5'\"/>\n    </linearGradient>\n    <circle class=\"st44\" cx=\"214\" cy=\"215.5\" r=\"28\"/>\n  </g>\n</g>\n<g id=\"Temp_Color_02\"  @click=\"value = colorpad[1]\"  @mouseover=\"save=change,change={hover:'历史记录'}\" @mouseout=\"change=save\">\n  <g>\n    <path class=\"st2\" d=\"M292.5,139.3c-13.6-9.5-32.3-6.2-41.8,7.4c-9.5,13.6-6.2,32.3,7.4,41.8c13.6,9.5,32.3,6.2,41.8-7.4\n      C309.4,167.5,306.1,148.8,292.5,139.3z M298.3,179.9c-8.9,12.7-26.3,15.7-39,6.9c-12.7-8.9-15.7-26.3-6.9-39\n      c8.9-12.7,26.3-15.7,39-6.9C304.1,149.8,307.1,167.3,298.3,179.9z\"/>\n    <linearGradient id=\"SVGID_47_\" gradientUnits=\"userSpaceOnUse\" x1=\"275.3235\" y1=\"135.8667\" x2=\"275.3235\" y2=\"191.8716\">\n      <stop  offset=\"0\" :style=\"'stop-color:'+toHex(colorpad[1])\"/>\n      <stop  offset=\"1\" :style=\"'stop-color:'+toHex(colorpad[1])+';stop-opacity:0.5'\"/>\n    </linearGradient>\n    <circle class=\"st45\" cx=\"275.3\" cy=\"163.9\" r=\"28\"/>\n  </g>\n</g>\n<g id=\"Temp_Color_03\"  @click=\"value= colorpad[2]\"  @mouseover=\"save=change,change={hover:'历史记录'}\" @mouseout=\"change=save\">\n  <g>\n    <path class=\"st2\" d=\"M365.9,102.4c-11.7-11.7-30.7-11.7-42.4,0c-11.7,11.7-11.7,30.7,0,42.4c11.7,11.7,30.7,11.7,42.4,0\n      C377.6,133.1,377.6,114.1,365.9,102.4z M364.5,143.4c-10.9,10.9-28.7,10.9-39.6,0c-10.9-10.9-10.9-28.7,0-39.6\n      c10.9-10.9,28.7-10.9,39.6,0C375.4,114.8,375.4,132.5,364.5,143.4z\"/>\n    <linearGradient id=\"SVGID_48_\" gradientUnits=\"userSpaceOnUse\" x1=\"344.6773\" y1=\"95.6269\" x2=\"344.6773\" y2=\"151.6267\">\n      <stop  offset=\"2.737399e-007\" :style=\"'stop-color:'+toHex(colorpad[2])\"/>\n      <stop  offset=\"1\" :style=\"'stop-color:'+toHex(colorpad[2])+';stop-opacity:0.5'\"/>\n    </linearGradient>\n    <circle class=\"st46\" cx=\"344.7\" cy=\"123.6\" r=\"28\"/>\n  </g>\n</g>\n<g id=\"Temp_Color_04\"  @click=\"value = colorpad[3]\"  @mouseover=\"save=change,change={hover:'历史记录'}\" @mouseout=\"change=save\">\n  <g>\n    <path class=\"st2\" d=\"M444.5,78.8c-9.5-13.6-28.2-16.9-41.8-7.4c-13.6,9.5-16.9,28.2-7.4,41.8c9.5,13.6,28.2,16.9,41.8,7.4\n      C450.7,111.1,454,92.4,444.5,78.8z M436,119c-12.7,8.9-30.1,5.8-39-6.9c-8.9-12.7-5.8-30.1,6.9-39c12.7-8.9,30.1-5.8,39,6.9\n      C451.8,92.6,448.7,110.1,436,119z\"/>\n    <linearGradient id=\"SVGID_49_\" gradientUnits=\"userSpaceOnUse\" x1=\"419.9649\" y1=\"68.0361\" x2=\"419.9649\" y2=\"124.041\">\n      <stop  offset=\"3.708734e-007\" :style=\"'stop-color:'+toHex(colorpad[3])\"/>\n      <stop  offset=\"1\" :style=\"'stop-color:'+toHex(colorpad[3])+';stop-opacity:0.5'\"/>\n    </linearGradient>\n    <circle class=\"st47\" cx=\"420\" cy=\"96\" r=\"28\"/>\n  </g>\n</g>\n<g id=\"Temp_Color_05\"  @click=\"value = colorpad[4]\"  @mouseover=\"save=change,change={hover:'历史记录'}\" @mouseout=\"change=save\">\n  <g>\n    <path class=\"st2\" d=\"M526.1,69.3c-7-15-24.9-21.5-39.9-14.5c-15,7-21.5,24.9-14.5,39.9c7,15,24.9,21.5,39.9,14.5\n      C526.6,102.1,533.1,84.3,526.1,69.3z M510.7,107.3c-14,6.5-30.7,0.5-37.2-13.5c-6.5-14-0.5-30.7,13.5-37.2\n      c14-6.5,30.7-0.5,37.2,13.5C530.8,84.1,524.7,100.8,510.7,107.3z\"/>\n    <linearGradient id=\"SVGID_50_\" gradientUnits=\"userSpaceOnUse\" x1=\"498.8995\" y1=\"53.9367\" x2=\"498.8995\" y2=\"109.9501\">\n      <stop  offset=\"2.737399e-007\" :style=\"'stop-color:'+toHex(colorpad[4])\"/>\n      <stop  offset=\"1\" :style=\"'stop-color:'+toHex(colorpad[4])+';stop-opacity:0.5'\"/>\n    </linearGradient>\n    <circle class=\"st48\" cx=\"498.9\" cy=\"81.9\" r=\"28\"/>\n  </g>\n</g>\n<g id=\"Temp_Color_06\"  @click=\"value = colorpad[5]\"  @mouseover=\"save=change,change={hover:'历史记录'}\" @mouseout=\"change=save\">\n  <g>\n    <path class=\"st2\" d=\"M608.1,74c-4.3-16-20.7-25.5-36.7-21.2c-16,4.3-25.5,20.7-21.2,36.7s20.7,25.5,36.7,21.2\n      C602.9,106.5,612.3,90,608.1,74z M586.3,108.8c-14.9,4-30.3-4.9-34.3-19.8c-4-14.9,4.9-30.3,19.8-34.3c14.9-4,30.3,4.9,34.3,19.8\n      C610.1,89.5,601.3,104.8,586.3,108.8z\"/>\n    <linearGradient id=\"SVGID_51_\" gradientUnits=\"userSpaceOnUse\" x1=\"579.0825\" y1=\"53.7619\" x2=\"579.0825\" y2=\"109.776\">\n      <stop  offset=\"3.708734e-007\" :style=\"'stop-color:'+toHex(colorpad[5])\"/>\n      <stop  offset=\"1\" :style=\"'stop-color:'+toHex(colorpad[5])+';stop-opacity:0.5'\"/>\n    </linearGradient>\n    <circle class=\"st49\" cx=\"579.1\" cy=\"81.8\" r=\"28\"/>\n  </g>\n</g>";

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(123)

	if (module.exports.__esModule) module.exports = module.exports.default
	;(typeof module.exports === "function" ? module.exports.options : module.exports).template = __webpack_require__(124)
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/bradpitt/Documents/front/carFitting/src/interact/remolder/materials/proColor.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
	  }
	})()}

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// <template>
	// <g id="Scale_P">
	//   <path class="st1" d="M449.4,291.1c-192.1,69.9-236,321.8-78.9,452.7c23.7,19.8,49,34.4,78,45c121.4,44.7,257.3-4.8,321.6-117
	//     c15.3-26.8,25.3-54.2,30.8-84.6C837.1,385.9,641.5,221.2,449.4,291.1z M799.2,584.8c-6.6-1.2-13.1-2.3-19.7-3.5
	//     c-0.1,0.7-0.2,1.3-0.3,2c6.6,1.2,13.1,2.3,19.7,3.5c-5.4,30.2-15.3,57.4-30.6,84c-5.8-3.3-11.5-6.7-17.3-10c-0.3,0.6-0.7,1.2-1,1.7
	//     c5.8,3.3,11.5,6.7,17.3,10c-15.4,26.5-34,48.7-57.4,68.5c-4.3-5.1-8.6-10.2-12.9-15.3c-0.5,0.4-1,0.9-1.5,1.3
	//     c4.3,5.1,8.6,10.2,12.9,15.3c-23.6,19.6-48.6,34.1-77.4,44.7c-2.3-6.3-4.6-12.5-6.8-18.8c-0.6,0.2-1.3,0.5-1.9,0.7
	//     c2.3,6.3,4.6,12.5,6.8,18.8c-28.8,10.4-57.4,15.4-88,15.5c0-6.7,0-13.3,0-20c-0.7,0-1.3,0-2,0c0,6.7,0,13.3,0,20
	//     c-30.6-0.1-59.2-5.1-88-15.5c2.3-6.3,4.6-12.5,6.8-18.8c-0.6-0.2-1.3-0.5-1.9-0.7c-2.3,6.3-4.6,12.5-6.8,18.8
	//     c-28.8-10.6-53.8-25.1-77.4-44.7c4.3-5.1,8.6-10.2,12.9-15.3c-0.5-0.4-1-0.9-1.5-1.3c-4.3,5.1-8.6,10.2-12.9,15.3
	//     c-23.4-19.8-42-42-57.4-68.5c5.8-3.3,11.5-6.7,17.3-10c-0.3-0.6-0.7-1.2-1-1.7c-5.8,3.3-11.5,6.7-17.3,10
	//     c-15.2-26.6-25.1-53.8-30.6-84c6.6-1.2,13.1-2.3,19.7-3.5c-0.1-0.7-0.2-1.3-0.3-2c-6.6,1.2-13.1,2.3-19.7,3.5
	//     c-5.2-30.2-5.2-59.2,0-89.4c6.6,1.2,13.1,2.3,19.7,3.5c0.1-0.7,0.2-1.3,0.3-2c-6.6-1.2-13.1-2.3-19.7-3.5
	//     c5.4-30.2,15.3-57.4,30.6-84c5.8,3.3,11.5,6.7,17.3,10c0.3-0.6,0.7-1.2,1-1.7c-5.8-3.3-11.5-6.7-17.3-10
	//     c15.4-26.5,34-48.7,57.4-68.5c4.3,5.1,8.6,10.2,12.9,15.3c0.5-0.4,1-0.9,1.5-1.3c-4.3-5.1-8.6-10.2-12.9-15.3
	//     c23.6-19.6,48.6-34.1,77.4-44.7c2.3,6.3,4.6,12.5,6.8,18.8c0.6-0.2,1.3-0.5,1.9-0.7c-2.3-6.3-4.6-12.5-6.8-18.8
	//     c28.8-10.4,57.4-15.4,88-15.5c0,6.7,0,13.3,0,20c0.7,0,1.3,0,2,0c0-6.7,0-13.3,0-20c30.6,0.1,59.2,5.1,88,15.5
	//     c-2.3,6.3-4.6,12.5-6.8,18.8c0.6,0.2,1.3,0.5,1.9,0.7c2.3-6.3,4.6-12.5,6.8-18.8c28.8,10.6,53.8,25.1,77.4,44.7
	//     c-4.3,5.1-8.6,10.2-12.9,15.3c0.5,0.4,1,0.9,1.5,1.3c4.3-5.1,8.6-10.2,12.9-15.3c23.4,19.8,42,42,57.4,68.5
	//     c-5.8,3.3-11.5,6.7-17.3,10c0.3,0.6,0.7,1.2,1,1.7c5.8-3.3,11.5-6.7,17.3-10c15.2,26.6,25.1,53.8,30.6,84
	//     c-6.6,1.2-13.1,2.3-19.7,3.5c0.1,0.7,0.2,1.3,0.3,2c6.6-1.2,13.1-2.3,19.7-3.5C804.5,525.6,804.5,554.6,799.2,584.8z"/>
	//   <path class="st1" d="M692.3,484.7c-30.6-84.1-123.6-127.4-207.6-96.8c-84.1,30.6-127.4,123.6-96.8,207.6
	//     c30.6,84.1,123.6,127.4,207.6,96.8C679.6,661.7,722.9,568.8,692.3,484.7z M594.8,690.5c-83,30.2-174.9-12.6-205.1-95.6
	//     c-30.2-83,12.6-174.9,95.6-205.1c83-30.2,174.9,12.6,205.1,95.6C720.6,568.4,677.8,660.2,594.8,690.5z"/>
	// </g>
	// <g id="Scale_BL2">
	//   <path class="st3_1" :fill="color" d="M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4
	//     C82,745.5,39.5,504.3,149.5,314.7z"/>
	// </g>
	// <g id="Scale_BL3">
	//   <linearGradient id="SVGID_1_1" gradientUnits="userSpaceOnUse" x1="214.4087" y1="932.3943" x2="44.3172" y2="297.604">
	//     <stop  offset="0" style="stop-color:#FFFFFF"/>
	//     <stop  offset="0.5" style="stop-color:#7A7A7A;stop-opacity:0"/>
	//     <stop  offset="1" style="stop-color:#000000"/>
	//   </linearGradient>
	//   <path class="st4_1" d="M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4
	//     C82,745.5,39.5,504.3,149.5,314.7z"/>
	// </g>
	// <g id="Scale_PL">
	//   <path class="st1" d="M251.6,885.5C83.4,745,40.9,503.8,150.9,314.2c-12.1-7-24.2-14-36.4-21c-0.3,0.6-0.7,1.2-1,1.7
	//     c11.5,6.7,23.1,13.3,34.6,20c-10.2,17.7-19.1,35.9-26.8,54.9c-6.2-2.5-12.4-5-18.5-7.5c-0.3,0.6-0.5,1.2-0.7,1.9
	//     c6.2,2.5,12.4,5,18.5,7.5c-7.6,19-13.9,38.2-18.9,58.1c-6.5-1.6-12.9-3.2-19.4-4.8c-0.2,0.6-0.3,1.3-0.5,1.9
	//     c6.5,1.6,12.9,3.2,19.4,4.8c-4.9,19.9-8.4,39.8-10.6,60.1c-6.6-0.7-13.3-1.4-19.9-2.1c-0.1,0.7-0.1,1.3-0.2,2
	//     c6.6,0.7,13.3,1.4,19.9,2.1c-2.1,20.3-2.8,40.6-2.1,61c-6.7,0.2-13.3,0.5-20,0.7c0,0.7,0,1.3,0.1,2c6.7-0.2,13.3-0.5,20-0.7
	//     c0.8,20.4,2.9,40.6,6.4,60.7c-13.1,2.3-26.3,4.6-39.4,6.9c0.1,0.7,0.2,1.3,0.3,2c13.1-2.3,26.3-4.6,39.4-6.9
	//     c3.6,20.1,8.5,39.8,14.8,59.2c-6.3,2.1-12.7,4.1-19,6.2c0.2,0.6,0.4,1.3,0.6,1.9c6.3-2.1,12.7-4.1,19-6.2
	//     c6.4,19.4,14,38.2,22.9,56.6c-6,2.9-12,5.8-18,8.8c0.3,0.6,0.6,1.2,0.9,1.8c6-2.9,12-5.8,18-8.8c9,18.4,19.1,35.9,30.5,52.9
	//     c-5.5,3.7-11.1,7.5-16.6,11.2c0.4,0.6,0.7,1.1,1.1,1.7c5.5-3.7,11.1-7.5,16.6-11.2c11.5,16.9,23.9,32.9,37.6,48.1
	//     c-5,4.5-9.9,8.9-14.9,13.4c0.4,0.5,0.9,1,1.3,1.5c5-4.5,9.9-8.9,14.9-13.4c13.7,15.2,28.3,29.2,43.9,42.4
	//     c-8.6,10.2-17.1,20.4-25.7,30.6c0.5,0.4,1,0.9,1.5,1.3C233.6,906.9,242.6,896.2,251.6,885.5z"/>
	// </g>
	// <g id="Scale_BR2">
	//   <path class="st3_1" :fill="color" d="M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1
	//     C900.2,190.4,1022.6,402.5,984.1,618.3z"/>
	// </g>
	// <g id="Scale_BR3">
	//   <linearGradient id="SVGID_2_1" gradientUnits="userSpaceOnUse" x1="968.8124" y1="649.5213" x2="803.8889" y2="34.0186">
	//     <stop  offset="0" style="stop-color:#808080;stop-opacity:1"/>
	//     <stop  offset="1" style="stop-color:#808080;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st5_1" d="M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1
	//     C900.2,190.4,1022.6,402.5,984.1,618.3z"/>
	// </g>
	// <g id="Scale_PR">
	//   <path class="st1" d="M983.1,619.2c38.5-215.7-83.9-427.8-290-502.3c4.8-13.2,9.6-26.3,14.4-39.5c0.6,0.2,1.3,0.5,1.9,0.7
	//     c-4.6,12.5-9.1,25.1-13.7,37.6c19.2,7,37.7,15.3,55.8,24.8c3.1-5.9,6.3-11.8,9.4-17.7c0.6,0.3,1.2,0.6,1.8,0.9
	//     c-3.1,5.9-6.3,11.8-9.4,17.7c18,9.6,35.2,20.4,51.8,32.4c3.9-5.4,7.8-10.8,11.8-16.2c0.5,0.4,1.1,0.8,1.6,1.2
	//     c-3.9,5.4-7.8,10.8-11.8,16.2c16.5,12.1,32,25.1,46.8,39.3c4.6-4.8,9.3-9.6,13.9-14.4c0.5,0.5,1,0.9,1.4,1.4
	//     c-4.6,4.8-9.3,9.6-13.9,14.4c14.7,14.2,28.2,29.3,40.9,45.4c5.3-4.1,10.5-8.2,15.8-12.3c0.4,0.5,0.8,1,1.2,1.6
	//     c-5.3,4.1-10.5,8.2-15.8,12.3c12.6,16.1,23.9,32.9,34.1,50.6c11.5-6.7,23.1-13.3,34.6-20c0.3,0.6,0.7,1.2,1,1.7
	//     c-11.5,6.7-23.1,13.3-34.6,20c10.2,17.7,19.1,35.9,26.8,54.9c6.2-2.5,12.4-5,18.5-7.5c0.3,0.6,0.5,1.2,0.7,1.9
	//     c-6.2,2.5-12.4,5-18.5,7.5c7.6,19,13.9,38.2,18.9,58.1c6.5-1.6,12.9-3.2,19.4-4.8c0.2,0.6,0.3,1.3,0.5,1.9
	//     c-6.5,1.6-12.9,3.2-19.4,4.8c4.9,19.9,8.4,39.8,10.6,60.1c6.6-0.7,13.3-1.4,19.9-2.1c0.1,0.7,0.1,1.3,0.2,2
	//     c-6.6,0.7-13.3,1.4-19.9,2.1c2.1,20.3,2.8,40.6,2.1,61c6.7,0.2,13.3,0.5,20,0.7c0,0.7,0,1.3-0.1,2c-6.7-0.2-13.3-0.5-20-0.7
	//     c-0.8,20.4-2.9,40.6-6.4,60.7c13.1,2.3,26.3,4.6,39.4,6.9c-0.1,0.7-0.2,1.3-0.3,2C1010.6,624.1,996.8,621.7,983.1,619.2z"/>
	// </g>
	// <g id="Color_P">
	//   <g>
	//     <defs>
	//       <path id="SVGID_1_" d="M867.2,309.9C740,129.2,490.5,85.9,309.8,213C129.2,340.2,85.8,589.7,213,770.4s376.7,224,557.3,96.8
	//         C951,740,994.3,490.5,867.2,309.9z M698.6,764.8c-124.1,87.6-295.7,58-383.2-66.1c-87.6-124.1-58-295.7,66.1-383.2
	//         c124.1-87.6,295.7-58,383.2,66.1S822.7,677.2,698.6,764.8z"/>
	//     </defs>
	//     <clipPath id="SVGID_2_">
	//       <use xlink:href="#SVGID_1_"  style="overflow:visible;"/>
	//     </clipPath>
	//     <g class="st2">
	//       <g>
	//         <defs>

	//             <rect id="SVGID_3_" x="77.8" y="77.8" transform="matrix(0.7071 -0.7071 0.7071 0.7071 -223.7432 540.0739)" width="924.6" height="924.6"/>
	//         </defs>
	//         <clipPath id="SVGID_4_">
	//           <use xlink:href="#SVGID_3_"  style="overflow:visible;"/>
	//         </clipPath>
	//         <g transform="matrix(1 0 0 1 0 1.525879e-005)" style="clip-path:url(#SVGID_4_);">

	//             <image style="overflow:visible;" width="2362" height="2362" xlink:href="hue-selector.jpg" transform="matrix(0.2768 0.2768 -0.2768 0.2768 540.0553 -113.6534)">
	//           </image>
	//         </g>
	//       </g>
	//     </g>
	//   </g>
	// </g>
	// <g id="Pin_P" :transform="'rotate(' + (360-deg)+ ' 540 540)'">
	//   <linearGradient id="SVGID_5_" gradientUnits="userSpaceOnUse" x1="875.5689" y1="540.1044" x2="517.0704" y2="540.1044">
	//     <stop  offset="0" style="stop-color:#F5D96C"/>
	//     <stop  offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st3" d="M561.3,531.2c-9.7-23.2-44.2-16.3-44.2,8.9c0,25.1,34.5,32.1,44.2,8.9c0.2-0.4,0.3-0.8,0.5-1.2
	//     c104.6-1.6,209.2-3.3,313.8-4.9c0-1.9,0-3.7,0-5.6c-104.6-1.6-209.2-3.3-313.8-4.9C561.6,532,561.5,531.6,561.3,531.2z"/>
	//   <linearGradient id="SVGID_6_" gradientUnits="userSpaceOnUse" x1="878.0686" y1="540.1048" x2="514.5707" y2="540.1048">
	//     <stop  offset="0" style="stop-color:#F5D96C"/>
	//     <stop  offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st4" d="M563.1,530.5c-10.5-25.2-48.1-17.7-48.1,9.6s37.5,34.8,48.1,9.6c104.8-1.6,209.6-3.3,314.4-4.9
	//     c0-1.6,0-3.2,0-4.8c0-1.6,0-3.2,0-4.8C772.8,533.7,667.9,532.1,563.1,530.5z"/>
	// </g>
	// <g id="Pin_PL" :transform="'rotate(' + BLangle + ' 540 540)'">
	//   <g>
	//     <linearGradient id="SVGID_171_" gradientUnits="userSpaceOnUse" x1="57.5965" y1="530.0045" x2="20.0443" y2="530.0045">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_171_);" d="M20,532.4c0-1.8,0.1-3.6,0.1-5.4c9.6,0.6,19.3,1.2,28.9,1.9c2.8,1.4,5.7,2.8,8.5,4.1    C45.1,532.8,32.6,532.6,20,532.4z"/>
	//     <linearGradient id="SVGID_181_" gradientUnits="userSpaceOnUse" x1="77.9868" y1="540.1041" x2="19.9875" y2="540.1041">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_181_);" d="M20,543.8c0-2.5,0-4.9,0-7.4c19.3,0.3,38.7,0.6,58,0.9c0,1.9,0,3.7,0,5.6C58.7,543.2,39.3,543.5,20,543.8z"/>
	//     <linearGradient id="SVGID_191_" gradientUnits="userSpaceOnUse" x1="57.5965" y1="550.2053" x2="20.0443" y2="550.2053">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_191_);" d="M20.2,553.2c0-1.8-0.1-3.6-0.1-5.4c12.5-0.2,25-0.4,37.6-0.6c-2.8,1.4-5.7,2.8-8.5,4.1    C39.4,552,29.8,552.6,20.2,553.2z"/>
	//   </g>
	// </g>
	// <g id="Pin_PR" :transform="'rotate(' + BRangle + ' 540 540)'">
	//   <g xmlns="http://www.w3.org/2000/svg">
	//     <linearGradient id="SVGID_101_" gradientUnits="userSpaceOnUse" x1="1022.4805" y1="550.2055" x2="1060.0327" y2="550.2055">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_101_)" d="M1059.9,553.2c0-1.8,0.1-3.6,0.1-5.4c-12.5-0.2-25-0.4-37.6-0.6c2.8,1.4,5.7,2.8,8.5,4.1    C1040.6,552,1050.3,552.6,1059.9,553.2z"/>
	//     <linearGradient id="SVGID_111_" gradientUnits="userSpaceOnUse" x1="1002.0901" y1="540.1044" x2="1060.0895" y2="540.1044">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_111_)" d="M1060.1,543.8c0-2.5,0-4.9,0-7.4c-19.3,0.3-38.7,0.6-58,0.9c0,1.9,0,3.7,0,5.6    C1021.4,543.2,1040.7,543.5,1060.1,543.8z"/>
	//     <linearGradient id="SVGID_121_" gradientUnits="userSpaceOnUse" x1="1022.4805" y1="530.0047" x2="1060.0327" y2="530.0047">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_121_)" d="M1060,532.4c0-1.8-0.1-3.6-0.1-5.4c-9.6,0.6-19.3,1.2-28.9,1.9c-2.8,1.4-5.7,2.8-8.5,4.1    C1035,532.8,1047.5,532.6,1060,532.4z"/>
	//   </g>
	// </g>
	// <g id="Monitor_P">
	//   <radialGradient id="SVGID_9_" cx="540.0702" cy="540.1046" r="150.0409" gradientUnits="userSpaceOnUse">
	//     <stop  offset="0" style="stop-color:#000000"/>
	//     <stop  offset="1" style="stop-color:#000000;stop-opacity:0.5"/>
	//   </radialGradient>
	//   <circle class="st7" cx="540.1" cy="540.1" r="150"/>
	//   <linearGradient id="SVGID_10_" gradientUnits="userSpaceOnUse" x1="540.0699" y1="392.0641" x2="540.0699" y2="688.1447">
	//     <stop  offset="9.271834e-008" :style="'stop-color:'+color"/>
	//     <stop  offset="1" :style="'stop-color:'+color"/>
	//   </linearGradient>
	//   <circle class="st8" cx="540.1" cy="540.1" r="148"/>
	//   <linearGradient id="SVGID_11_" gradientUnits="userSpaceOnUse" x1="540.0705" y1="396.6748" x2="540.0705" y2="524.5886">
	//     <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//     <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st9" d="M540.1,524.6c36.6,0,94.1-17.1,94.1-64c0-46.8-57.5-64-94.1-64c-36.6,0-94.1,17.1-94.1,64
	//     C446,507.5,503.5,524.6,540.1,524.6z"/>
	//   <linearGradient id="SVGID_12_" gradientUnits="userSpaceOnUse" x1="540.0699" y1="400.9027" x2="540.0699" y2="450.9808">
	//     <stop  offset="0" style="stop-color:#FFFFFF;stop-opacity:0.6"/>
	//     <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st10" d="M540.1,451c10.1,0,19.6-1.3,29.2-5c7.9-3,19.6-9.3,19.6-20.1c0-10.7-11.7-17-19.6-20.1c-9.6-3.7-19-5-29.1-5
	//     c-10.1,0-19.6,1.3-29.2,5c-7.9,3-19.6,9.3-19.6,20.1c0,10.7,11.7,17,19.6,20.1C520.5,449.7,529.9,451,540.1,451z"/>
	//   <linearGradient id="SVGID_13_" gradientUnits="userSpaceOnUse" x1="540.0705" y1="683.535" x2="540.0705" y2="555.6201">
	//     <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//     <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st11" d="M540.1,555.6c36.6,0,94.1,17.1,94.1,64c0,46.8-57.5,64-94.1,64c-36.6,0-94.1-17.1-94.1-64
	//     C446,572.7,503.5,555.6,540.1,555.6z"/>
	//   <text xmlns="http://www.w3.org/2000/svg" transform="matrix(1 0 0 1 484.3381 482)">
	//     <tspan x="0" y="0" style="font-size:36px;font-family:'HYg1gj'" v-text="change.name"></tspan>
	//     <tspan x="-25" y="130" style="font-size:120px;font-family:'HYg1gj'" v-text="change.value"></tspan>
	//     <tspan x="-20" y="120" style="font-size:36px;font-family:'HYg1gj'" v-text="change.hover"></tspan>
	//     <tspan x="150" y="130" style="font-size:36px" v-text="change.name?'%':''"></tspan>

	//   </text>
	// </g>
	// <g id="Metrial_Matt" @click="material='matte'">
	//   <g>
	//     <path class="st1" d="M451.9,982.1c-1.4-16.5-16-28.7-32.5-27.3c-16.5,1.4-28.7,16-27.3,32.5c1.4,16.5,16,28.7,32.5,27.3
	//       C441.1,1013.1,453.3,998.6,451.9,982.1z M424.4,1012.6c-15.4,1.3-29-10-30.3-25.5c-1.3-15.4,10-29,25.5-30.3
	//       c15.4-1.3,29,10,30.3,25.5C451.2,997.7,439.8,1011.2,424.4,1012.6z"/>
	//     <linearGradient id="SVGID_14_" gradientUnits="userSpaceOnUse" x1="421.982" y1="956.6859" x2="421.982" y2="1012.6892">
	//       <stop  offset="9.271834e-008" style="stop-color:#808080;stop-opacity:0.9"/>
	//       <stop  offset="1" style="stop-color:#1A1A1A;stop-opacity:0.9"/>
	//     </linearGradient>
	//     <circle class="st12" cx="422" cy="984.7" r="28"/>
	//   </g>
	// </g>
	// <g id="Metrial_Paint" @click="material = 'normal'">
	//   <g>
	//     <path class="st1" d="M530,990.7c-4.3-16-20.7-25.5-36.7-21.2c-16,4.3-25.5,20.7-21.2,36.7c4.3,16,20.7,25.5,36.7,21.2
	//       C524.7,1023.1,534.2,1006.7,530,990.7z M508.2,1025.5c-14.9,4-30.3-4.9-34.3-19.8c-4-14.9,4.9-30.3,19.8-34.3
	//       c14.9-4,30.3,4.9,34.3,19.8C532,1006.1,523.2,1021.5,508.2,1025.5z"/>
	//     <linearGradient id="SVGID_15_" gradientUnits="userSpaceOnUse" x1="500.9773" y1="970.433" x2="500.9773" y2="1026.4468">
	//       <stop  offset="9.271834e-008" style="stop-color:#808080;stop-opacity:0.9"/>
	//       <stop  offset="1" style="stop-color:#1A1A1A;stop-opacity:0.9"/>
	//     </linearGradient>
	//     <circle class="st13" cx="501" cy="998.4" r="28"/>
	//     <linearGradient id="SVGID_16_" gradientUnits="userSpaceOnUse" x1="500.9776" y1="971.3044" x2="500.9776" y2="990.4042">
	//       <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//       <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st14" d="M501,990.4c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5
	//       C484.4,988.7,495.4,990.4,501,990.4z"/>
	//   </g>
	// </g>
	// <g id="Material_Electroplate" @click="material = 'electroplate'">
	//   <g>
	//     <linearGradient id="SVGID_17_" gradientUnits="userSpaceOnUse" x1="581.1804" y1="970.2589" x2="581.1804" y2="1026.2723">
	//       <stop  offset="9.271834e-008" style="stop-color:#808080;stop-opacity:0.9"/>
	//       <stop  offset="1" style="stop-color:#1A1A1A;stop-opacity:0.9"/>
	//     </linearGradient>
	//     <circle class="st15" cx="581.2" cy="998.3" r="28"/>
	//     <linearGradient id="SVGID_18_" gradientUnits="userSpaceOnUse" x1="581.1605" y1="971.1303" x2="581.1605" y2="995.3297">
	//       <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//       <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st16" d="M581.2,995.3c6.9,0,17.8-3.2,17.8-12.1s-10.9-12.1-17.8-12.1c-6.9,0-17.8,3.2-17.8,12.1
	//       S574.2,995.3,581.2,995.3z"/>
	//     <linearGradient id="SVGID_19_" gradientUnits="userSpaceOnUse" x1="581.1611" y1="971.9307" x2="581.1611" y2="981.5522">
	//       <stop  offset="0" style="stop-color:#FFFFFF;stop-opacity:0.6"/>
	//       <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st17" d="M581.2,981.4c4.2,0,9.2,1.5,9.2-4.7c0-3.9-5-4.7-9.2-4.7c-4.2,0-9.2,1-9.2,4.7
	//       C571.9,982.9,577,981.4,581.2,981.4z"/>
	//     <path class="st1" d="M608.3,985.6c-7-15-24.9-21.5-39.9-14.5c-15,7-21.5,24.9-14.5,39.9c7,15,24.9,21.5,39.9,14.5
	//       C608.9,1018.5,615.4,1000.6,608.3,985.6z M593,1023.6c-14,6.5-30.7,0.5-37.2-13.5c-6.5-14-0.5-30.7,13.5-37.2
	//       c14-6.5,30.7-0.5,37.2,13.5C613.1,1000.4,607,1017.1,593,1023.6z"/>
	//   </g>
	// </g>
	// <!--g id="Material_Frosting" @click="material = 'matting'">
	//   <g>
	//     <path class="st1" d="M684.7,967c-9.5-13.6-28.2-16.9-41.8-7.4c-13.6,9.5-16.9,28.2-7.4,41.8c9.5,13.6,28.2,16.9,41.8,7.4
	//       C690.9,999.2,694.2,980.5,684.7,967z M676.2,1007.1c-12.7,8.9-30.1,5.8-39-6.9c-8.9-12.7-5.8-30.1,6.9-39
	//       c12.7-8.9,30.1-5.8,39,6.9C691.9,980.8,688.8,998.2,676.2,1007.1z"/>
	//     <g>
	//       <defs>
	//         <circle id="SVGID_20_" cx="660.1" cy="984.2" r="28"/>
	//       </defs>
	//       <clipPath id="SVGID_21_">
	//         <use xlink:href="#SVGID_20_"  style="overflow:visible;"/>
	//       </clipPath>
	//       <g class="st18">

	//           <image style="overflow:visible;" width="200" height="200" xlink:href="materials/matting.png" transform="matrix(0.4233 0 0 0.4233 617.7646 942.357)">
	//         </image>
	//       </g>
	//     </g>
	//     <linearGradient id="SVGID_22_" gradientUnits="userSpaceOnUse" x1="660.0952" y1="957.0345" x2="660.0952" y2="976.1343">
	//       <stop  offset="0" style="stop-color:#FFFFFF;stop-opacity:0.2"/>
	//       <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st19" d="M660.1,976.1c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5
	//       C643.5,974.4,654.5,976.1,660.1,976.1z"/>
	//   </g>
	// </g-->
	// <!--g id="Material_Brushed" @click="material = 'carbon'">
	//   <g>
	//     <g>
	//       <defs>
	//         <circle id="SVGID_23_" cx="735.4" cy="956.6" r="28"/>
	//       </defs>
	//       <clipPath id="SVGID_24_">
	//         <use xlink:href="#SVGID_23_"  style="overflow:visible;"/>
	//       </clipPath>
	//       <g class="st20">

	//           <image style="overflow:visible;" width="200" height="200" xlink:href="materials/carbon.png" transform="matrix(0.6852 0 0 0.6852 666.8676 888.5193)">
	//         </image>
	//       </g>
	//     </g>
	//     <path class="st1" d="M756.6,935.4c-11.7-11.7-30.7-11.7-42.4,0c-11.7,11.7-11.7,30.7,0,42.4c11.7,11.7,30.7,11.7,42.4,0
	//       C768.3,966.1,768.3,947.1,756.6,935.4z M755.2,976.4c-10.9,10.9-28.7,10.9-39.6,0c-10.9-10.9-10.9-28.7,0-39.6
	//       c10.9-10.9,28.7-10.9,39.6,0C766.1,947.7,766.1,965.4,755.2,976.4z"/>
	//     <linearGradient id="SVGID_25_" gradientUnits="userSpaceOnUse" x1="735.3828" y1="929.4463" x2="735.3828" y2="948.5473">
	//       <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//       <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st21" d="M735.4,948.5c5.6,0,16.6-1.7,16.6-9.6c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5
	//       C718.8,946.8,729.8,948.5,735.4,948.5z"/>
	//   </g>
	// </g-->
	// <!--g id="Material_Carbonfibre" @click="material = 'drawbench'">
	//   <g>
	//     <g>
	//       <defs>
	//         <circle id="SVGID_26_" cx="804.7" cy="916.3" r="28"/>
	//       </defs>
	//       <clipPath id="SVGID_27_">
	//         <use xlink:href="#SVGID_26_"  style="overflow:visible;"/>
	//       </clipPath>
	//       <g class="st22">

	//           <image style="overflow:visible;" width="200" height="200" xlink:href="materials/drawbench.png" transform="matrix(0.6029 0 0 0.6029 744.4496 853.8486)">
	//         </image>
	//       </g>
	//     </g>
	//     <path class="st1" d="M821.9,891.8c-13.6-9.5-32.3-6.2-41.8,7.4c-9.5,13.6-6.2,32.3,7.4,41.8c13.6,9.5,32.3,6.2,41.8-7.4
	//       C838.8,920,835.5,901.3,821.9,891.8z M827.7,932.4c-8.9,12.7-26.3,15.7-39,6.9c-12.7-8.9-15.7-26.3-6.9-39
	//       c8.9-12.7,26.3-15.7,39-6.9C833.5,902.3,836.5,919.7,827.7,932.4z"/>
	//     <linearGradient id="SVGID_28_" gradientUnits="userSpaceOnUse" x1="804.7361" y1="889.2046" x2="804.7361" y2="908.3044">
	//       <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//       <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st23" d="M804.7,908.3c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5
	//       C788.2,906.6,799.2,908.3,804.7,908.3z"/>
	//   </g>
	// </g-->
	// <g id="Material_Chameleon" @click="material = 'discolor'">
	//   <g>
	//     <linearGradient id="SVGID_29_" gradientUnits="userSpaceOnUse" x1="866.0483" y1="836.6588" x2="866.0483" y2="892.6722">
	//       <stop  offset="0" style="stop-color:#FFFFFF;stop-opacity:0.8"/>
	//       <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//     </linearGradient>
	//     <circle class="st24" cx="866" cy="864.7" r="28"/>
	//     <linearGradient id="SVGID_30_" gradientUnits="userSpaceOnUse" x1="866.0483" y1="891.8015" x2="866.0483" y2="872.7005">
	//       <stop  offset="0" style="stop-color:#0000FF;stop-opacity:0.5"/>
	//       <stop  offset="1" style="stop-color:#0000FF;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st25" d="M866,872.7c5.6,0,16.6,1.7,16.6,9.6c0,7.8-11,9.5-16.6,9.5c-5.6,0-16.6-1.7-16.6-9.5
	//       C849.5,874.4,860.5,872.7,866,872.7z"/>
	//     <path class="st1" d="M878.7,837.5c-15-7-32.9-0.5-39.9,14.5c-7,15-0.5,32.9,14.5,39.9c15,7,32.9,0.5,39.9-14.5
	//       C900.2,862.3,893.7,844.5,878.7,837.5z M891.4,876.5c-6.5,14-23.2,20.1-37.2,13.5c-14-6.5-20.1-23.2-13.5-37.2
	//       c6.5-14,23.2-20.1,37.2-13.5C891.9,845.8,898,862.5,891.4,876.5z"/>
	//     <linearGradient id="SVGID_31_" gradientUnits="userSpaceOnUse" x1="866.0483" y1="837.5306" x2="866.0483" y2="856.6304">
	//       <stop  offset="0" style="stop-color:#FF0000;stop-opacity:0.5"/>
	//       <stop  offset="1" style="stop-color:#FF0000;stop-opacity:0"/>
	//     </linearGradient>
	//     <path class="st26" d="M866,856.6c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5S860.5,856.6,866,856.6z
	//       "/>
	//   </g>
	// </g>
	// <g id="To_Basic" @click="current='junior'">
	//   <g>
	//     <path class="st1" d="M925.2,774.2c-16-4.3-32.5,5.2-36.7,21.2s5.2,32.5,21.2,36.7c16,4.3,32.5-5.2,36.7-21.2
	//       C950.7,794.9,941.2,778.4,925.2,774.2z M944.5,810.4c-4,14.9-19.4,23.8-34.3,19.8c-14.9-4-23.8-19.4-19.8-34.3
	//       c4-14.9,19.4-23.8,34.3-19.8C939.6,780.1,948.5,795.4,944.5,810.4z"/>
	//     <g>
	//       <defs>
	//         <circle id="SVGID_32_" cx="917.5" cy="803.1" r="28"/>
	//       </defs>
	//       <clipPath id="SVGID_33_">
	//         <use xlink:href="#SVGID_32_"  style="overflow:visible;"/>
	//       </clipPath>
	//       <g class="st27">

	//           <image style="overflow:visible;" width="884" height="873" xlink:href="colors-ring.png" transform="matrix(6.815579e-002 0 0 6.815579e-002 887.3278 773.3801)">
	//         </image>
	//       </g>
	//     </g>
	//   </g>
	// </g>
	// <g id="Temp_Color_01"  @click="value = colorpad[0]">
	//   <g>
	//     <path class="st1" d="M226.7,188.4c-15-7-32.9-0.5-39.9,14.5c-7,15-0.5,32.9,14.5,39.9c15,7,32.9,0.5,39.9-14.5
	//       C248.2,213.2,241.7,195.4,226.7,188.4z M239.4,227.4c-6.5,14-23.2,20.1-37.2,13.5c-14-6.5-20.1-23.2-13.5-37.2
	//       c6.5-14,23.2-20.1,37.2-13.5C239.9,196.7,245.9,213.4,239.4,227.4z"/>
	//     <linearGradient id="SVGID_34_" gradientUnits="userSpaceOnUse" x1="214.0118" y1="187.5365" x2="214.0118" y2="243.5498">
	//       <stop  offset="3.708734e-007" :style="'stop-color:'+toHex(colorpad[0])"/>
	//       <stop  offset="1" :style="'stop-color:'+toHex(colorpad[0])+';stop-opacity:0.5'"/>
	//     </linearGradient>
	//     <circle class="st28" cx="214" cy="215.5" r="28"/>
	//   </g>
	// </g>
	// <g id="Temp_Color_02"  @click="value = colorpad[1]">
	//   <g>
	//     <path class="st1" d="M292.5,139.3c-13.6-9.5-32.3-6.2-41.8,7.4c-9.5,13.6-6.2,32.3,7.4,41.8c13.6,9.5,32.3,6.2,41.8-7.4
	//       C309.4,167.5,306.1,148.8,292.5,139.3z M298.3,179.9c-8.9,12.7-26.3,15.7-39,6.9c-12.7-8.9-15.7-26.3-6.9-39
	//       c8.9-12.7,26.3-15.7,39-6.9C304.1,149.8,307.1,167.3,298.3,179.9z"/>
	//     <linearGradient id="SVGID_35_" gradientUnits="userSpaceOnUse" x1="275.3235" y1="135.8667" x2="275.3235" y2="191.8716">
	//       <stop  offset="0" :style="'stop-color:'+toHex(colorpad[1])"/>
	//       <stop  offset="1" :style="'stop-color:'+toHex(colorpad[1])+';stop-opacity:0.5'"/>
	//     </linearGradient>
	//     <circle class="st29" cx="275.3" cy="163.9" r="28"/>
	//   </g>
	// </g>
	// <g id="Temp_Color_03"  @click="value= colorpad[2]">
	//   <g>
	//     <path class="st1" d="M365.9,102.4c-11.7-11.7-30.7-11.7-42.4,0c-11.7,11.7-11.7,30.7,0,42.4c11.7,11.7,30.7,11.7,42.4,0
	//       C377.6,133.1,377.6,114.1,365.9,102.4z M364.5,143.4c-10.9,10.9-28.7,10.9-39.6,0c-10.9-10.9-10.9-28.7,0-39.6
	//       c10.9-10.9,28.7-10.9,39.6,0C375.4,114.8,375.4,132.5,364.5,143.4z"/>
	//     <linearGradient id="SVGID_36_" gradientUnits="userSpaceOnUse" x1="344.6773" y1="95.6269" x2="344.6773" y2="151.6267">
	//       <stop  offset="2.737399e-007" :style="'stop-color:'+toHex(colorpad[2])"/>
	//       <stop  offset="1" :style="'stop-color:'+toHex(colorpad[2])+';stop-opacity:0.5'"/>
	//     </linearGradient>
	//     <circle class="st30" cx="344.7" cy="123.6" r="28"/>
	//   </g>
	// </g>
	// <g id="Temp_Color_04"  @click="value = colorpad[3]">
	//   <g>
	//     <path class="st1" d="M444.5,78.8c-9.5-13.6-28.2-16.9-41.8-7.4c-13.6,9.5-16.9,28.2-7.4,41.8c9.5,13.6,28.2,16.9,41.8,7.4
	//       C450.7,111.1,454,92.4,444.5,78.8z M436,119c-12.7,8.9-30.1,5.8-39-6.9c-8.9-12.7-5.8-30.1,6.9-39c12.7-8.9,30.1-5.8,39,6.9
	//       C451.8,92.6,448.7,110.1,436,119z"/>
	//     <linearGradient id="SVGID_37_" gradientUnits="userSpaceOnUse" x1="419.9649" y1="68.0361" x2="419.9649" y2="124.041">
	//       <stop  offset="3.708734e-007" :style="'stop-color:'+toHex(colorpad[3])"/>
	//       <stop  offset="1" :style="'stop-color:'+toHex(colorpad[3])+';stop-opacity:0.5'"/>
	//     </linearGradient>
	//     <circle class="st31" cx="420" cy="96" r="28"/>
	//   </g>
	// </g>
	// <g id="Temp_Color_05"  @click="value = colorpad[4]">
	//   <g>
	//     <path class="st1" d="M526.1,69.3c-7-15-24.9-21.5-39.9-14.5c-15,7-21.5,24.9-14.5,39.9c7,15,24.9,21.5,39.9,14.5
	//       C526.6,102.1,533.1,84.3,526.1,69.3z M510.7,107.3c-14,6.5-30.7,0.5-37.2-13.5c-6.5-14-0.5-30.7,13.5-37.2
	//       c14-6.5,30.7-0.5,37.2,13.5C530.8,84.1,524.7,100.8,510.7,107.3z"/>
	//     <linearGradient id="SVGID_38_" gradientUnits="userSpaceOnUse" x1="498.8995" y1="53.9367" x2="498.8995" y2="109.9501">
	//       <stop  offset="2.737399e-007" :style="'stop-color:'+toHex(colorpad[4])"/>
	//       <stop  offset="1" :style="'stop-color:'+toHex(colorpad[4])+';stop-opacity:0.5'"/>
	//     </linearGradient>
	//     <circle class="st32" cx="498.9" cy="81.9" r="28"/>
	//   </g>
	// </g>
	// <g id="Temp_Color_06"  @click="value = colorpad[5]">
	//   <g>
	//     <path class="st1" d="M608.1,74c-4.3-16-20.7-25.5-36.7-21.2c-16,4.3-25.5,20.7-21.2,36.7s20.7,25.5,36.7,21.2
	//       C602.9,106.5,612.3,90,608.1,74z M586.3,108.8c-14.9,4-30.3-4.9-34.3-19.8c-4-14.9,4.9-30.3,19.8-34.3c14.9-4,30.3,4.9,34.3,19.8
	//       C610.1,89.5,601.3,104.8,586.3,108.8z"/>
	//     <linearGradient id="SVGID_39_" gradientUnits="userSpaceOnUse" x1="579.0825" y1="53.7619" x2="579.0825" y2="109.776">
	//       <stop  offset="3.708734e-007" :style="'stop-color:'+toHex(colorpad[5])"/>
	//       <stop  offset="1" :style="'stop-color:'+toHex(colorpad[5])+';stop-opacity:0.5'"/>
	//     </linearGradient>
	//     <circle class="st33" cx="579.1" cy="81.8" r="28"/>
	//   </g>
	// </g>
	// <style type="text/css">
	//   #regular .st4_1{fill:url(#SVGID_1_1);}
	//   #regular .st5_1{fill:url(#SVGID_2_1);}
	//   #regular .st0{fill:#333333;}
	//   #regular .st1{fill:#F5D96C;}
	//   #regular .st2{clip-path:url(#SVGID_2_);}
	//   #regular .st3{fill:url(#SVGID_5_);}
	//   #regular .st4{fill:none;stroke:url(#SVGID_6_);stroke-miterlimit:10;}
	//   #regular .st5{fill:url(#SVGID_7_);}
	//   #regular .st6{fill:url(#SVGID_8_);}
	//   #regular .st7{fill:url(#SVGID_9_);}
	//   #regular .st8{fill:url(#SVGID_10_);}
	//   #regular .st9{fill:url(#SVGID_11_);}
	//   #regular .st10{fill:url(#SVGID_12_);}
	//   #regular .st11{fill:url(#SVGID_13_);}
	//   #regular .st12{fill:url(#SVGID_14_);}
	//   #regular .st13{fill:url(#SVGID_15_);}
	//   #regular .st14{fill:url(#SVGID_16_);}
	//   #regular .st15{fill:url(#SVGID_17_);}
	//   #regular .st16{fill:url(#SVGID_18_);}
	//   #regular .st17{fill:url(#SVGID_19_);}
	//   #regular .st18{clip-path:url(#SVGID_21_);}
	//   #regular .st19{fill:url(#SVGID_22_);}
	//   #regular .st20{clip-path:url(#SVGID_24_);}
	//   #regular .st21{fill:url(#SVGID_25_);}
	//   #regular .st22{clip-path:url(#SVGID_27_);}
	//   #regular .st23{fill:url(#SVGID_28_);}
	//   #regular .st24{fill:url(#SVGID_29_);}
	//   #regular .st25{fill:url(#SVGID_30_);}
	//   #regular .st26{fill:url(#SVGID_31_);}
	//   #regular .st27{clip-path:url(#SVGID_33_);}
	//   #regular .st28{opacity:0.5;fill:url(#SVGID_34_);}
	//   #regular .st29{opacity:0.5;fill:url(#SVGID_35_);}
	//   #regular .st30{opacity:0.5;fill:url(#SVGID_36_);}
	//   #regular .st31{opacity:0.5;fill:url(#SVGID_37_);}
	//   #regular .st32{opacity:0.5;fill:url(#SVGID_38_);}
	//   #regular .st33{opacity:0.5;fill:url(#SVGID_39_);}
	// </style>
	// </template>

	// <script>
	var THREE = __webpack_require__(26);

	module.exports = {
	  props: ['value', 'BRangle', 'BLangle', 'current', 'deg', 'colorpad', 'material', 'spec'],
	  data: function data() {
	    return {
	      color: "",
	      colorSet: 'diffuse',
	      change: { name: "调色板" },
	      save: {}
	    };
	  },
	  computed: {
	    'color': function color() {
	      var h = this.value.h;
	      var s = this.value.s;
	      var l = this.value.l;
	      var color = new THREE.Color("hsl(" + h + "," + s + "," + l + ")");
	      return '#' + color.getHexString();
	    }
	  },
	  methods: {
	    toHex: function toHex(value) {
	      var h = value.h;
	      var s = value.s;
	      var l = value.l;
	      var color = new THREE.Color("hsl(" + h + "," + s + "," + l + ")");
	      return '#' + color.getHexString();
	    }
	  },
	  watch: {
	    value: function value(_value) {
	      var h = _value.h;
	      var s = _value.s;
	      var l = _value.l;
	      this.deg = h * 360;
	      this.BRangle = 10 - Number(s.substring(0, s.length - 1)) * 8 / 10;
	      this.BLangle = 30 - Number(l.substring(0, l.length - 1)) * 8 / 10;
	    },
	    deg: function deg(value) {
	      this.value = { h: (value / 360).toFixed(4), s: this.value.s, l: this.value.l };
	    },
	    BRangle: function BRangle(value) {
	      this.value = { h: this.value.h, s: (10 - value) * 10 / 8 + '%', l: this.value.l };
	      this.change = { name: '饱和度', value: (10 - value) * 10 / 8 };
	    },
	    BLangle: function BLangle(value) {
	      this.value = { h: this.value.h, s: this.value.s, l: (30 - value) * 10 / 8 + '%' };
	      this.change = { name: '明度', value: (30 - value) * 10 / 8 };
	    }
	  }
	};
	// </script>

/***/ },
/* 124 */
/***/ function(module, exports) {

	module.exports = "<g id=\"Scale_P\">\n  <path class=\"st1\" d=\"M449.4,291.1c-192.1,69.9-236,321.8-78.9,452.7c23.7,19.8,49,34.4,78,45c121.4,44.7,257.3-4.8,321.6-117\n    c15.3-26.8,25.3-54.2,30.8-84.6C837.1,385.9,641.5,221.2,449.4,291.1z M799.2,584.8c-6.6-1.2-13.1-2.3-19.7-3.5\n    c-0.1,0.7-0.2,1.3-0.3,2c6.6,1.2,13.1,2.3,19.7,3.5c-5.4,30.2-15.3,57.4-30.6,84c-5.8-3.3-11.5-6.7-17.3-10c-0.3,0.6-0.7,1.2-1,1.7\n    c5.8,3.3,11.5,6.7,17.3,10c-15.4,26.5-34,48.7-57.4,68.5c-4.3-5.1-8.6-10.2-12.9-15.3c-0.5,0.4-1,0.9-1.5,1.3\n    c4.3,5.1,8.6,10.2,12.9,15.3c-23.6,19.6-48.6,34.1-77.4,44.7c-2.3-6.3-4.6-12.5-6.8-18.8c-0.6,0.2-1.3,0.5-1.9,0.7\n    c2.3,6.3,4.6,12.5,6.8,18.8c-28.8,10.4-57.4,15.4-88,15.5c0-6.7,0-13.3,0-20c-0.7,0-1.3,0-2,0c0,6.7,0,13.3,0,20\n    c-30.6-0.1-59.2-5.1-88-15.5c2.3-6.3,4.6-12.5,6.8-18.8c-0.6-0.2-1.3-0.5-1.9-0.7c-2.3,6.3-4.6,12.5-6.8,18.8\n    c-28.8-10.6-53.8-25.1-77.4-44.7c4.3-5.1,8.6-10.2,12.9-15.3c-0.5-0.4-1-0.9-1.5-1.3c-4.3,5.1-8.6,10.2-12.9,15.3\n    c-23.4-19.8-42-42-57.4-68.5c5.8-3.3,11.5-6.7,17.3-10c-0.3-0.6-0.7-1.2-1-1.7c-5.8,3.3-11.5,6.7-17.3,10\n    c-15.2-26.6-25.1-53.8-30.6-84c6.6-1.2,13.1-2.3,19.7-3.5c-0.1-0.7-0.2-1.3-0.3-2c-6.6,1.2-13.1,2.3-19.7,3.5\n    c-5.2-30.2-5.2-59.2,0-89.4c6.6,1.2,13.1,2.3,19.7,3.5c0.1-0.7,0.2-1.3,0.3-2c-6.6-1.2-13.1-2.3-19.7-3.5\n    c5.4-30.2,15.3-57.4,30.6-84c5.8,3.3,11.5,6.7,17.3,10c0.3-0.6,0.7-1.2,1-1.7c-5.8-3.3-11.5-6.7-17.3-10\n    c15.4-26.5,34-48.7,57.4-68.5c4.3,5.1,8.6,10.2,12.9,15.3c0.5-0.4,1-0.9,1.5-1.3c-4.3-5.1-8.6-10.2-12.9-15.3\n    c23.6-19.6,48.6-34.1,77.4-44.7c2.3,6.3,4.6,12.5,6.8,18.8c0.6-0.2,1.3-0.5,1.9-0.7c-2.3-6.3-4.6-12.5-6.8-18.8\n    c28.8-10.4,57.4-15.4,88-15.5c0,6.7,0,13.3,0,20c0.7,0,1.3,0,2,0c0-6.7,0-13.3,0-20c30.6,0.1,59.2,5.1,88,15.5\n    c-2.3,6.3-4.6,12.5-6.8,18.8c0.6,0.2,1.3,0.5,1.9,0.7c2.3-6.3,4.6-12.5,6.8-18.8c28.8,10.6,53.8,25.1,77.4,44.7\n    c-4.3,5.1-8.6,10.2-12.9,15.3c0.5,0.4,1,0.9,1.5,1.3c4.3-5.1,8.6-10.2,12.9-15.3c23.4,19.8,42,42,57.4,68.5\n    c-5.8,3.3-11.5,6.7-17.3,10c0.3,0.6,0.7,1.2,1,1.7c5.8-3.3,11.5-6.7,17.3-10c15.2,26.6,25.1,53.8,30.6,84\n    c-6.6,1.2-13.1,2.3-19.7,3.5c0.1,0.7,0.2,1.3,0.3,2c6.6-1.2,13.1-2.3,19.7-3.5C804.5,525.6,804.5,554.6,799.2,584.8z\"/>\n  <path class=\"st1\" d=\"M692.3,484.7c-30.6-84.1-123.6-127.4-207.6-96.8c-84.1,30.6-127.4,123.6-96.8,207.6\n    c30.6,84.1,123.6,127.4,207.6,96.8C679.6,661.7,722.9,568.8,692.3,484.7z M594.8,690.5c-83,30.2-174.9-12.6-205.1-95.6\n    c-30.2-83,12.6-174.9,95.6-205.1c83-30.2,174.9,12.6,205.1,95.6C720.6,568.4,677.8,660.2,594.8,690.5z\"/>\n</g>\n<g id=\"Scale_BL2\">\n  <path class=\"st3_1\" :fill=\"color\" d=\"M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4\n    C82,745.5,39.5,504.3,149.5,314.7z\"/>\n</g>\n<g id=\"Scale_BL3\">\n  <linearGradient id=\"SVGID_1_1\" gradientUnits=\"userSpaceOnUse\" x1=\"214.4087\" y1=\"932.3943\" x2=\"44.3172\" y2=\"297.604\">\n    <stop  offset=\"0\" style=\"stop-color:#FFFFFF\"/>\n    <stop  offset=\"0.5\" style=\"stop-color:#7A7A7A;stop-opacity:0\"/>\n    <stop  offset=\"1\" style=\"stop-color:#000000\"/>\n  </linearGradient>\n  <path class=\"st4_1\" d=\"M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4\n    C82,745.5,39.5,504.3,149.5,314.7z\"/>\n</g>\n<g id=\"Scale_PL\">\n  <path class=\"st1\" d=\"M251.6,885.5C83.4,745,40.9,503.8,150.9,314.2c-12.1-7-24.2-14-36.4-21c-0.3,0.6-0.7,1.2-1,1.7\n    c11.5,6.7,23.1,13.3,34.6,20c-10.2,17.7-19.1,35.9-26.8,54.9c-6.2-2.5-12.4-5-18.5-7.5c-0.3,0.6-0.5,1.2-0.7,1.9\n    c6.2,2.5,12.4,5,18.5,7.5c-7.6,19-13.9,38.2-18.9,58.1c-6.5-1.6-12.9-3.2-19.4-4.8c-0.2,0.6-0.3,1.3-0.5,1.9\n    c6.5,1.6,12.9,3.2,19.4,4.8c-4.9,19.9-8.4,39.8-10.6,60.1c-6.6-0.7-13.3-1.4-19.9-2.1c-0.1,0.7-0.1,1.3-0.2,2\n    c6.6,0.7,13.3,1.4,19.9,2.1c-2.1,20.3-2.8,40.6-2.1,61c-6.7,0.2-13.3,0.5-20,0.7c0,0.7,0,1.3,0.1,2c6.7-0.2,13.3-0.5,20-0.7\n    c0.8,20.4,2.9,40.6,6.4,60.7c-13.1,2.3-26.3,4.6-39.4,6.9c0.1,0.7,0.2,1.3,0.3,2c13.1-2.3,26.3-4.6,39.4-6.9\n    c3.6,20.1,8.5,39.8,14.8,59.2c-6.3,2.1-12.7,4.1-19,6.2c0.2,0.6,0.4,1.3,0.6,1.9c6.3-2.1,12.7-4.1,19-6.2\n    c6.4,19.4,14,38.2,22.9,56.6c-6,2.9-12,5.8-18,8.8c0.3,0.6,0.6,1.2,0.9,1.8c6-2.9,12-5.8,18-8.8c9,18.4,19.1,35.9,30.5,52.9\n    c-5.5,3.7-11.1,7.5-16.6,11.2c0.4,0.6,0.7,1.1,1.1,1.7c5.5-3.7,11.1-7.5,16.6-11.2c11.5,16.9,23.9,32.9,37.6,48.1\n    c-5,4.5-9.9,8.9-14.9,13.4c0.4,0.5,0.9,1,1.3,1.5c5-4.5,9.9-8.9,14.9-13.4c13.7,15.2,28.3,29.2,43.9,42.4\n    c-8.6,10.2-17.1,20.4-25.7,30.6c0.5,0.4,1,0.9,1.5,1.3C233.6,906.9,242.6,896.2,251.6,885.5z\"/>\n</g>\n<g id=\"Scale_BR2\">\n  <path class=\"st3_1\" :fill=\"color\" d=\"M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1\n    C900.2,190.4,1022.6,402.5,984.1,618.3z\"/>\n</g>\n<g id=\"Scale_BR3\">\n  <linearGradient id=\"SVGID_2_1\" gradientUnits=\"userSpaceOnUse\" x1=\"968.8124\" y1=\"649.5213\" x2=\"803.8889\" y2=\"34.0186\">\n    <stop  offset=\"0\" style=\"stop-color:#808080;stop-opacity:1\"/>\n    <stop  offset=\"1\" style=\"stop-color:#808080;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st5_1\" d=\"M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1\n    C900.2,190.4,1022.6,402.5,984.1,618.3z\"/>\n</g>\n<g id=\"Scale_PR\">\n  <path class=\"st1\" d=\"M983.1,619.2c38.5-215.7-83.9-427.8-290-502.3c4.8-13.2,9.6-26.3,14.4-39.5c0.6,0.2,1.3,0.5,1.9,0.7\n    c-4.6,12.5-9.1,25.1-13.7,37.6c19.2,7,37.7,15.3,55.8,24.8c3.1-5.9,6.3-11.8,9.4-17.7c0.6,0.3,1.2,0.6,1.8,0.9\n    c-3.1,5.9-6.3,11.8-9.4,17.7c18,9.6,35.2,20.4,51.8,32.4c3.9-5.4,7.8-10.8,11.8-16.2c0.5,0.4,1.1,0.8,1.6,1.2\n    c-3.9,5.4-7.8,10.8-11.8,16.2c16.5,12.1,32,25.1,46.8,39.3c4.6-4.8,9.3-9.6,13.9-14.4c0.5,0.5,1,0.9,1.4,1.4\n    c-4.6,4.8-9.3,9.6-13.9,14.4c14.7,14.2,28.2,29.3,40.9,45.4c5.3-4.1,10.5-8.2,15.8-12.3c0.4,0.5,0.8,1,1.2,1.6\n    c-5.3,4.1-10.5,8.2-15.8,12.3c12.6,16.1,23.9,32.9,34.1,50.6c11.5-6.7,23.1-13.3,34.6-20c0.3,0.6,0.7,1.2,1,1.7\n    c-11.5,6.7-23.1,13.3-34.6,20c10.2,17.7,19.1,35.9,26.8,54.9c6.2-2.5,12.4-5,18.5-7.5c0.3,0.6,0.5,1.2,0.7,1.9\n    c-6.2,2.5-12.4,5-18.5,7.5c7.6,19,13.9,38.2,18.9,58.1c6.5-1.6,12.9-3.2,19.4-4.8c0.2,0.6,0.3,1.3,0.5,1.9\n    c-6.5,1.6-12.9,3.2-19.4,4.8c4.9,19.9,8.4,39.8,10.6,60.1c6.6-0.7,13.3-1.4,19.9-2.1c0.1,0.7,0.1,1.3,0.2,2\n    c-6.6,0.7-13.3,1.4-19.9,2.1c2.1,20.3,2.8,40.6,2.1,61c6.7,0.2,13.3,0.5,20,0.7c0,0.7,0,1.3-0.1,2c-6.7-0.2-13.3-0.5-20-0.7\n    c-0.8,20.4-2.9,40.6-6.4,60.7c13.1,2.3,26.3,4.6,39.4,6.9c-0.1,0.7-0.2,1.3-0.3,2C1010.6,624.1,996.8,621.7,983.1,619.2z\"/>\n</g>\n<g id=\"Color_P\">\n  <g>\n    <defs>\n      <path id=\"SVGID_1_\" d=\"M867.2,309.9C740,129.2,490.5,85.9,309.8,213C129.2,340.2,85.8,589.7,213,770.4s376.7,224,557.3,96.8\n        C951,740,994.3,490.5,867.2,309.9z M698.6,764.8c-124.1,87.6-295.7,58-383.2-66.1c-87.6-124.1-58-295.7,66.1-383.2\n        c124.1-87.6,295.7-58,383.2,66.1S822.7,677.2,698.6,764.8z\"/>\n    </defs>\n    <clipPath id=\"SVGID_2_\">\n      <use xlink:href=\"#SVGID_1_\"  style=\"overflow:visible;\"/>\n    </clipPath>\n    <g class=\"st2\">\n      <g>\n        <defs>\n\n            <rect id=\"SVGID_3_\" x=\"77.8\" y=\"77.8\" transform=\"matrix(0.7071 -0.7071 0.7071 0.7071 -223.7432 540.0739)\" width=\"924.6\" height=\"924.6\"/>\n        </defs>\n        <clipPath id=\"SVGID_4_\">\n          <use xlink:href=\"#SVGID_3_\"  style=\"overflow:visible;\"/>\n        </clipPath>\n        <g transform=\"matrix(1 0 0 1 0 1.525879e-005)\" style=\"clip-path:url(#SVGID_4_);\">\n\n            <image style=\"overflow:visible;\" width=\"2362\" height=\"2362\" xlink:href=\"hue-selector.jpg\" transform=\"matrix(0.2768 0.2768 -0.2768 0.2768 540.0553 -113.6534)\">\n          </image>\n        </g>\n      </g>\n    </g>\n  </g>\n</g>\n<g id=\"Pin_P\" :transform=\"'rotate(' + (360-deg)+ ' 540 540)'\">\n  <linearGradient id=\"SVGID_5_\" gradientUnits=\"userSpaceOnUse\" x1=\"875.5689\" y1=\"540.1044\" x2=\"517.0704\" y2=\"540.1044\">\n    <stop  offset=\"0\" style=\"stop-color:#F5D96C\"/>\n    <stop  offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st3\" d=\"M561.3,531.2c-9.7-23.2-44.2-16.3-44.2,8.9c0,25.1,34.5,32.1,44.2,8.9c0.2-0.4,0.3-0.8,0.5-1.2\n    c104.6-1.6,209.2-3.3,313.8-4.9c0-1.9,0-3.7,0-5.6c-104.6-1.6-209.2-3.3-313.8-4.9C561.6,532,561.5,531.6,561.3,531.2z\"/>\n  <linearGradient id=\"SVGID_6_\" gradientUnits=\"userSpaceOnUse\" x1=\"878.0686\" y1=\"540.1048\" x2=\"514.5707\" y2=\"540.1048\">\n    <stop  offset=\"0\" style=\"stop-color:#F5D96C\"/>\n    <stop  offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st4\" d=\"M563.1,530.5c-10.5-25.2-48.1-17.7-48.1,9.6s37.5,34.8,48.1,9.6c104.8-1.6,209.6-3.3,314.4-4.9\n    c0-1.6,0-3.2,0-4.8c0-1.6,0-3.2,0-4.8C772.8,533.7,667.9,532.1,563.1,530.5z\"/>\n</g>\n<g id=\"Pin_PL\" :transform=\"'rotate(' + BLangle + ' 540 540)'\">\n  <g>\n    <linearGradient id=\"SVGID_171_\" gradientUnits=\"userSpaceOnUse\" x1=\"57.5965\" y1=\"530.0045\" x2=\"20.0443\" y2=\"530.0045\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_171_);\" d=\"M20,532.4c0-1.8,0.1-3.6,0.1-5.4c9.6,0.6,19.3,1.2,28.9,1.9c2.8,1.4,5.7,2.8,8.5,4.1    C45.1,532.8,32.6,532.6,20,532.4z\"/>\n    <linearGradient id=\"SVGID_181_\" gradientUnits=\"userSpaceOnUse\" x1=\"77.9868\" y1=\"540.1041\" x2=\"19.9875\" y2=\"540.1041\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_181_);\" d=\"M20,543.8c0-2.5,0-4.9,0-7.4c19.3,0.3,38.7,0.6,58,0.9c0,1.9,0,3.7,0,5.6C58.7,543.2,39.3,543.5,20,543.8z\"/>\n    <linearGradient id=\"SVGID_191_\" gradientUnits=\"userSpaceOnUse\" x1=\"57.5965\" y1=\"550.2053\" x2=\"20.0443\" y2=\"550.2053\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_191_);\" d=\"M20.2,553.2c0-1.8-0.1-3.6-0.1-5.4c12.5-0.2,25-0.4,37.6-0.6c-2.8,1.4-5.7,2.8-8.5,4.1    C39.4,552,29.8,552.6,20.2,553.2z\"/>\n  </g>\n</g>\n<g id=\"Pin_PR\" :transform=\"'rotate(' + BRangle + ' 540 540)'\">\n  <g xmlns=\"http://www.w3.org/2000/svg\">\n    <linearGradient id=\"SVGID_101_\" gradientUnits=\"userSpaceOnUse\" x1=\"1022.4805\" y1=\"550.2055\" x2=\"1060.0327\" y2=\"550.2055\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_101_)\" d=\"M1059.9,553.2c0-1.8,0.1-3.6,0.1-5.4c-12.5-0.2-25-0.4-37.6-0.6c2.8,1.4,5.7,2.8,8.5,4.1    C1040.6,552,1050.3,552.6,1059.9,553.2z\"/>\n    <linearGradient id=\"SVGID_111_\" gradientUnits=\"userSpaceOnUse\" x1=\"1002.0901\" y1=\"540.1044\" x2=\"1060.0895\" y2=\"540.1044\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_111_)\" d=\"M1060.1,543.8c0-2.5,0-4.9,0-7.4c-19.3,0.3-38.7,0.6-58,0.9c0,1.9,0,3.7,0,5.6    C1021.4,543.2,1040.7,543.5,1060.1,543.8z\"/>\n    <linearGradient id=\"SVGID_121_\" gradientUnits=\"userSpaceOnUse\" x1=\"1022.4805\" y1=\"530.0047\" x2=\"1060.0327\" y2=\"530.0047\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_121_)\" d=\"M1060,532.4c0-1.8-0.1-3.6-0.1-5.4c-9.6,0.6-19.3,1.2-28.9,1.9c-2.8,1.4-5.7,2.8-8.5,4.1    C1035,532.8,1047.5,532.6,1060,532.4z\"/>\n  </g>\n</g>\n<g id=\"Monitor_P\">\n  <radialGradient id=\"SVGID_9_\" cx=\"540.0702\" cy=\"540.1046\" r=\"150.0409\" gradientUnits=\"userSpaceOnUse\">\n    <stop  offset=\"0\" style=\"stop-color:#000000\"/>\n    <stop  offset=\"1\" style=\"stop-color:#000000;stop-opacity:0.5\"/>\n  </radialGradient>\n  <circle class=\"st7\" cx=\"540.1\" cy=\"540.1\" r=\"150\"/>\n  <linearGradient id=\"SVGID_10_\" gradientUnits=\"userSpaceOnUse\" x1=\"540.0699\" y1=\"392.0641\" x2=\"540.0699\" y2=\"688.1447\">\n    <stop  offset=\"9.271834e-008\" :style=\"'stop-color:'+color\"/>\n    <stop  offset=\"1\" :style=\"'stop-color:'+color\"/>\n  </linearGradient>\n  <circle class=\"st8\" cx=\"540.1\" cy=\"540.1\" r=\"148\"/>\n  <linearGradient id=\"SVGID_11_\" gradientUnits=\"userSpaceOnUse\" x1=\"540.0705\" y1=\"396.6748\" x2=\"540.0705\" y2=\"524.5886\">\n    <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n    <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st9\" d=\"M540.1,524.6c36.6,0,94.1-17.1,94.1-64c0-46.8-57.5-64-94.1-64c-36.6,0-94.1,17.1-94.1,64\n    C446,507.5,503.5,524.6,540.1,524.6z\"/>\n  <linearGradient id=\"SVGID_12_\" gradientUnits=\"userSpaceOnUse\" x1=\"540.0699\" y1=\"400.9027\" x2=\"540.0699\" y2=\"450.9808\">\n    <stop  offset=\"0\" style=\"stop-color:#FFFFFF;stop-opacity:0.6\"/>\n    <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st10\" d=\"M540.1,451c10.1,0,19.6-1.3,29.2-5c7.9-3,19.6-9.3,19.6-20.1c0-10.7-11.7-17-19.6-20.1c-9.6-3.7-19-5-29.1-5\n    c-10.1,0-19.6,1.3-29.2,5c-7.9,3-19.6,9.3-19.6,20.1c0,10.7,11.7,17,19.6,20.1C520.5,449.7,529.9,451,540.1,451z\"/>\n  <linearGradient id=\"SVGID_13_\" gradientUnits=\"userSpaceOnUse\" x1=\"540.0705\" y1=\"683.535\" x2=\"540.0705\" y2=\"555.6201\">\n    <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n    <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st11\" d=\"M540.1,555.6c36.6,0,94.1,17.1,94.1,64c0,46.8-57.5,64-94.1,64c-36.6,0-94.1-17.1-94.1-64\n    C446,572.7,503.5,555.6,540.1,555.6z\"/>\n  <text xmlns=\"http://www.w3.org/2000/svg\" transform=\"matrix(1 0 0 1 484.3381 482)\">\n    <tspan x=\"0\" y=\"0\" style=\"font-size:36px;font-family:'HYg1gj'\" v-text=\"change.name\"></tspan>\n    <tspan x=\"-25\" y=\"130\" style=\"font-size:120px;font-family:'HYg1gj'\" v-text=\"change.value\"></tspan>\n    <tspan x=\"-20\" y=\"120\" style=\"font-size:36px;font-family:'HYg1gj'\" v-text=\"change.hover\"></tspan>\n    <tspan x=\"150\" y=\"130\" style=\"font-size:36px\" v-text=\"change.name?'%':''\"></tspan>\n\n  </text>\n</g>\n<g id=\"Metrial_Matt\" @click=\"material='matte'\">\n  <g>\n    <path class=\"st1\" d=\"M451.9,982.1c-1.4-16.5-16-28.7-32.5-27.3c-16.5,1.4-28.7,16-27.3,32.5c1.4,16.5,16,28.7,32.5,27.3\n      C441.1,1013.1,453.3,998.6,451.9,982.1z M424.4,1012.6c-15.4,1.3-29-10-30.3-25.5c-1.3-15.4,10-29,25.5-30.3\n      c15.4-1.3,29,10,30.3,25.5C451.2,997.7,439.8,1011.2,424.4,1012.6z\"/>\n    <linearGradient id=\"SVGID_14_\" gradientUnits=\"userSpaceOnUse\" x1=\"421.982\" y1=\"956.6859\" x2=\"421.982\" y2=\"1012.6892\">\n      <stop  offset=\"9.271834e-008\" style=\"stop-color:#808080;stop-opacity:0.9\"/>\n      <stop  offset=\"1\" style=\"stop-color:#1A1A1A;stop-opacity:0.9\"/>\n    </linearGradient>\n    <circle class=\"st12\" cx=\"422\" cy=\"984.7\" r=\"28\"/>\n  </g>\n</g>\n<g id=\"Metrial_Paint\" @click=\"material = 'normal'\">\n  <g>\n    <path class=\"st1\" d=\"M530,990.7c-4.3-16-20.7-25.5-36.7-21.2c-16,4.3-25.5,20.7-21.2,36.7c4.3,16,20.7,25.5,36.7,21.2\n      C524.7,1023.1,534.2,1006.7,530,990.7z M508.2,1025.5c-14.9,4-30.3-4.9-34.3-19.8c-4-14.9,4.9-30.3,19.8-34.3\n      c14.9-4,30.3,4.9,34.3,19.8C532,1006.1,523.2,1021.5,508.2,1025.5z\"/>\n    <linearGradient id=\"SVGID_15_\" gradientUnits=\"userSpaceOnUse\" x1=\"500.9773\" y1=\"970.433\" x2=\"500.9773\" y2=\"1026.4468\">\n      <stop  offset=\"9.271834e-008\" style=\"stop-color:#808080;stop-opacity:0.9\"/>\n      <stop  offset=\"1\" style=\"stop-color:#1A1A1A;stop-opacity:0.9\"/>\n    </linearGradient>\n    <circle class=\"st13\" cx=\"501\" cy=\"998.4\" r=\"28\"/>\n    <linearGradient id=\"SVGID_16_\" gradientUnits=\"userSpaceOnUse\" x1=\"500.9776\" y1=\"971.3044\" x2=\"500.9776\" y2=\"990.4042\">\n      <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st14\" d=\"M501,990.4c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5\n      C484.4,988.7,495.4,990.4,501,990.4z\"/>\n  </g>\n</g>\n<g id=\"Material_Electroplate\" @click=\"material = 'electroplate'\">\n  <g>\n    <linearGradient id=\"SVGID_17_\" gradientUnits=\"userSpaceOnUse\" x1=\"581.1804\" y1=\"970.2589\" x2=\"581.1804\" y2=\"1026.2723\">\n      <stop  offset=\"9.271834e-008\" style=\"stop-color:#808080;stop-opacity:0.9\"/>\n      <stop  offset=\"1\" style=\"stop-color:#1A1A1A;stop-opacity:0.9\"/>\n    </linearGradient>\n    <circle class=\"st15\" cx=\"581.2\" cy=\"998.3\" r=\"28\"/>\n    <linearGradient id=\"SVGID_18_\" gradientUnits=\"userSpaceOnUse\" x1=\"581.1605\" y1=\"971.1303\" x2=\"581.1605\" y2=\"995.3297\">\n      <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st16\" d=\"M581.2,995.3c6.9,0,17.8-3.2,17.8-12.1s-10.9-12.1-17.8-12.1c-6.9,0-17.8,3.2-17.8,12.1\n      S574.2,995.3,581.2,995.3z\"/>\n    <linearGradient id=\"SVGID_19_\" gradientUnits=\"userSpaceOnUse\" x1=\"581.1611\" y1=\"971.9307\" x2=\"581.1611\" y2=\"981.5522\">\n      <stop  offset=\"0\" style=\"stop-color:#FFFFFF;stop-opacity:0.6\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st17\" d=\"M581.2,981.4c4.2,0,9.2,1.5,9.2-4.7c0-3.9-5-4.7-9.2-4.7c-4.2,0-9.2,1-9.2,4.7\n      C571.9,982.9,577,981.4,581.2,981.4z\"/>\n    <path class=\"st1\" d=\"M608.3,985.6c-7-15-24.9-21.5-39.9-14.5c-15,7-21.5,24.9-14.5,39.9c7,15,24.9,21.5,39.9,14.5\n      C608.9,1018.5,615.4,1000.6,608.3,985.6z M593,1023.6c-14,6.5-30.7,0.5-37.2-13.5c-6.5-14-0.5-30.7,13.5-37.2\n      c14-6.5,30.7-0.5,37.2,13.5C613.1,1000.4,607,1017.1,593,1023.6z\"/>\n  </g>\n</g>\n<!--g id=\"Material_Frosting\" @click=\"material = 'matting'\">\n  <g>\n    <path class=\"st1\" d=\"M684.7,967c-9.5-13.6-28.2-16.9-41.8-7.4c-13.6,9.5-16.9,28.2-7.4,41.8c9.5,13.6,28.2,16.9,41.8,7.4\n      C690.9,999.2,694.2,980.5,684.7,967z M676.2,1007.1c-12.7,8.9-30.1,5.8-39-6.9c-8.9-12.7-5.8-30.1,6.9-39\n      c12.7-8.9,30.1-5.8,39,6.9C691.9,980.8,688.8,998.2,676.2,1007.1z\"/>\n    <g>\n      <defs>\n        <circle id=\"SVGID_20_\" cx=\"660.1\" cy=\"984.2\" r=\"28\"/>\n      </defs>\n      <clipPath id=\"SVGID_21_\">\n        <use xlink:href=\"#SVGID_20_\"  style=\"overflow:visible;\"/>\n      </clipPath>\n      <g class=\"st18\">\n\n          <image style=\"overflow:visible;\" width=\"200\" height=\"200\" xlink:href=\"materials/matting.png\" transform=\"matrix(0.4233 0 0 0.4233 617.7646 942.357)\">\n        </image>\n      </g>\n    </g>\n    <linearGradient id=\"SVGID_22_\" gradientUnits=\"userSpaceOnUse\" x1=\"660.0952\" y1=\"957.0345\" x2=\"660.0952\" y2=\"976.1343\">\n      <stop  offset=\"0\" style=\"stop-color:#FFFFFF;stop-opacity:0.2\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st19\" d=\"M660.1,976.1c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5\n      C643.5,974.4,654.5,976.1,660.1,976.1z\"/>\n  </g>\n</g-->\n<!--g id=\"Material_Brushed\" @click=\"material = 'carbon'\">\n  <g>\n    <g>\n      <defs>\n        <circle id=\"SVGID_23_\" cx=\"735.4\" cy=\"956.6\" r=\"28\"/>\n      </defs>\n      <clipPath id=\"SVGID_24_\">\n        <use xlink:href=\"#SVGID_23_\"  style=\"overflow:visible;\"/>\n      </clipPath>\n      <g class=\"st20\">\n\n          <image style=\"overflow:visible;\" width=\"200\" height=\"200\" xlink:href=\"materials/carbon.png\" transform=\"matrix(0.6852 0 0 0.6852 666.8676 888.5193)\">\n        </image>\n      </g>\n    </g>\n    <path class=\"st1\" d=\"M756.6,935.4c-11.7-11.7-30.7-11.7-42.4,0c-11.7,11.7-11.7,30.7,0,42.4c11.7,11.7,30.7,11.7,42.4,0\n      C768.3,966.1,768.3,947.1,756.6,935.4z M755.2,976.4c-10.9,10.9-28.7,10.9-39.6,0c-10.9-10.9-10.9-28.7,0-39.6\n      c10.9-10.9,28.7-10.9,39.6,0C766.1,947.7,766.1,965.4,755.2,976.4z\"/>\n    <linearGradient id=\"SVGID_25_\" gradientUnits=\"userSpaceOnUse\" x1=\"735.3828\" y1=\"929.4463\" x2=\"735.3828\" y2=\"948.5473\">\n      <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st21\" d=\"M735.4,948.5c5.6,0,16.6-1.7,16.6-9.6c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5\n      C718.8,946.8,729.8,948.5,735.4,948.5z\"/>\n  </g>\n</g-->\n<!--g id=\"Material_Carbonfibre\" @click=\"material = 'drawbench'\">\n  <g>\n    <g>\n      <defs>\n        <circle id=\"SVGID_26_\" cx=\"804.7\" cy=\"916.3\" r=\"28\"/>\n      </defs>\n      <clipPath id=\"SVGID_27_\">\n        <use xlink:href=\"#SVGID_26_\"  style=\"overflow:visible;\"/>\n      </clipPath>\n      <g class=\"st22\">\n\n          <image style=\"overflow:visible;\" width=\"200\" height=\"200\" xlink:href=\"materials/drawbench.png\" transform=\"matrix(0.6029 0 0 0.6029 744.4496 853.8486)\">\n        </image>\n      </g>\n    </g>\n    <path class=\"st1\" d=\"M821.9,891.8c-13.6-9.5-32.3-6.2-41.8,7.4c-9.5,13.6-6.2,32.3,7.4,41.8c13.6,9.5,32.3,6.2,41.8-7.4\n      C838.8,920,835.5,901.3,821.9,891.8z M827.7,932.4c-8.9,12.7-26.3,15.7-39,6.9c-12.7-8.9-15.7-26.3-6.9-39\n      c8.9-12.7,26.3-15.7,39-6.9C833.5,902.3,836.5,919.7,827.7,932.4z\"/>\n    <linearGradient id=\"SVGID_28_\" gradientUnits=\"userSpaceOnUse\" x1=\"804.7361\" y1=\"889.2046\" x2=\"804.7361\" y2=\"908.3044\">\n      <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st23\" d=\"M804.7,908.3c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5\n      C788.2,906.6,799.2,908.3,804.7,908.3z\"/>\n  </g>\n</g-->\n<g id=\"Material_Chameleon\" @click=\"material = 'discolor'\">\n  <g>\n    <linearGradient id=\"SVGID_29_\" gradientUnits=\"userSpaceOnUse\" x1=\"866.0483\" y1=\"836.6588\" x2=\"866.0483\" y2=\"892.6722\">\n      <stop  offset=\"0\" style=\"stop-color:#FFFFFF;stop-opacity:0.8\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n    </linearGradient>\n    <circle class=\"st24\" cx=\"866\" cy=\"864.7\" r=\"28\"/>\n    <linearGradient id=\"SVGID_30_\" gradientUnits=\"userSpaceOnUse\" x1=\"866.0483\" y1=\"891.8015\" x2=\"866.0483\" y2=\"872.7005\">\n      <stop  offset=\"0\" style=\"stop-color:#0000FF;stop-opacity:0.5\"/>\n      <stop  offset=\"1\" style=\"stop-color:#0000FF;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st25\" d=\"M866,872.7c5.6,0,16.6,1.7,16.6,9.6c0,7.8-11,9.5-16.6,9.5c-5.6,0-16.6-1.7-16.6-9.5\n      C849.5,874.4,860.5,872.7,866,872.7z\"/>\n    <path class=\"st1\" d=\"M878.7,837.5c-15-7-32.9-0.5-39.9,14.5c-7,15-0.5,32.9,14.5,39.9c15,7,32.9,0.5,39.9-14.5\n      C900.2,862.3,893.7,844.5,878.7,837.5z M891.4,876.5c-6.5,14-23.2,20.1-37.2,13.5c-14-6.5-20.1-23.2-13.5-37.2\n      c6.5-14,23.2-20.1,37.2-13.5C891.9,845.8,898,862.5,891.4,876.5z\"/>\n    <linearGradient id=\"SVGID_31_\" gradientUnits=\"userSpaceOnUse\" x1=\"866.0483\" y1=\"837.5306\" x2=\"866.0483\" y2=\"856.6304\">\n      <stop  offset=\"0\" style=\"stop-color:#FF0000;stop-opacity:0.5\"/>\n      <stop  offset=\"1\" style=\"stop-color:#FF0000;stop-opacity:0\"/>\n    </linearGradient>\n    <path class=\"st26\" d=\"M866,856.6c5.6,0,16.6-1.7,16.6-9.5c0-7.8-11-9.5-16.6-9.5c-5.6,0-16.6,1.7-16.6,9.5S860.5,856.6,866,856.6z\n      \"/>\n  </g>\n</g>\n<g id=\"To_Basic\" @click=\"current='junior'\">\n  <g>\n    <path class=\"st1\" d=\"M925.2,774.2c-16-4.3-32.5,5.2-36.7,21.2s5.2,32.5,21.2,36.7c16,4.3,32.5-5.2,36.7-21.2\n      C950.7,794.9,941.2,778.4,925.2,774.2z M944.5,810.4c-4,14.9-19.4,23.8-34.3,19.8c-14.9-4-23.8-19.4-19.8-34.3\n      c4-14.9,19.4-23.8,34.3-19.8C939.6,780.1,948.5,795.4,944.5,810.4z\"/>\n    <g>\n      <defs>\n        <circle id=\"SVGID_32_\" cx=\"917.5\" cy=\"803.1\" r=\"28\"/>\n      </defs>\n      <clipPath id=\"SVGID_33_\">\n        <use xlink:href=\"#SVGID_32_\"  style=\"overflow:visible;\"/>\n      </clipPath>\n      <g class=\"st27\">\n\n          <image style=\"overflow:visible;\" width=\"884\" height=\"873\" xlink:href=\"colors-ring.png\" transform=\"matrix(6.815579e-002 0 0 6.815579e-002 887.3278 773.3801)\">\n        </image>\n      </g>\n    </g>\n  </g>\n</g>\n<g id=\"Temp_Color_01\"  @click=\"value = colorpad[0]\">\n  <g>\n    <path class=\"st1\" d=\"M226.7,188.4c-15-7-32.9-0.5-39.9,14.5c-7,15-0.5,32.9,14.5,39.9c15,7,32.9,0.5,39.9-14.5\n      C248.2,213.2,241.7,195.4,226.7,188.4z M239.4,227.4c-6.5,14-23.2,20.1-37.2,13.5c-14-6.5-20.1-23.2-13.5-37.2\n      c6.5-14,23.2-20.1,37.2-13.5C239.9,196.7,245.9,213.4,239.4,227.4z\"/>\n    <linearGradient id=\"SVGID_34_\" gradientUnits=\"userSpaceOnUse\" x1=\"214.0118\" y1=\"187.5365\" x2=\"214.0118\" y2=\"243.5498\">\n      <stop  offset=\"3.708734e-007\" :style=\"'stop-color:'+toHex(colorpad[0])\"/>\n      <stop  offset=\"1\" :style=\"'stop-color:'+toHex(colorpad[0])+';stop-opacity:0.5'\"/>\n    </linearGradient>\n    <circle class=\"st28\" cx=\"214\" cy=\"215.5\" r=\"28\"/>\n  </g>\n</g>\n<g id=\"Temp_Color_02\"  @click=\"value = colorpad[1]\">\n  <g>\n    <path class=\"st1\" d=\"M292.5,139.3c-13.6-9.5-32.3-6.2-41.8,7.4c-9.5,13.6-6.2,32.3,7.4,41.8c13.6,9.5,32.3,6.2,41.8-7.4\n      C309.4,167.5,306.1,148.8,292.5,139.3z M298.3,179.9c-8.9,12.7-26.3,15.7-39,6.9c-12.7-8.9-15.7-26.3-6.9-39\n      c8.9-12.7,26.3-15.7,39-6.9C304.1,149.8,307.1,167.3,298.3,179.9z\"/>\n    <linearGradient id=\"SVGID_35_\" gradientUnits=\"userSpaceOnUse\" x1=\"275.3235\" y1=\"135.8667\" x2=\"275.3235\" y2=\"191.8716\">\n      <stop  offset=\"0\" :style=\"'stop-color:'+toHex(colorpad[1])\"/>\n      <stop  offset=\"1\" :style=\"'stop-color:'+toHex(colorpad[1])+';stop-opacity:0.5'\"/>\n    </linearGradient>\n    <circle class=\"st29\" cx=\"275.3\" cy=\"163.9\" r=\"28\"/>\n  </g>\n</g>\n<g id=\"Temp_Color_03\"  @click=\"value= colorpad[2]\">\n  <g>\n    <path class=\"st1\" d=\"M365.9,102.4c-11.7-11.7-30.7-11.7-42.4,0c-11.7,11.7-11.7,30.7,0,42.4c11.7,11.7,30.7,11.7,42.4,0\n      C377.6,133.1,377.6,114.1,365.9,102.4z M364.5,143.4c-10.9,10.9-28.7,10.9-39.6,0c-10.9-10.9-10.9-28.7,0-39.6\n      c10.9-10.9,28.7-10.9,39.6,0C375.4,114.8,375.4,132.5,364.5,143.4z\"/>\n    <linearGradient id=\"SVGID_36_\" gradientUnits=\"userSpaceOnUse\" x1=\"344.6773\" y1=\"95.6269\" x2=\"344.6773\" y2=\"151.6267\">\n      <stop  offset=\"2.737399e-007\" :style=\"'stop-color:'+toHex(colorpad[2])\"/>\n      <stop  offset=\"1\" :style=\"'stop-color:'+toHex(colorpad[2])+';stop-opacity:0.5'\"/>\n    </linearGradient>\n    <circle class=\"st30\" cx=\"344.7\" cy=\"123.6\" r=\"28\"/>\n  </g>\n</g>\n<g id=\"Temp_Color_04\"  @click=\"value = colorpad[3]\">\n  <g>\n    <path class=\"st1\" d=\"M444.5,78.8c-9.5-13.6-28.2-16.9-41.8-7.4c-13.6,9.5-16.9,28.2-7.4,41.8c9.5,13.6,28.2,16.9,41.8,7.4\n      C450.7,111.1,454,92.4,444.5,78.8z M436,119c-12.7,8.9-30.1,5.8-39-6.9c-8.9-12.7-5.8-30.1,6.9-39c12.7-8.9,30.1-5.8,39,6.9\n      C451.8,92.6,448.7,110.1,436,119z\"/>\n    <linearGradient id=\"SVGID_37_\" gradientUnits=\"userSpaceOnUse\" x1=\"419.9649\" y1=\"68.0361\" x2=\"419.9649\" y2=\"124.041\">\n      <stop  offset=\"3.708734e-007\" :style=\"'stop-color:'+toHex(colorpad[3])\"/>\n      <stop  offset=\"1\" :style=\"'stop-color:'+toHex(colorpad[3])+';stop-opacity:0.5'\"/>\n    </linearGradient>\n    <circle class=\"st31\" cx=\"420\" cy=\"96\" r=\"28\"/>\n  </g>\n</g>\n<g id=\"Temp_Color_05\"  @click=\"value = colorpad[4]\">\n  <g>\n    <path class=\"st1\" d=\"M526.1,69.3c-7-15-24.9-21.5-39.9-14.5c-15,7-21.5,24.9-14.5,39.9c7,15,24.9,21.5,39.9,14.5\n      C526.6,102.1,533.1,84.3,526.1,69.3z M510.7,107.3c-14,6.5-30.7,0.5-37.2-13.5c-6.5-14-0.5-30.7,13.5-37.2\n      c14-6.5,30.7-0.5,37.2,13.5C530.8,84.1,524.7,100.8,510.7,107.3z\"/>\n    <linearGradient id=\"SVGID_38_\" gradientUnits=\"userSpaceOnUse\" x1=\"498.8995\" y1=\"53.9367\" x2=\"498.8995\" y2=\"109.9501\">\n      <stop  offset=\"2.737399e-007\" :style=\"'stop-color:'+toHex(colorpad[4])\"/>\n      <stop  offset=\"1\" :style=\"'stop-color:'+toHex(colorpad[4])+';stop-opacity:0.5'\"/>\n    </linearGradient>\n    <circle class=\"st32\" cx=\"498.9\" cy=\"81.9\" r=\"28\"/>\n  </g>\n</g>\n<g id=\"Temp_Color_06\"  @click=\"value = colorpad[5]\">\n  <g>\n    <path class=\"st1\" d=\"M608.1,74c-4.3-16-20.7-25.5-36.7-21.2c-16,4.3-25.5,20.7-21.2,36.7s20.7,25.5,36.7,21.2\n      C602.9,106.5,612.3,90,608.1,74z M586.3,108.8c-14.9,4-30.3-4.9-34.3-19.8c-4-14.9,4.9-30.3,19.8-34.3c14.9-4,30.3,4.9,34.3,19.8\n      C610.1,89.5,601.3,104.8,586.3,108.8z\"/>\n    <linearGradient id=\"SVGID_39_\" gradientUnits=\"userSpaceOnUse\" x1=\"579.0825\" y1=\"53.7619\" x2=\"579.0825\" y2=\"109.776\">\n      <stop  offset=\"3.708734e-007\" :style=\"'stop-color:'+toHex(colorpad[5])\"/>\n      <stop  offset=\"1\" :style=\"'stop-color:'+toHex(colorpad[5])+';stop-opacity:0.5'\"/>\n    </linearGradient>\n    <circle class=\"st33\" cx=\"579.1\" cy=\"81.8\" r=\"28\"/>\n  </g>\n</g>\n<style type=\"text/css\">\n  #regular .st4_1{fill:url(#SVGID_1_1);}\n  #regular .st5_1{fill:url(#SVGID_2_1);}\n  #regular .st0{fill:#333333;}\n  #regular .st1{fill:#F5D96C;}\n  #regular .st2{clip-path:url(#SVGID_2_);}\n  #regular .st3{fill:url(#SVGID_5_);}\n  #regular .st4{fill:none;stroke:url(#SVGID_6_);stroke-miterlimit:10;}\n  #regular .st5{fill:url(#SVGID_7_);}\n  #regular .st6{fill:url(#SVGID_8_);}\n  #regular .st7{fill:url(#SVGID_9_);}\n  #regular .st8{fill:url(#SVGID_10_);}\n  #regular .st9{fill:url(#SVGID_11_);}\n  #regular .st10{fill:url(#SVGID_12_);}\n  #regular .st11{fill:url(#SVGID_13_);}\n  #regular .st12{fill:url(#SVGID_14_);}\n  #regular .st13{fill:url(#SVGID_15_);}\n  #regular .st14{fill:url(#SVGID_16_);}\n  #regular .st15{fill:url(#SVGID_17_);}\n  #regular .st16{fill:url(#SVGID_18_);}\n  #regular .st17{fill:url(#SVGID_19_);}\n  #regular .st18{clip-path:url(#SVGID_21_);}\n  #regular .st19{fill:url(#SVGID_22_);}\n  #regular .st20{clip-path:url(#SVGID_24_);}\n  #regular .st21{fill:url(#SVGID_25_);}\n  #regular .st22{clip-path:url(#SVGID_27_);}\n  #regular .st23{fill:url(#SVGID_28_);}\n  #regular .st24{fill:url(#SVGID_29_);}\n  #regular .st25{fill:url(#SVGID_30_);}\n  #regular .st26{fill:url(#SVGID_31_);}\n  #regular .st27{clip-path:url(#SVGID_33_);}\n  #regular .st28{opacity:0.5;fill:url(#SVGID_34_);}\n  #regular .st29{opacity:0.5;fill:url(#SVGID_35_);}\n  #regular .st30{opacity:0.5;fill:url(#SVGID_36_);}\n  #regular .st31{opacity:0.5;fill:url(#SVGID_37_);}\n  #regular .st32{opacity:0.5;fill:url(#SVGID_38_);}\n  #regular .st33{opacity:0.5;fill:url(#SVGID_39_);}\n</style>";

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(126)
	module.exports = __webpack_require__(128)

	if (module.exports.__esModule) module.exports = module.exports.default
	;(typeof module.exports === "function" ? module.exports.options : module.exports).template = __webpack_require__(135)
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/bradpitt/Documents/front/carFitting/src/interact/remolder/materials/specular.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
	  }
	})()}

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(127);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(66)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-7f386c49&file=specular.vue!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./specular.vue", function() {
				var newContent = require("!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/vue-loader/lib/style-rewriter.js?id=_v-7f386c49&file=specular.vue!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./specular.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(63)();
	// imports


	// module
	exports.push([module.id, ".specular{\n  left: 500px;\n}", ""]);

	// exports


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// <template>
	// <svg xmlns="http://www.w3.org/2000/svg"
	//   viewBox="0 0 1080 1080" class="v-materials specular" @click.stop="afterClick($event)" id="spe" v-el:svg>
	//   <component is="color" v-if="current == 'junior'" :value.sync="value" :BRangle.sync="BRangle" :BLangle.sync="BLangle" :current.sync="current" :cancel.sync='cancel'></component>
	//   <component is="proColor" v-if="current == 'pro'" :current.sync="current" :BRangle.sync="BRangle" :BLangle.sync="BLangle"  :deg="deg" :value.sync="value" ></component>
	// </svg>
	// </template>

	// <style>
	// .specular{
	//   left: 500px;
	// }
	// </style>

	// <script>

	var repaint = __webpack_require__(116);
	var store = __webpack_require__(13);
	var parts = __webpack_require__(27);
	module.exports = {
	  data: function data() {
	    return {
	      store: store,
	      color: { h: 0, s: '100%', l: '50%' },
	      BLangle: 0,
	      BRangle: 0,
	      current: 'junior',
	      deg: '0',
	      colorpad: [{ h: 0, s: '100%', l: '50%' }, { h: 0, s: '100%', l: '50%' }, { h: 0, s: '100%', l: '50%' }, { h: 0, s: '100%', l: '50%' }, { h: 0, s: '100%', l: '50%' }, { h: 0, s: '100%', l: '50%' }],
	      material: "normal",
	      materials: []
	    };
	  },
	  props: ['value'],
	  components: {
	    color: __webpack_require__(129),
	    proColor: __webpack_require__(132)
	  },
	  watch: {
	    current: function current() {
	      repaint();
	    }
	  },
	  methods: {
	    afterClick: function afterClick(e) {
	      var width = 500;
	      var height = 360;
	      var radius = Math.pow(Math.pow(e.offsetX - width / 2, 2) + Math.pow(e.offsetY - height / 2, 2), 1 / 2);
	      if (radius < 0.25 * width) {
	        this.deg = e.offsetX > width / 2 ? Math.asin((height / 2 - e.offsetY) / radius) / Math.PI * 180 : 180 - Math.asin((height / 2 - e.offsetY) / radius) / Math.PI * 180;
	        this.deg = this.deg >= 0 ? this.deg : this.deg + 360;
	      }
	      if (radius > 0.3 * width && radius < 0.3 * width + 15) {
	        var angle = e.offsetX > width / 2 ? Math.asin((height / 2 - e.offsetY) / radius) / Math.PI * 180 : 180 - Math.asin((height / 2 - e.offsetY) / radius) / Math.PI * 180;
	        if (angle > -15 && angle < 75) {
	          this.BRangle = 10 - Math.round((angle + 10) / 8) * 8;
	        }
	        angle = angle >= 0 ? angle : angle + 360;
	        if (angle > 145 && angle < 235) {
	          this.BLangle = 30 - Math.round((angle - 150) / 8) * 8;
	        }
	      }
	    }
	  }
	};
	// </script>

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(130)

	if (module.exports.__esModule) module.exports = module.exports.default
	;(typeof module.exports === "function" ? module.exports.options : module.exports).template = __webpack_require__(131)
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/bradpitt/Documents/front/carFitting/src/interact/remolder/materials/spec_color.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
	  }
	})()}

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// <template>
	// <g id="Scale_B">
	//   <path class="st2" d="M457.8,768.8c-0.6-0.2-1.3-0.5-1.9-0.7c-2.5,6.9-5,13.8-7.5,20.7c121.4,44.7,257.3-4.8,321.6-117
	//     c-6.4-3.7-12.7-7.3-19.1-11c-0.3,0.6-0.7,1.2-1,1.7c5.8,3.3,11.5,6.7,17.3,10c-15.4,26.5-34,48.7-57.4,68.5
	//     c-4.3-5.1-8.6-10.2-12.9-15.3c-0.5,0.4-1,0.9-1.5,1.3c4.3,5.1,8.6,10.2,12.9,15.3c-23.6,19.6-48.6,34.1-77.4,44.7
	//     c-2.3-6.3-4.6-12.5-6.8-18.8c-0.6,0.2-1.3,0.5-1.9,0.7c2.3,6.3,4.6,12.5,6.8,18.8c-28.8,10.4-57.4,15.4-88,15.5c0-6.7,0-13.3,0-20
	//     c-0.7,0-1.3,0-2,0c0,6.7,0,13.3,0,20c-30.6-0.1-59.2-5.1-88-15.5C453.3,781.3,455.5,775.1,457.8,768.8z"/>
	//   <path class="st2" d="M384.6,726.9c-4.3,5.1-8.6,10.2-12.9,15.3c-0.4,0.5-0.9,1-1.3,1.5C213.3,612.9,257.2,361,449.4,291.1
	//     c192.1-69.9,387.7,94.8,351.4,296c-7.2-1.3-14.4-2.5-21.7-3.8c0.1-0.7,0.2-1.3,0.3-2c6.6,1.2,13.1,2.3,19.7,3.5
	//     c5.2-30.2,5.2-59.2,0-89.4c-6.6,1.2-13.1,2.3-19.7,3.5c-0.1-0.7-0.2-1.3-0.3-2c6.6-1.2,13.1-2.3,19.7-3.5
	//     c-5.4-30.2-15.3-57.4-30.6-84c-5.8,3.3-11.5,6.7-17.3,10c-0.3-0.6-0.7-1.2-1-1.7c5.8-3.3,11.5-6.7,17.3-10
	//     c-15.4-26.5-34-48.7-57.4-68.5c-4.3,5.1-8.6,10.2-12.9,15.3c-0.5-0.4-1-0.9-1.5-1.3c4.3-5.1,8.6-10.2,12.9-15.3
	//     c-23.6-19.6-48.6-34.1-77.4-44.7c-2.3,6.3-4.6,12.5-6.8,18.8c-0.6-0.2-1.3-0.5-1.9-0.7c2.3-6.3,4.6-12.5,6.8-18.8
	//     c-28.8-10.4-57.4-15.4-88-15.5c0,6.7,0,13.3,0,20c-0.7,0-1.3,0-2,0c0-6.7,0-13.3,0-20c-30.6,0.1-59.2,5.1-88,15.5
	//     c2.3,6.3,4.6,12.5,6.8,18.8c-0.6,0.2-1.3,0.5-1.9,0.7c-2.3-6.3-4.6-12.5-6.8-18.8c-28.8,10.6-53.8,25.1-77.4,44.7
	//     c4.3,5.1,8.6,10.2,12.9,15.3c-0.5,0.4-1,0.9-1.5,1.3c-4.3-5.1-8.6-10.2-12.9-15.3c-23.4,19.8-42,42-57.4,68.5
	//     c5.8,3.3,11.5,6.7,17.3,10c-0.3,0.6-0.7,1.2-1,1.7c-5.8-3.3-11.5-6.7-17.3-10c-15.2,26.6-25.1,53.8-30.6,84
	//     c6.6,1.2,13.1,2.3,19.7,3.5c-0.1,0.7-0.2,1.3-0.3,2c-6.6-1.2-13.1-2.3-19.7-3.5c-5.2,30.2-5.2,59.2,0,89.4
	//     c6.6-1.2,13.1-2.3,19.7-3.5c0.1,0.7,0.2,1.3,0.3,2c-6.6,1.2-13.1,2.3-19.7,3.5c5.4,30.2,15.3,57.4,30.6,84
	//     c5.8-3.3,11.5-6.7,17.3-10c0.3,0.6,0.7,1.2,1,1.7c-5.8,3.3-11.5,6.7-17.3,10c15.4,26.5,34,48.7,57.4,68.5
	//     c4.3-5.1,8.6-10.2,12.9-15.3C383.5,726,384,726.5,384.6,726.9z"/>
	//   <path class="st2" d="M692.2,484.7c-30.6-84.1-123.6-127.4-207.6-96.8c-84.1,30.6-127.4,123.6-96.8,207.6
	//     c30.6,84.1,123.6,127.4,207.6,96.8C679.5,661.7,722.8,568.8,692.2,484.7z M594.7,690.5c-83,30.2-174.9-12.6-205.1-95.6
	//     c-30.2-83,12.6-174.9,95.6-205.1c83-30.2,174.9,12.6,205.1,95.6C720.6,568.4,677.7,660.2,594.7,690.5z"/>
	// </g>
	// <g id="Scale_BL2">
	//   <path class="st3_1" :fill="color" d="M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4
	//     C82,745.5,39.5,504.3,149.5,314.7z"/>
	// </g>
	// <g id="Scale_BL3">
	//   <linearGradient id="SVGID_1_1" gradientUnits="userSpaceOnUse" x1="214.4087" y1="932.3943" x2="44.3172" y2="297.604">
	//     <stop  offset="0" style="stop-color:#FFFFFF"/>
	//     <stop  offset="0.5" style="stop-color:#7A7A7A;stop-opacity:0"/>
	//     <stop  offset="1" style="stop-color:#000000"/>
	//   </linearGradient>
	//   <path class="st4_1" d=M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4
	//     C82,745.5,39.5,504.3,149.5,314.7z"/>
	// </g>
	// <g id="Scale_BL">
	//   <path class="st2"  d="M251.5,885.5C83.3,745,40.8,503.8,150.8,314.2c-12.1-7-24.2-14-36.4-21c-0.3,0.6-0.7,1.2-1,1.7
	//     c11.5,6.7,23.1,13.3,34.6,20c-10.2,17.7-19.1,35.9-26.8,54.9c-6.2-2.5-12.4-5-18.5-7.5c-0.3,0.6-0.5,1.2-0.7,1.9
	//     c6.2,2.5,12.4,5,18.5,7.5c-7.6,19-13.9,38.2-18.9,58.1c-6.5-1.6-12.9-3.2-19.4-4.8c-0.2,0.6-0.3,1.3-0.5,1.9
	//     c6.5,1.6,12.9,3.2,19.4,4.8c-4.9,19.9-8.4,39.8-10.6,60.1c-6.6-0.7-13.3-1.4-19.9-2.1c-0.1,0.7-0.1,1.3-0.2,2
	//     c6.6,0.7,13.3,1.4,19.9,2.1c-2.1,20.3-2.8,40.6-2.1,61c-6.7,0.2-13.3,0.5-20,0.7c0,0.7,0,1.3,0.1,2c6.7-0.2,13.3-0.5,20-0.7
	//     c0.8,20.4,2.9,40.6,6.4,60.7c-13.1,2.3-26.3,4.6-39.4,6.9c0.1,0.7,0.2,1.3,0.3,2c13.1-2.3,26.3-4.6,39.4-6.9
	//     c3.6,20.1,8.5,39.8,14.8,59.3c-6.3,2.1-12.7,4.1-19,6.2c0.2,0.6,0.4,1.3,0.6,1.9c6.3-2.1,12.7-4.1,19-6.2
	//     c6.4,19.4,14,38.2,22.9,56.6c-6,2.9-12,5.8-18,8.8c0.3,0.6,0.6,1.2,0.9,1.8c6-2.9,12-5.8,18-8.8c9,18.4,19.1,35.9,30.5,52.9
	//     c-5.5,3.7-11.1,7.5-16.6,11.2c0.4,0.6,0.7,1.1,1.1,1.7c5.5-3.7,11.1-7.5,16.6-11.2c11.5,16.9,23.9,32.9,37.6,48.1
	//     c-5,4.5-9.9,8.9-14.9,13.4c0.4,0.5,0.9,1,1.3,1.5c5-4.5,9.9-8.9,14.9-13.4c13.7,15.2,28.3,29.2,43.9,42.4
	//     c-8.6,10.2-17.1,20.4-25.7,30.6c0.5,0.4,1,0.9,1.5,1.3C233.5,906.9,242.5,896.2,251.5,885.5z"/>
	// </g>
	// <g id="Scale_BR2" v-show="!cancel">
	//   <path class="st3_1" :fill="color" d="M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1
	//     C900.2,190.4,1022.6,402.5,984.1,618.3z"/>
	// </g>
	// <g id="Scale_BR3" v-show="!cancel">
	//   <linearGradient id="SVGID_2_1" gradientUnits="userSpaceOnUse" x1="968.8124" y1="649.5213" x2="803.8889" y2="34.0186">
	//     <stop  offset="0" style="stop-color:#808080;stop-opacity:1"/>
	//     <stop  offset="1" style="stop-color:#808080;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st5_1" d="M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1
	//     C900.2,190.4,1022.6,402.5,984.1,618.3z"/>
	// </g>

	// <g id="Scale_BR" v-show="!cancel">
	//   <path class="st2" d="M983,619.2c38.5-215.7-83.9-427.8-290-502.3c4.8-13.2,9.6-26.3,14.4-39.5c0.6,0.2,1.3,0.5,1.9,0.7
	//     c-4.6,12.5-9.1,25.1-13.7,37.6c19.2,7,37.7,15.3,55.8,24.8c3.1-5.9,6.3-11.8,9.4-17.7c0.6,0.3,1.2,0.6,1.8,0.9
	//     c-3.1,5.9-6.3,11.8-9.4,17.7c18,9.6,35.2,20.4,51.8,32.4c3.9-5.4,7.8-10.8,11.8-16.2c0.5,0.4,1.1,0.8,1.6,1.2
	//     c-3.9,5.4-7.8,10.8-11.8,16.2c16.5,12.1,32,25.1,46.8,39.3c4.6-4.8,9.3-9.6,13.9-14.4c0.5,0.5,1,0.9,1.4,1.4
	//     c-4.6,4.8-9.3,9.6-13.9,14.4c14.7,14.2,28.2,29.3,40.9,45.4c5.3-4.1,10.5-8.2,15.8-12.3c0.4,0.5,0.8,1,1.2,1.6
	//     c-5.3,4.1-10.5,8.2-15.8,12.3c12.6,16.1,23.9,32.9,34.1,50.6c11.5-6.7,23.1-13.3,34.6-20c0.3,0.6,0.7,1.2,1,1.7
	//     c-11.5,6.7-23.1,13.3-34.6,20c10.2,17.7,19.1,35.9,26.8,54.9c6.2-2.5,12.4-5,18.5-7.5c0.3,0.6,0.5,1.2,0.7,1.9
	//     c-6.2,2.5-12.4,5-18.5,7.5c7.6,19,13.9,38.2,18.9,58.1c6.5-1.6,12.9-3.2,19.4-4.8c0.2,0.6,0.3,1.3,0.5,1.9
	//     c-6.5,1.6-12.9,3.2-19.4,4.8c4.9,19.9,8.4,39.8,10.6,60.1c6.6-0.7,13.3-1.4,19.9-2.1c0.1,0.7,0.1,1.3,0.2,2
	//     c-6.6,0.7-13.3,1.4-19.9,2.1c2.1,20.3,2.8,40.6,2.1,61c6.7,0.2,13.3,0.5,20,0.7c0,0.7,0,1.3-0.1,2c-6.7-0.2-13.3-0.5-20-0.7
	//     c-0.8,20.4-2.9,40.6-6.4,60.7c13.1,2.3,26.3,4.6,39.4,6.9c-0.1,0.7-0.2,1.3-0.3,2C1010.6,624.1,996.8,621.7,983,619.2z"/>
	// </g>
	// <g id="Color_B01" class="hover" @click="value={h:0,s:'90%',l:'40%'},index=0">
	//   <linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="810.9808" y1="540.1049" x2="940.1153" y2="540.1049">
	//     <stop  offset="9.271834e-008" style="stop-color:#990000"/>
	//     <stop  offset="0.2" style="stop-color:#990000"/>
	//     <stop  offset="1" style="stop-color:#990000;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st3" d="M811,586.9c41,7.2,82.1,14.5,123.1,21.7c8-46.3,8-90.7,0-136.9c-41,7.2-82.1,14.5-123.1,21.7
	//     C816.4,525,816.4,555.3,811,586.9z"/>
	// </g>
	// <g id="Color_B02" @click="value={h:0.0996,s:'70%',l:'50%'},index=1">
	//   <linearGradient id="SVGID_2_" gradientUnits="userSpaceOnUse" x1="794.638" y1="447.4195" x2="915.9847" y2="403.2529">
	//     <stop  offset="0" style="stop-color:#CC7A00"/>
	//     <stop  offset="0.2" style="stop-color:#CC7A00"/>
	//     <stop  offset="1" style="stop-color:#CC7A00;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st4" d="M810.6,491.4c41-7.2,82.1-14.5,123.1-21.7c-8.3-46.3-23.4-87.9-46.8-128.7c-36.1,20.8-72.2,41.7-108.3,62.5
	//     C794.6,431.3,804.9,459.8,810.6,491.4z"/>
	// </g>
	// <g id="Color_B03" @click="value={h:0.16666666,s:'80%',l:'50%'},index=2">
	//   <linearGradient id="SVGID_3_" gradientUnits="userSpaceOnUse" x1="747.5805" y1="365.9128" x2="846.5033" y2="282.9067">
	//     <stop  offset="0" style="stop-color:#cccc00"/>
	//     <stop  offset="0.2" style="stop-color:#cccc00"/>
	//     <stop  offset="1" style="stop-color:#cccc00;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st5" d="M777.6,401.7c36.1-20.8,72.2-41.7,108.3-62.5c-23.6-40.6-52.1-74.6-88-104.9c-26.8,31.9-53.6,63.8-80.3,95.8
	//     C742,350.8,761.5,374,777.6,401.7z"/>
	// </g>
	// <g id="Color_B04" @click="value={h:0.23311,s:'50%',l:'60%'},index=3">
	//   <linearGradient id="SVGID_4_" gradientUnits="userSpaceOnUse" x1="675.4836" y1="305.4167" x2="740.0508" y2="193.583">
	//     <stop  offset="0" style="stop-color:#5c9900"/>
	//     <stop  offset="0.2" style="stop-color:#5c9900"/>
	//     <stop  offset="1" style="stop-color:#5c9900;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st6" d="M716,328.8c26.8-31.9,53.6-63.8,80.3-95.8c-36.1-30.1-74.5-52.3-118.6-68.5c-14.3,39.2-28.5,78.3-42.8,117.5
	//     C665.1,293.1,691.3,308.3,716,328.8z"/>
	// </g>
	// <g id="Color_B05" @click="value={h:0.33333333333333,s:'100%',l:'30%'},index=4">
	//   <linearGradient id="SVGID_5_" gradientUnits="userSpaceOnUse" x1="587.0449" y1="273.228" x2="609.4689" y2="146.0551">
	//     <stop  offset="0" style="stop-color:#009900"/>
	//     <stop  offset="0.2" style="stop-color:#009900"/>
	//     <stop  offset="1" style="stop-color:#009900;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st7" d="M633.1,281.3c14.3-39.2,28.5-78.3,42.8-117.5c-44.2-16-87.9-23.7-134.9-23.8c0,41.7,0,83.3,0,125
	//     C573.1,265.2,602.9,270.5,633.1,281.3z"/>
	// </g>
	// <g id="Color_B06" @click="value={h : 0.430555556,s:'70%',l:'50%'},index=5">
	//   <linearGradient id="SVGID_6_" gradientUnits="userSpaceOnUse" x1="492.9301" y1="273.228" x2="470.5061" y2="146.0549">
	//     <stop  offset="0" style="stop-color:#00cc7a"/>
	//     <stop  offset="0.2" style="stop-color:#00cc7a"/>
	//     <stop  offset="1" style="stop-color:#00cc7a;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st8" d="M539,265.1c0-41.7,0-83.3,0-125c-47,0.1-90.7,7.8-134.9,23.8c14.3,39.2,28.5,78.3,42.8,117.5
	//     C477.1,270.5,506.9,265.2,539,265.1z"/>
	// </g>
	// <g id="Color_B07" @click="value={h :0.5,s:'50%',l:'50%'},index=6">
	//   <linearGradient id="SVGID_7_" gradientUnits="userSpaceOnUse" x1="404.4905" y1="305.4172" x2="339.9231" y2="193.5832">
	//     <stop  offset="9.271834e-008" style="stop-color:#00cccc"/>
	//     <stop  offset="0.2" style="stop-color:#00cccc"/>
	//     <stop  offset="1" style="stop-color:#00FFFF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st9" d="M445,282c-14.3-39.2-28.5-78.3-42.8-117.5c-44.1,16.2-82.5,38.4-118.6,68.5c26.8,31.9,53.6,63.8,80.3,95.8
	//     C388.6,308.3,414.9,293.1,445,282z"/>
	// </g>
	// <g id="Color_B08" @click="value={h : 0.5669,s:'50%',l:'60%'},index=7">
	//   <linearGradient id="SVGID_8_" gradientUnits="userSpaceOnUse" x1="332.3944" y1="365.9128" x2="233.4712" y2="282.9063">
	//     <stop  offset="1.854367e-007" style="stop-color:#007acc"/>
	//     <stop  offset="0.2" style="stop-color:#007acc"/>
	//     <stop  offset="1" style="stop-color:#007acc;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st10" d="M362.5,330.1c-26.8-31.9-53.6-63.8-80.3-95.8c-35.9,30.3-64.4,64.3-88,104.9c36.1,20.8,72.2,41.7,108.3,62.5
	//     C318.5,374,338,350.8,362.5,330.1z"/>
	// </g>
	// <g id="Color_B09" @click="value={h : 0.66666666666,s:'60%',l:'50%'},index=8">
	//   <linearGradient id="SVGID_9_" gradientUnits="userSpaceOnUse" x1="285.3359" y1="447.4191" x2="163.9899" y2="403.2528">
	//     <stop  offset="2.781550e-007" style="stop-color:#000099"/>
	//     <stop  offset="0.2" style="stop-color:#000099"/>
	//     <stop  offset="1" style="stop-color:#000099;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st11" d="M301.3,403.5c-36.1-20.8-72.2-41.7-108.3-62.5c-23.4,40.8-38.6,82.4-46.8,128.7c41,7.2,82.1,14.5,123.1,21.7
	//     C275,459.8,285.4,431.3,301.3,403.5z"/>
	// </g>
	// <g id="Color_B10" @click="value={h : 0.7663,s:'50%',l:'40%'},index=9">
	//   <linearGradient id="SVGID_10_" gradientUnits="userSpaceOnUse" x1="268.993" y1="540.1049" x2="139.8585" y2="540.1049">
	//     <stop  offset="2.781550e-007" style="stop-color:#7a00cc"/>
	//     <stop  offset="0.2" style="stop-color:#7a00cc"/>
	//     <stop  offset="1" style="stop-color:#7a00cc;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st12" d="M269,493.3c-41-7.2-82.1-14.5-123.1-21.7c-8,46.3-8,90.7,0,136.9c41-7.2,82.1-14.5,123.1-21.7
	//     C263.5,555.3,263.5,525,269,493.3z"/>
	// </g>
	// <g id="Color_B11" @click="value={h:0.83333333333,s:'60%',l:'50%'},index=10">
	//   <linearGradient id="SVGID_11_" gradientUnits="userSpaceOnUse" x1="285.3358" y1="632.7901" x2="163.9899" y2="676.9564">
	//     <stop  offset="3.708734e-007" style="stop-color:#FF00FF"/>
	//     <stop  offset="0.2" style="stop-color:#FF00FF"/>
	//     <stop  offset="1" style="stop-color:#FF00FF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st13" d="M269.3,588.8c-41,7.2-82.1,14.5-123.1,21.7c8.3,46.3,23.4,87.9,46.8,128.7c36.1-20.8,72.2-41.7,108.3-62.5
	//     C285.4,648.9,275,620.4,269.3,588.8z"/>
	// </g>
	// <g id="Color_B12" @click="value={h:0.9,s:'50%',l:'80%'},index=11">
	//   <linearGradient id="SVGID_12_" gradientUnits="userSpaceOnUse" x1="332.3944" y1="714.2958" x2="233.4712" y2="797.3022">
	//     <stop  offset="3.708734e-007" style="stop-color:#ff99d6"/>
	//     <stop  offset="0.2" style="stop-color:#ff99d6"/>
	//     <stop  offset="1" style="stop-color:#ff99d6;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st14" d="M302.3,678.5c-36.1,20.8-72.2,41.7-108.3,62.5c23.6,40.6,52.1,74.6,88,104.9c26.8-31.9,53.6-63.8,80.3-95.8
	//     C338,729.4,318.5,706.2,302.3,678.5z"/>
	// </g>
	// <g id="Color_B13" @click="value={h:0.123,s:'62%',l:'70%'},index=12">
	//   <linearGradient id="SVGID_13_" gradientUnits="userSpaceOnUse" x1="492.9301" y1="806.9812" x2="470.5062" y2="934.1538">
	//     <stop  offset="2.737399e-007" style="stop-color:#d8b656"/>
	//     <stop  offset="0.2" style="stop-color:#d8b656"/>
	//     <stop  offset="1" style="stop-color:#d8b656;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st15" d="M446.9,798.9c-14.3,39.2-28.5,78.3-42.8,117.5c44.2,16,87.9,23.7,134.9,23.8c0-41.7,0-83.3,0-125
	//     C506.9,815,477.1,809.7,446.9,798.9z"/>
	// </g>
	// <g id="Color_B14" @click="value={h:0,s:'0%',l:'70%'},index=13">
	//   <linearGradient id="SVGID_14_" gradientUnits="userSpaceOnUse" x1="587.0449" y1="806.9812" x2="609.4688" y2="934.1536">
	//     <stop  offset="3.664582e-007" style="stop-color:#999999"/>
	//     <stop  offset="0.2" style="stop-color:#999999"/>
	//     <stop  offset="1" style="stop-color:#999999;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st16" d="M541,815.1c0,41.7,0,83.3,0,125c47-0.1,90.7-7.8,134.9-23.8c-14.3-39.2-28.5-78.3-42.8-117.5
	//     C602.9,809.7,573.1,815,541,815.1z"/>
	// </g>
	// <g id="Color_B15"  @click="value={h:0,s:'0%',l:'30%'},index=14">
	//   <linearGradient id="SVGID_15_" gradientUnits="userSpaceOnUse" x1="675.4838" y1="774.7922" x2="740.0508" y2="886.6255">
	//     <stop  offset="4.591765e-007" style="stop-color:#4d4d4d"/>
	//     <stop  offset="0.2" style="stop-color:#4d4d4d"/>
	//     <stop  offset="1" style="stop-color:#4d4d4d;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st17" d="M635,798.2c14.3,39.2,28.5,78.3,42.8,117.5c44.1-16.2,82.5-38.4,118.6-68.5c-26.8-31.9-53.6-63.8-80.3-95.8
	//     C691.3,771.9,665.1,787.1,635,798.2z"/>
	// </g>
	// <g id="Color_B16" @click="value={h:0,s:'0%',l:'100%'},index=15">
	//   <linearGradient id="SVGID_16_" gradientUnits="userSpaceOnUse" x1="747.5805" y1="714.2958" x2="846.5033" y2="797.3018">
	//     <stop  offset="3.664582e-007" style="stop-color:#e5e5e5"/>
	//     <stop  offset="0.2" style="stop-color:#e5e5e5"/>
	//     <stop  offset="1" style="stop-color:#e5e5e5;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st18" d="M717.5,750.1c26.8,31.9,53.6,63.8,80.3,95.8c35.9-30.3,64.4-64.3,88-104.9c-36.1-20.8-72.2-41.7-108.3-62.5
	//     C761.5,706.2,742,729.4,717.5,750.1z"/>
	// </g>
	// <g id="Pin_BL" :transform="'rotate(' + BLangle + ' 540 540)'">
	//   <g>
	//     <linearGradient id="SVGID_171_" gradientUnits="userSpaceOnUse" x1="57.5965" y1="530.0045" x2="20.0443" y2="530.0045">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_171_);" d="M20,532.4c0-1.8,0.1-3.6,0.1-5.4c9.6,0.6,19.3,1.2,28.9,1.9c2.8,1.4,5.7,2.8,8.5,4.1    C45.1,532.8,32.6,532.6,20,532.4z"/>
	//     <linearGradient id="SVGID_181_" gradientUnits="userSpaceOnUse" x1="77.9868" y1="540.1041" x2="19.9875" y2="540.1041">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_181_);" d="M20,543.8c0-2.5,0-4.9,0-7.4c19.3,0.3,38.7,0.6,58,0.9c0,1.9,0,3.7,0,5.6C58.7,543.2,39.3,543.5,20,543.8z"/>
	//     <linearGradient id="SVGID_191_" gradientUnits="userSpaceOnUse" x1="57.5965" y1="550.2053" x2="20.0443" y2="550.2053">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_191_);" d="M20.2,553.2c0-1.8-0.1-3.6-0.1-5.4c12.5-0.2,25-0.4,37.6-0.6c-2.8,1.4-5.7,2.8-8.5,4.1    C39.4,552,29.8,552.6,20.2,553.2z"/>
	//   </g>
	// </g>
	// <g id="Pin_BR" :transform="'rotate(' + BRangle + ' 540 540)'" v-show="!cancel">
	//   <g xmlns="http://www.w3.org/2000/svg">
	//     <linearGradient id="SVGID_101_" gradientUnits="userSpaceOnUse" x1="1022.4805" y1="550.2055" x2="1060.0327" y2="550.2055">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_101_)" d="M1059.9,553.2c0-1.8,0.1-3.6,0.1-5.4c-12.5-0.2-25-0.4-37.6-0.6c2.8,1.4,5.7,2.8,8.5,4.1    C1040.6,552,1050.3,552.6,1059.9,553.2z"/>
	//     <linearGradient id="SVGID_111_" gradientUnits="userSpaceOnUse" x1="1002.0901" y1="540.1044" x2="1060.0895" y2="540.1044">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_111_)" d="M1060.1,543.8c0-2.5,0-4.9,0-7.4c-19.3,0.3-38.7,0.6-58,0.9c0,1.9,0,3.7,0,5.6    C1021.4,543.2,1040.7,543.5,1060.1,543.8z"/>
	//     <linearGradient id="SVGID_121_" gradientUnits="userSpaceOnUse" x1="1022.4805" y1="530.0047" x2="1060.0327" y2="530.0047">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_121_)" d="M1060,532.4c0-1.8-0.1-3.6-0.1-5.4c-9.6,0.6-19.3,1.2-28.9,1.9c-2.8,1.4-5.7,2.8-8.5,4.1    C1035,532.8,1047.5,532.6,1060,532.4z"/>
	//   </g>
	// </g>
	// <g id="Pin_B" :transform="'rotate(' + angles[index] + ' 540 540)'">
	//   <g>
	//     <linearGradient id="SVGID_231_" gradientUnits="userSpaceOnUse" x1="875.485" y1="539.9995" x2="516.9875" y2="539.9995">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_231_)" d="M561.2,531.1c-9.7-23.2-44.2-16.3-44.2,8.9s34.5,32.1,44.2,8.9c0.2-0.4,0.3-0.8,0.5-1.2    c104.6-1.6,209.2-3.3,313.8-4.9c0-1.9,0-3.7,0-5.6c-104.6-1.6-209.2-3.3-313.8-4.9C561.5,531.9,561.4,531.5,561.2,531.1z"/>
	//     <linearGradient id="SVGID_241_" gradientUnits="userSpaceOnUse" x1="855.0947" y1="540" x2="508.9872" y2="540">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_241_)" d="M846.6,528.8c2.8,1.4,5.7,2.8,8.5,4.1c-96.9-1.5-193.8-3-290.7-4.5C552,502.4,513,511.2,513,540    c0,28.8,39,37.6,51.4,11.6c96.9-1.5,193.8-3,290.7-4.5c-2.8,1.4-5.7,2.8-8.5,4.1c-101.5,6.6-203,13.1-304.6,19.7    c-44,2.8-44-64.7,0-61.9C643.5,515.6,745,522.2,846.6,528.8z"/>
	//   </g>
	// </g>
	// <g id="Monitor_B">
	//   <radialGradient id="SVGID_21_" cx="539.9872" cy="540.1043" r="150.0408" gradientUnits="userSpaceOnUse">
	//     <stop  offset="0" style="stop-color:#000000"/>
	//     <stop  offset="1" style="stop-color:#000000;stop-opacity:0.5"/>
	//   </radialGradient>
	//   <circle class="st23" cx="540" cy="540.1" r="150"/>
	//   <linearGradient id="SVGID_22_" gradientUnits="userSpaceOnUse" x1="539.987" y1="392.0641" x2="539.987" y2="688.1447">
	//     <stop  class="pad" offset="9.271834e-008" :style="'stop-color:' + color "/>
	//     <stop  offset="1" :style="'stop-color:' + color"/>
	//   </linearGradient>
	//   <circle class="st24" cx="540" cy="540.1" r="148" @click="colorSet='diffuse'"/>
	//   <linearGradient id="SVGID_23_" gradientUnits="userSpaceOnUse" x1="539.9875" y1="683.535" x2="539.9875" y2="555.6201">
	//     <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//     <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st25" d="M540,555.6c36.6,0,94.1,17.1,94.1,64c0,46.8-57.5,64-94.1,64c-36.6,0-94.1-17.1-94.1-64
	//     C445.9,572.7,503.4,555.6,540,555.6z" @click="colorSet='shadow'"/>
	//   <linearGradient id="SVGID_24_" gradientUnits="userSpaceOnUse" x1="539.9875" y1="396.6736" x2="539.9875" y2="524.5886">
	//     <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//     <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st26" d="M540,524.6c36.6,0,94.1-17.1,94.1-64c0-46.8-57.5-64-94.1-64c-36.6,0-94.1,17.1-94.1,64
	//     C445.9,507.5,503.4,524.6,540,524.6z" @click="colorSet='highlight'"/>
	//   <linearGradient id="SVGID_25_" gradientUnits="userSpaceOnUse" x1="539.9869" y1="400.9027" x2="539.9869" y2="450.9808">
	//     <stop  offset="0" style="stop-color:#FFFFFF;stop-opacity:0.6"/>
	//     <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st27" d="M540,451c10.1,0,19.6-1.3,29.2-5c7.9-3,19.6-9.3,19.6-20.1c0-10.7-11.7-17-19.6-20.1c-9.6-3.7-19-5-29.1-5
	//     c-10.1,0-19.6,1.3-29.2,5c-7.9,3-19.6,9.3-19.6,20.1c0,10.7,11.7,17,19.6,20.1C520.4,449.7,529.9,451,540,451z"/>
	//     <text xmlns="http://www.w3.org/2000/svg" transform="matrix(1 0 0 1 484.3381 482)">
	//       <tspan x="0" y="0" style="font-size:36px;font-family:'HYg1gj'" v-text="change.name"></tspan>
	//       <tspan x="-40" y="130" style="font-size:120px;font-family:'HYg1gj'" v-text="change.value"></tspan>
	//       <tspan x="-20" y="120" style="font-size:36px;font-family:'HYg1gj'" v-text="change.hover"></tspan>
	//       <tspan x="150" y="130" style="font-size:36px" v-text="change.name?'%':''"></tspan>

	//     </text>
	// </g>
	// <g id="Color_P">
	// </g>
	// <g id="To_Pro" @click="current = 'pro'" @mouseover="save=change,change={hover:'高级模式'}" @mouseout="change=save">
	//   <g>
	//     <path class="st2" d="M925.1,774.2c-16-4.3-32.5,5.2-36.7,21.2c-4.3,16,5.2,32.5,21.2,36.7c16,4.3,32.5-5.2,36.7-21.2
	//       C950.6,794.9,941.1,778.4,925.1,774.2z M944.4,810.4c-4,14.9-19.4,23.8-34.3,19.8c-14.9-4-23.8-19.4-19.8-34.3
	//       c4-14.9,19.4-23.8,34.3-19.8C939.6,780.1,948.4,795.4,944.4,810.4z"/>
	//     <g>
	//       <defs>
	//         <circle id="SVGID_44_" cx="917.4" cy="803.1" r="28"/>
	//       </defs>
	//       <clipPath id="SVGID_45_">
	//         <use xlink:href="#SVGID_44_"  style="overflow:visible;"/>
	//       </clipPath>
	//       <g class="st43">

	//           <image style="overflow:visible;" width="851" height="850" xlink:href="hue-ring.png" transform="matrix(5.837880e-002 5.837880e-002 -5.837880e-002 5.837880e-002 917.3402 753.4789)">
	//         </image>
	//       </g>
	//     </g>
	//   </g>
	// </g>
	// <style>
	// .v-colors .color path {
	//   stroke: #888;
	//   cursor: pointer;
	// }
	//   #spe .st4_1{fill:url(#SVGID_1_1);}
	//   #spe .st5_1{fill:url(#SVGID_2_1);}
	//   #spe .st0{display:none;}
	//   #spe .st1{display:inline;fill:#333333;}
	//   #spe .st2{fill:#F5D96C;}
	//   #spe .st3{fill:url(#SVGID_1_);}
	//   #spe .st4{fill:url(#SVGID_2_);}
	//   #spe .st5{fill:url(#SVGID_3_);}
	//   #spe .st6{fill:url(#SVGID_4_);}
	//   #spe .st7{fill:url(#SVGID_5_);}
	//   #spe .st8{fill:url(#SVGID_6_);}
	//   #spe .st9{fill:url(#SVGID_7_);}
	//   #spe .st10{fill:url(#SVGID_8_);}
	//   #spe .st11{fill:url(#SVGID_9_);}
	//   #spe .st12{fill:url(#SVGID_10_);}
	//   #spe .st13{fill:url(#SVGID_11_);}
	//   #spe .st14{fill:url(#SVGID_12_);}
	//   #spe .st15{fill:url(#SVGID_13_);}
	//   #spe .st16{fill:url(#SVGID_14_);}
	//   #spe .st17{fill:url(#SVGID_15_);}
	//   #spe .st18{fill:url(#SVGID_16_);}
	//   #spe .st19{fill:url(#SVGID_17_);}
	//   #spe .st20{fill:url(#SVGID_18_);}
	//   #spe .st21{fill:none;stroke:url(#SVGID_19_);stroke-miterlimit:10;}
	//   #spe .st22{fill:url(#SVGID_20_);}
	//   #spe .st23{fill:url(#SVGID_21_);}
	//   #spe .st24{fill:url(#SVGID_22_);}
	//   #spe .st25{fill:url(#SVGID_23_);}
	//   #spe .st26{fill:url(#SVGID_24_);}
	//   #spe .st27{fill:url(#SVGID_25_);}
	//   #spe .st28{fill:url(#SVGID_26_);}
	//   #spe .st29{fill:url(#SVGID_27_);}
	//   #spe .st30{fill:url(#SVGID_28_);}
	//   #spe .st31{fill:url(#SVGID_29_);}
	//   #spe .st32{fill:url(#SVGID_30_);}
	//   #spe .st33{fill:url(#SVGID_31_);}
	//   #spe .st34{clip-path:url(#SVGID_33_);}
	//   #spe .st35{fill:url(#SVGID_34_);}
	//   #spe .st36{clip-path:url(#SVGID_36_);}
	//   #spe .st37{fill:url(#SVGID_37_);}
	//   #spe .st38{clip-path:url(#SVGID_39_);}
	//   #spe .st39{fill:url(#SVGID_40_);}
	//   #spe .st40{fill:url(#SVGID_41_);}
	//   #spe .st41{fill:url(#SVGID_42_);}
	//   #spe .st42{fill:url(#SVGID_43_);}
	//   #spe .st43{clip-path:url(#SVGID_45_);}
	//   #spe .st44{opacity:0.5;fill:url(#SVGID_46_);}
	//   #spe .st45{opacity:0.5;fill:url(#SVGID_47_);}
	//   #spe .st46{opacity:0.5;fill:url(#SVGID_48_);}
	//   #spe .st47{opacity:0.5;fill:url(#SVGID_49_);}
	//   #spe .st48{opacity:0.5;fill:url(#SVGID_50_);}
	//   #spe .st49{opacity:0.5;fill:url(#SVGID_51_);}
	//   #spe .st00{
	//     fill: none;
	//     stroke: #F5D96C;
	//     stroke-width: 2;
	//     stroke-miterlimit: 10
	//   }
	//   .font{
	//     font-size: 36px;
	//     font-family: 'MicrosoftYaHei';
	//     fill:#F5D96C;
	//   }
	// </style>
	// </template>

	// <script>
	var THREE = __webpack_require__(26);

	module.exports = {
	  props: ['value', 'BRangle', 'BLangle', 'current', 'cancel'],
	  data: function data() {
	    return {
	      color: "",
	      angles: [0, 340, 320, 300, 280, 260, 240, 220, 200, 180, 160, 140, 100, 80, 60, 40],
	      index: 6,
	      colorSet: 'diffuse',
	      change: { name: "调色板" },
	      save: {}
	    };
	  },
	  computed: {
	    'color': function color() {
	      var h = this.value.h;
	      var s = this.value.s;
	      var l = this.value.l;
	      var color = new THREE.Color("hsl(" + h + "," + s + "," + l + ")");
	      return '#' + color.getHexString();
	    }
	  },
	  methods: {
	    toHex: function toHex(value) {
	      var h = value.h;
	      var s = value.s;
	      var l = value.l;
	      var color = new THREE.Color("hsl(" + h + "," + s + "," + l + ")");
	      return '#' + color.getHexString();
	    }
	  },
	  watch: {
	    value: function value(_value) {
	      var h = _value.h;
	      var s = _value.s;
	      var l = _value.l;
	      this.deg = h * 360;
	      this.BRangle = 10 - Number(s.substring(0, s.length - 1)) * 8 / 10;
	      this.BLangle = 30 - Number(l.substring(0, l.length - 1)) * 8 / 10;
	    },
	    index: function index(value) {
	      if (value == 12 || value == 13 || value == 14 || value == 15) {
	        this.cancel = true;
	      } else {
	        this.cancel = false;
	      }
	    },
	    BRangle: function BRangle(value) {
	      if (!this.cancel) {
	        this.value = { h: this.value.h, s: (10 - value) * 10 / 8 + '%', l: this.value.l };
	        this.change = { name: '饱和度', value: (10 - value) * 10 / 8 };
	      }
	    },
	    BLangle: function BLangle(value) {
	      this.value = { h: this.value.h, s: this.value.s, l: (30 - value) * 10 / 8 + '%' };
	      this.change = { name: '明度', value: (30 - value) * 10 / 8 };
	    }
	  }
	};
	// </script>

/***/ },
/* 131 */
/***/ function(module, exports) {

	module.exports = "<g id=\"Scale_B\">\n  <path class=\"st2\" d=\"M457.8,768.8c-0.6-0.2-1.3-0.5-1.9-0.7c-2.5,6.9-5,13.8-7.5,20.7c121.4,44.7,257.3-4.8,321.6-117\n    c-6.4-3.7-12.7-7.3-19.1-11c-0.3,0.6-0.7,1.2-1,1.7c5.8,3.3,11.5,6.7,17.3,10c-15.4,26.5-34,48.7-57.4,68.5\n    c-4.3-5.1-8.6-10.2-12.9-15.3c-0.5,0.4-1,0.9-1.5,1.3c4.3,5.1,8.6,10.2,12.9,15.3c-23.6,19.6-48.6,34.1-77.4,44.7\n    c-2.3-6.3-4.6-12.5-6.8-18.8c-0.6,0.2-1.3,0.5-1.9,0.7c2.3,6.3,4.6,12.5,6.8,18.8c-28.8,10.4-57.4,15.4-88,15.5c0-6.7,0-13.3,0-20\n    c-0.7,0-1.3,0-2,0c0,6.7,0,13.3,0,20c-30.6-0.1-59.2-5.1-88-15.5C453.3,781.3,455.5,775.1,457.8,768.8z\"/>\n  <path class=\"st2\" d=\"M384.6,726.9c-4.3,5.1-8.6,10.2-12.9,15.3c-0.4,0.5-0.9,1-1.3,1.5C213.3,612.9,257.2,361,449.4,291.1\n    c192.1-69.9,387.7,94.8,351.4,296c-7.2-1.3-14.4-2.5-21.7-3.8c0.1-0.7,0.2-1.3,0.3-2c6.6,1.2,13.1,2.3,19.7,3.5\n    c5.2-30.2,5.2-59.2,0-89.4c-6.6,1.2-13.1,2.3-19.7,3.5c-0.1-0.7-0.2-1.3-0.3-2c6.6-1.2,13.1-2.3,19.7-3.5\n    c-5.4-30.2-15.3-57.4-30.6-84c-5.8,3.3-11.5,6.7-17.3,10c-0.3-0.6-0.7-1.2-1-1.7c5.8-3.3,11.5-6.7,17.3-10\n    c-15.4-26.5-34-48.7-57.4-68.5c-4.3,5.1-8.6,10.2-12.9,15.3c-0.5-0.4-1-0.9-1.5-1.3c4.3-5.1,8.6-10.2,12.9-15.3\n    c-23.6-19.6-48.6-34.1-77.4-44.7c-2.3,6.3-4.6,12.5-6.8,18.8c-0.6-0.2-1.3-0.5-1.9-0.7c2.3-6.3,4.6-12.5,6.8-18.8\n    c-28.8-10.4-57.4-15.4-88-15.5c0,6.7,0,13.3,0,20c-0.7,0-1.3,0-2,0c0-6.7,0-13.3,0-20c-30.6,0.1-59.2,5.1-88,15.5\n    c2.3,6.3,4.6,12.5,6.8,18.8c-0.6,0.2-1.3,0.5-1.9,0.7c-2.3-6.3-4.6-12.5-6.8-18.8c-28.8,10.6-53.8,25.1-77.4,44.7\n    c4.3,5.1,8.6,10.2,12.9,15.3c-0.5,0.4-1,0.9-1.5,1.3c-4.3-5.1-8.6-10.2-12.9-15.3c-23.4,19.8-42,42-57.4,68.5\n    c5.8,3.3,11.5,6.7,17.3,10c-0.3,0.6-0.7,1.2-1,1.7c-5.8-3.3-11.5-6.7-17.3-10c-15.2,26.6-25.1,53.8-30.6,84\n    c6.6,1.2,13.1,2.3,19.7,3.5c-0.1,0.7-0.2,1.3-0.3,2c-6.6-1.2-13.1-2.3-19.7-3.5c-5.2,30.2-5.2,59.2,0,89.4\n    c6.6-1.2,13.1-2.3,19.7-3.5c0.1,0.7,0.2,1.3,0.3,2c-6.6,1.2-13.1,2.3-19.7,3.5c5.4,30.2,15.3,57.4,30.6,84\n    c5.8-3.3,11.5-6.7,17.3-10c0.3,0.6,0.7,1.2,1,1.7c-5.8,3.3-11.5,6.7-17.3,10c15.4,26.5,34,48.7,57.4,68.5\n    c4.3-5.1,8.6-10.2,12.9-15.3C383.5,726,384,726.5,384.6,726.9z\"/>\n  <path class=\"st2\" d=\"M692.2,484.7c-30.6-84.1-123.6-127.4-207.6-96.8c-84.1,30.6-127.4,123.6-96.8,207.6\n    c30.6,84.1,123.6,127.4,207.6,96.8C679.5,661.7,722.8,568.8,692.2,484.7z M594.7,690.5c-83,30.2-174.9-12.6-205.1-95.6\n    c-30.2-83,12.6-174.9,95.6-205.1c83-30.2,174.9,12.6,205.1,95.6C720.6,568.4,677.7,660.2,594.7,690.5z\"/>\n</g>\n<g id=\"Scale_BL2\">\n  <path class=\"st3_1\" :fill=\"color\" d=\"M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4\n    C82,745.5,39.5,504.3,149.5,314.7z\"/>\n</g>\n<g id=\"Scale_BL3\">\n  <linearGradient id=\"SVGID_1_1\" gradientUnits=\"userSpaceOnUse\" x1=\"214.4087\" y1=\"932.3943\" x2=\"44.3172\" y2=\"297.604\">\n    <stop  offset=\"0\" style=\"stop-color:#FFFFFF\"/>\n    <stop  offset=\"0.5\" style=\"stop-color:#7A7A7A;stop-opacity:0\"/>\n    <stop  offset=\"1\" style=\"stop-color:#000000\"/>\n  </linearGradient>\n  <path class=\"st4_1\" d=M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4\n    C82,745.5,39.5,504.3,149.5,314.7z\"/>\n</g>\n<g id=\"Scale_BL\">\n  <path class=\"st2\"  d=\"M251.5,885.5C83.3,745,40.8,503.8,150.8,314.2c-12.1-7-24.2-14-36.4-21c-0.3,0.6-0.7,1.2-1,1.7\n    c11.5,6.7,23.1,13.3,34.6,20c-10.2,17.7-19.1,35.9-26.8,54.9c-6.2-2.5-12.4-5-18.5-7.5c-0.3,0.6-0.5,1.2-0.7,1.9\n    c6.2,2.5,12.4,5,18.5,7.5c-7.6,19-13.9,38.2-18.9,58.1c-6.5-1.6-12.9-3.2-19.4-4.8c-0.2,0.6-0.3,1.3-0.5,1.9\n    c6.5,1.6,12.9,3.2,19.4,4.8c-4.9,19.9-8.4,39.8-10.6,60.1c-6.6-0.7-13.3-1.4-19.9-2.1c-0.1,0.7-0.1,1.3-0.2,2\n    c6.6,0.7,13.3,1.4,19.9,2.1c-2.1,20.3-2.8,40.6-2.1,61c-6.7,0.2-13.3,0.5-20,0.7c0,0.7,0,1.3,0.1,2c6.7-0.2,13.3-0.5,20-0.7\n    c0.8,20.4,2.9,40.6,6.4,60.7c-13.1,2.3-26.3,4.6-39.4,6.9c0.1,0.7,0.2,1.3,0.3,2c13.1-2.3,26.3-4.6,39.4-6.9\n    c3.6,20.1,8.5,39.8,14.8,59.3c-6.3,2.1-12.7,4.1-19,6.2c0.2,0.6,0.4,1.3,0.6,1.9c6.3-2.1,12.7-4.1,19-6.2\n    c6.4,19.4,14,38.2,22.9,56.6c-6,2.9-12,5.8-18,8.8c0.3,0.6,0.6,1.2,0.9,1.8c6-2.9,12-5.8,18-8.8c9,18.4,19.1,35.9,30.5,52.9\n    c-5.5,3.7-11.1,7.5-16.6,11.2c0.4,0.6,0.7,1.1,1.1,1.7c5.5-3.7,11.1-7.5,16.6-11.2c11.5,16.9,23.9,32.9,37.6,48.1\n    c-5,4.5-9.9,8.9-14.9,13.4c0.4,0.5,0.9,1,1.3,1.5c5-4.5,9.9-8.9,14.9-13.4c13.7,15.2,28.3,29.2,43.9,42.4\n    c-8.6,10.2-17.1,20.4-25.7,30.6c0.5,0.4,1,0.9,1.5,1.3C233.5,906.9,242.5,896.2,251.5,885.5z\"/>\n</g>\n<g id=\"Scale_BR2\" v-show=\"!cancel\">\n  <path class=\"st3_1\" :fill=\"color\" d=\"M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1\n    C900.2,190.4,1022.6,402.5,984.1,618.3z\"/>\n</g>\n<g id=\"Scale_BR3\" v-show=\"!cancel\">\n  <linearGradient id=\"SVGID_2_1\" gradientUnits=\"userSpaceOnUse\" x1=\"968.8124\" y1=\"649.5213\" x2=\"803.8889\" y2=\"34.0186\">\n    <stop  offset=\"0\" style=\"stop-color:#808080;stop-opacity:1\"/>\n    <stop  offset=\"1\" style=\"stop-color:#808080;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st5_1\" d=\"M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1\n    C900.2,190.4,1022.6,402.5,984.1,618.3z\"/>\n</g>\n\n<g id=\"Scale_BR\" v-show=\"!cancel\">\n  <path class=\"st2\" d=\"M983,619.2c38.5-215.7-83.9-427.8-290-502.3c4.8-13.2,9.6-26.3,14.4-39.5c0.6,0.2,1.3,0.5,1.9,0.7\n    c-4.6,12.5-9.1,25.1-13.7,37.6c19.2,7,37.7,15.3,55.8,24.8c3.1-5.9,6.3-11.8,9.4-17.7c0.6,0.3,1.2,0.6,1.8,0.9\n    c-3.1,5.9-6.3,11.8-9.4,17.7c18,9.6,35.2,20.4,51.8,32.4c3.9-5.4,7.8-10.8,11.8-16.2c0.5,0.4,1.1,0.8,1.6,1.2\n    c-3.9,5.4-7.8,10.8-11.8,16.2c16.5,12.1,32,25.1,46.8,39.3c4.6-4.8,9.3-9.6,13.9-14.4c0.5,0.5,1,0.9,1.4,1.4\n    c-4.6,4.8-9.3,9.6-13.9,14.4c14.7,14.2,28.2,29.3,40.9,45.4c5.3-4.1,10.5-8.2,15.8-12.3c0.4,0.5,0.8,1,1.2,1.6\n    c-5.3,4.1-10.5,8.2-15.8,12.3c12.6,16.1,23.9,32.9,34.1,50.6c11.5-6.7,23.1-13.3,34.6-20c0.3,0.6,0.7,1.2,1,1.7\n    c-11.5,6.7-23.1,13.3-34.6,20c10.2,17.7,19.1,35.9,26.8,54.9c6.2-2.5,12.4-5,18.5-7.5c0.3,0.6,0.5,1.2,0.7,1.9\n    c-6.2,2.5-12.4,5-18.5,7.5c7.6,19,13.9,38.2,18.9,58.1c6.5-1.6,12.9-3.2,19.4-4.8c0.2,0.6,0.3,1.3,0.5,1.9\n    c-6.5,1.6-12.9,3.2-19.4,4.8c4.9,19.9,8.4,39.8,10.6,60.1c6.6-0.7,13.3-1.4,19.9-2.1c0.1,0.7,0.1,1.3,0.2,2\n    c-6.6,0.7-13.3,1.4-19.9,2.1c2.1,20.3,2.8,40.6,2.1,61c6.7,0.2,13.3,0.5,20,0.7c0,0.7,0,1.3-0.1,2c-6.7-0.2-13.3-0.5-20-0.7\n    c-0.8,20.4-2.9,40.6-6.4,60.7c13.1,2.3,26.3,4.6,39.4,6.9c-0.1,0.7-0.2,1.3-0.3,2C1010.6,624.1,996.8,621.7,983,619.2z\"/>\n</g>\n<g id=\"Color_B01\" class=\"hover\" @click=\"value={h:0,s:'90%',l:'40%'},index=0\">\n  <linearGradient id=\"SVGID_1_\" gradientUnits=\"userSpaceOnUse\" x1=\"810.9808\" y1=\"540.1049\" x2=\"940.1153\" y2=\"540.1049\">\n    <stop  offset=\"9.271834e-008\" style=\"stop-color:#990000\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#990000\"/>\n    <stop  offset=\"1\" style=\"stop-color:#990000;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st3\" d=\"M811,586.9c41,7.2,82.1,14.5,123.1,21.7c8-46.3,8-90.7,0-136.9c-41,7.2-82.1,14.5-123.1,21.7\n    C816.4,525,816.4,555.3,811,586.9z\"/>\n</g>\n<g id=\"Color_B02\" @click=\"value={h:0.0996,s:'70%',l:'50%'},index=1\">\n  <linearGradient id=\"SVGID_2_\" gradientUnits=\"userSpaceOnUse\" x1=\"794.638\" y1=\"447.4195\" x2=\"915.9847\" y2=\"403.2529\">\n    <stop  offset=\"0\" style=\"stop-color:#CC7A00\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#CC7A00\"/>\n    <stop  offset=\"1\" style=\"stop-color:#CC7A00;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st4\" d=\"M810.6,491.4c41-7.2,82.1-14.5,123.1-21.7c-8.3-46.3-23.4-87.9-46.8-128.7c-36.1,20.8-72.2,41.7-108.3,62.5\n    C794.6,431.3,804.9,459.8,810.6,491.4z\"/>\n</g>\n<g id=\"Color_B03\" @click=\"value={h:0.16666666,s:'80%',l:'50%'},index=2\">\n  <linearGradient id=\"SVGID_3_\" gradientUnits=\"userSpaceOnUse\" x1=\"747.5805\" y1=\"365.9128\" x2=\"846.5033\" y2=\"282.9067\">\n    <stop  offset=\"0\" style=\"stop-color:#cccc00\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#cccc00\"/>\n    <stop  offset=\"1\" style=\"stop-color:#cccc00;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st5\" d=\"M777.6,401.7c36.1-20.8,72.2-41.7,108.3-62.5c-23.6-40.6-52.1-74.6-88-104.9c-26.8,31.9-53.6,63.8-80.3,95.8\n    C742,350.8,761.5,374,777.6,401.7z\"/>\n</g>\n<g id=\"Color_B04\" @click=\"value={h:0.23311,s:'50%',l:'60%'},index=3\">\n  <linearGradient id=\"SVGID_4_\" gradientUnits=\"userSpaceOnUse\" x1=\"675.4836\" y1=\"305.4167\" x2=\"740.0508\" y2=\"193.583\">\n    <stop  offset=\"0\" style=\"stop-color:#5c9900\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#5c9900\"/>\n    <stop  offset=\"1\" style=\"stop-color:#5c9900;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st6\" d=\"M716,328.8c26.8-31.9,53.6-63.8,80.3-95.8c-36.1-30.1-74.5-52.3-118.6-68.5c-14.3,39.2-28.5,78.3-42.8,117.5\n    C665.1,293.1,691.3,308.3,716,328.8z\"/>\n</g>\n<g id=\"Color_B05\" @click=\"value={h:0.33333333333333,s:'100%',l:'30%'},index=4\">\n  <linearGradient id=\"SVGID_5_\" gradientUnits=\"userSpaceOnUse\" x1=\"587.0449\" y1=\"273.228\" x2=\"609.4689\" y2=\"146.0551\">\n    <stop  offset=\"0\" style=\"stop-color:#009900\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#009900\"/>\n    <stop  offset=\"1\" style=\"stop-color:#009900;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st7\" d=\"M633.1,281.3c14.3-39.2,28.5-78.3,42.8-117.5c-44.2-16-87.9-23.7-134.9-23.8c0,41.7,0,83.3,0,125\n    C573.1,265.2,602.9,270.5,633.1,281.3z\"/>\n</g>\n<g id=\"Color_B06\" @click=\"value={h : 0.430555556,s:'70%',l:'50%'},index=5\">\n  <linearGradient id=\"SVGID_6_\" gradientUnits=\"userSpaceOnUse\" x1=\"492.9301\" y1=\"273.228\" x2=\"470.5061\" y2=\"146.0549\">\n    <stop  offset=\"0\" style=\"stop-color:#00cc7a\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#00cc7a\"/>\n    <stop  offset=\"1\" style=\"stop-color:#00cc7a;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st8\" d=\"M539,265.1c0-41.7,0-83.3,0-125c-47,0.1-90.7,7.8-134.9,23.8c14.3,39.2,28.5,78.3,42.8,117.5\n    C477.1,270.5,506.9,265.2,539,265.1z\"/>\n</g>\n<g id=\"Color_B07\" @click=\"value={h :0.5,s:'50%',l:'50%'},index=6\">\n  <linearGradient id=\"SVGID_7_\" gradientUnits=\"userSpaceOnUse\" x1=\"404.4905\" y1=\"305.4172\" x2=\"339.9231\" y2=\"193.5832\">\n    <stop  offset=\"9.271834e-008\" style=\"stop-color:#00cccc\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#00cccc\"/>\n    <stop  offset=\"1\" style=\"stop-color:#00FFFF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st9\" d=\"M445,282c-14.3-39.2-28.5-78.3-42.8-117.5c-44.1,16.2-82.5,38.4-118.6,68.5c26.8,31.9,53.6,63.8,80.3,95.8\n    C388.6,308.3,414.9,293.1,445,282z\"/>\n</g>\n<g id=\"Color_B08\" @click=\"value={h : 0.5669,s:'50%',l:'60%'},index=7\">\n  <linearGradient id=\"SVGID_8_\" gradientUnits=\"userSpaceOnUse\" x1=\"332.3944\" y1=\"365.9128\" x2=\"233.4712\" y2=\"282.9063\">\n    <stop  offset=\"1.854367e-007\" style=\"stop-color:#007acc\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#007acc\"/>\n    <stop  offset=\"1\" style=\"stop-color:#007acc;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st10\" d=\"M362.5,330.1c-26.8-31.9-53.6-63.8-80.3-95.8c-35.9,30.3-64.4,64.3-88,104.9c36.1,20.8,72.2,41.7,108.3,62.5\n    C318.5,374,338,350.8,362.5,330.1z\"/>\n</g>\n<g id=\"Color_B09\" @click=\"value={h : 0.66666666666,s:'60%',l:'50%'},index=8\">\n  <linearGradient id=\"SVGID_9_\" gradientUnits=\"userSpaceOnUse\" x1=\"285.3359\" y1=\"447.4191\" x2=\"163.9899\" y2=\"403.2528\">\n    <stop  offset=\"2.781550e-007\" style=\"stop-color:#000099\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#000099\"/>\n    <stop  offset=\"1\" style=\"stop-color:#000099;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st11\" d=\"M301.3,403.5c-36.1-20.8-72.2-41.7-108.3-62.5c-23.4,40.8-38.6,82.4-46.8,128.7c41,7.2,82.1,14.5,123.1,21.7\n    C275,459.8,285.4,431.3,301.3,403.5z\"/>\n</g>\n<g id=\"Color_B10\" @click=\"value={h : 0.7663,s:'50%',l:'40%'},index=9\">\n  <linearGradient id=\"SVGID_10_\" gradientUnits=\"userSpaceOnUse\" x1=\"268.993\" y1=\"540.1049\" x2=\"139.8585\" y2=\"540.1049\">\n    <stop  offset=\"2.781550e-007\" style=\"stop-color:#7a00cc\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#7a00cc\"/>\n    <stop  offset=\"1\" style=\"stop-color:#7a00cc;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st12\" d=\"M269,493.3c-41-7.2-82.1-14.5-123.1-21.7c-8,46.3-8,90.7,0,136.9c41-7.2,82.1-14.5,123.1-21.7\n    C263.5,555.3,263.5,525,269,493.3z\"/>\n</g>\n<g id=\"Color_B11\" @click=\"value={h:0.83333333333,s:'60%',l:'50%'},index=10\">\n  <linearGradient id=\"SVGID_11_\" gradientUnits=\"userSpaceOnUse\" x1=\"285.3358\" y1=\"632.7901\" x2=\"163.9899\" y2=\"676.9564\">\n    <stop  offset=\"3.708734e-007\" style=\"stop-color:#FF00FF\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#FF00FF\"/>\n    <stop  offset=\"1\" style=\"stop-color:#FF00FF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st13\" d=\"M269.3,588.8c-41,7.2-82.1,14.5-123.1,21.7c8.3,46.3,23.4,87.9,46.8,128.7c36.1-20.8,72.2-41.7,108.3-62.5\n    C285.4,648.9,275,620.4,269.3,588.8z\"/>\n</g>\n<g id=\"Color_B12\" @click=\"value={h:0.9,s:'50%',l:'80%'},index=11\">\n  <linearGradient id=\"SVGID_12_\" gradientUnits=\"userSpaceOnUse\" x1=\"332.3944\" y1=\"714.2958\" x2=\"233.4712\" y2=\"797.3022\">\n    <stop  offset=\"3.708734e-007\" style=\"stop-color:#ff99d6\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#ff99d6\"/>\n    <stop  offset=\"1\" style=\"stop-color:#ff99d6;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st14\" d=\"M302.3,678.5c-36.1,20.8-72.2,41.7-108.3,62.5c23.6,40.6,52.1,74.6,88,104.9c26.8-31.9,53.6-63.8,80.3-95.8\n    C338,729.4,318.5,706.2,302.3,678.5z\"/>\n</g>\n<g id=\"Color_B13\" @click=\"value={h:0.123,s:'62%',l:'70%'},index=12\">\n  <linearGradient id=\"SVGID_13_\" gradientUnits=\"userSpaceOnUse\" x1=\"492.9301\" y1=\"806.9812\" x2=\"470.5062\" y2=\"934.1538\">\n    <stop  offset=\"2.737399e-007\" style=\"stop-color:#d8b656\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#d8b656\"/>\n    <stop  offset=\"1\" style=\"stop-color:#d8b656;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st15\" d=\"M446.9,798.9c-14.3,39.2-28.5,78.3-42.8,117.5c44.2,16,87.9,23.7,134.9,23.8c0-41.7,0-83.3,0-125\n    C506.9,815,477.1,809.7,446.9,798.9z\"/>\n</g>\n<g id=\"Color_B14\" @click=\"value={h:0,s:'0%',l:'70%'},index=13\">\n  <linearGradient id=\"SVGID_14_\" gradientUnits=\"userSpaceOnUse\" x1=\"587.0449\" y1=\"806.9812\" x2=\"609.4688\" y2=\"934.1536\">\n    <stop  offset=\"3.664582e-007\" style=\"stop-color:#999999\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#999999\"/>\n    <stop  offset=\"1\" style=\"stop-color:#999999;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st16\" d=\"M541,815.1c0,41.7,0,83.3,0,125c47-0.1,90.7-7.8,134.9-23.8c-14.3-39.2-28.5-78.3-42.8-117.5\n    C602.9,809.7,573.1,815,541,815.1z\"/>\n</g>\n<g id=\"Color_B15\"  @click=\"value={h:0,s:'0%',l:'30%'},index=14\">\n  <linearGradient id=\"SVGID_15_\" gradientUnits=\"userSpaceOnUse\" x1=\"675.4838\" y1=\"774.7922\" x2=\"740.0508\" y2=\"886.6255\">\n    <stop  offset=\"4.591765e-007\" style=\"stop-color:#4d4d4d\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#4d4d4d\"/>\n    <stop  offset=\"1\" style=\"stop-color:#4d4d4d;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st17\" d=\"M635,798.2c14.3,39.2,28.5,78.3,42.8,117.5c44.1-16.2,82.5-38.4,118.6-68.5c-26.8-31.9-53.6-63.8-80.3-95.8\n    C691.3,771.9,665.1,787.1,635,798.2z\"/>\n</g>\n<g id=\"Color_B16\" @click=\"value={h:0,s:'0%',l:'100%'},index=15\">\n  <linearGradient id=\"SVGID_16_\" gradientUnits=\"userSpaceOnUse\" x1=\"747.5805\" y1=\"714.2958\" x2=\"846.5033\" y2=\"797.3018\">\n    <stop  offset=\"3.664582e-007\" style=\"stop-color:#e5e5e5\"/>\n    <stop  offset=\"0.2\" style=\"stop-color:#e5e5e5\"/>\n    <stop  offset=\"1\" style=\"stop-color:#e5e5e5;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st18\" d=\"M717.5,750.1c26.8,31.9,53.6,63.8,80.3,95.8c35.9-30.3,64.4-64.3,88-104.9c-36.1-20.8-72.2-41.7-108.3-62.5\n    C761.5,706.2,742,729.4,717.5,750.1z\"/>\n</g>\n<g id=\"Pin_BL\" :transform=\"'rotate(' + BLangle + ' 540 540)'\">\n  <g>\n    <linearGradient id=\"SVGID_171_\" gradientUnits=\"userSpaceOnUse\" x1=\"57.5965\" y1=\"530.0045\" x2=\"20.0443\" y2=\"530.0045\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_171_);\" d=\"M20,532.4c0-1.8,0.1-3.6,0.1-5.4c9.6,0.6,19.3,1.2,28.9,1.9c2.8,1.4,5.7,2.8,8.5,4.1    C45.1,532.8,32.6,532.6,20,532.4z\"/>\n    <linearGradient id=\"SVGID_181_\" gradientUnits=\"userSpaceOnUse\" x1=\"77.9868\" y1=\"540.1041\" x2=\"19.9875\" y2=\"540.1041\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_181_);\" d=\"M20,543.8c0-2.5,0-4.9,0-7.4c19.3,0.3,38.7,0.6,58,0.9c0,1.9,0,3.7,0,5.6C58.7,543.2,39.3,543.5,20,543.8z\"/>\n    <linearGradient id=\"SVGID_191_\" gradientUnits=\"userSpaceOnUse\" x1=\"57.5965\" y1=\"550.2053\" x2=\"20.0443\" y2=\"550.2053\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_191_);\" d=\"M20.2,553.2c0-1.8-0.1-3.6-0.1-5.4c12.5-0.2,25-0.4,37.6-0.6c-2.8,1.4-5.7,2.8-8.5,4.1    C39.4,552,29.8,552.6,20.2,553.2z\"/>\n  </g>\n</g>\n<g id=\"Pin_BR\" :transform=\"'rotate(' + BRangle + ' 540 540)'\" v-show=\"!cancel\">\n  <g xmlns=\"http://www.w3.org/2000/svg\">\n    <linearGradient id=\"SVGID_101_\" gradientUnits=\"userSpaceOnUse\" x1=\"1022.4805\" y1=\"550.2055\" x2=\"1060.0327\" y2=\"550.2055\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_101_)\" d=\"M1059.9,553.2c0-1.8,0.1-3.6,0.1-5.4c-12.5-0.2-25-0.4-37.6-0.6c2.8,1.4,5.7,2.8,8.5,4.1    C1040.6,552,1050.3,552.6,1059.9,553.2z\"/>\n    <linearGradient id=\"SVGID_111_\" gradientUnits=\"userSpaceOnUse\" x1=\"1002.0901\" y1=\"540.1044\" x2=\"1060.0895\" y2=\"540.1044\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_111_)\" d=\"M1060.1,543.8c0-2.5,0-4.9,0-7.4c-19.3,0.3-38.7,0.6-58,0.9c0,1.9,0,3.7,0,5.6    C1021.4,543.2,1040.7,543.5,1060.1,543.8z\"/>\n    <linearGradient id=\"SVGID_121_\" gradientUnits=\"userSpaceOnUse\" x1=\"1022.4805\" y1=\"530.0047\" x2=\"1060.0327\" y2=\"530.0047\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_121_)\" d=\"M1060,532.4c0-1.8-0.1-3.6-0.1-5.4c-9.6,0.6-19.3,1.2-28.9,1.9c-2.8,1.4-5.7,2.8-8.5,4.1    C1035,532.8,1047.5,532.6,1060,532.4z\"/>\n  </g>\n</g>\n<g id=\"Pin_B\" :transform=\"'rotate(' + angles[index] + ' 540 540)'\">\n  <g>\n    <linearGradient id=\"SVGID_231_\" gradientUnits=\"userSpaceOnUse\" x1=\"875.485\" y1=\"539.9995\" x2=\"516.9875\" y2=\"539.9995\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_231_)\" d=\"M561.2,531.1c-9.7-23.2-44.2-16.3-44.2,8.9s34.5,32.1,44.2,8.9c0.2-0.4,0.3-0.8,0.5-1.2    c104.6-1.6,209.2-3.3,313.8-4.9c0-1.9,0-3.7,0-5.6c-104.6-1.6-209.2-3.3-313.8-4.9C561.5,531.9,561.4,531.5,561.2,531.1z\"/>\n    <linearGradient id=\"SVGID_241_\" gradientUnits=\"userSpaceOnUse\" x1=\"855.0947\" y1=\"540\" x2=\"508.9872\" y2=\"540\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_241_)\" d=\"M846.6,528.8c2.8,1.4,5.7,2.8,8.5,4.1c-96.9-1.5-193.8-3-290.7-4.5C552,502.4,513,511.2,513,540    c0,28.8,39,37.6,51.4,11.6c96.9-1.5,193.8-3,290.7-4.5c-2.8,1.4-5.7,2.8-8.5,4.1c-101.5,6.6-203,13.1-304.6,19.7    c-44,2.8-44-64.7,0-61.9C643.5,515.6,745,522.2,846.6,528.8z\"/>\n  </g>\n</g>\n<g id=\"Monitor_B\">\n  <radialGradient id=\"SVGID_21_\" cx=\"539.9872\" cy=\"540.1043\" r=\"150.0408\" gradientUnits=\"userSpaceOnUse\">\n    <stop  offset=\"0\" style=\"stop-color:#000000\"/>\n    <stop  offset=\"1\" style=\"stop-color:#000000;stop-opacity:0.5\"/>\n  </radialGradient>\n  <circle class=\"st23\" cx=\"540\" cy=\"540.1\" r=\"150\"/>\n  <linearGradient id=\"SVGID_22_\" gradientUnits=\"userSpaceOnUse\" x1=\"539.987\" y1=\"392.0641\" x2=\"539.987\" y2=\"688.1447\">\n    <stop  class=\"pad\" offset=\"9.271834e-008\" :style=\"'stop-color:' + color \"/>\n    <stop  offset=\"1\" :style=\"'stop-color:' + color\"/>\n  </linearGradient>\n  <circle class=\"st24\" cx=\"540\" cy=\"540.1\" r=\"148\" @click=\"colorSet='diffuse'\"/>\n  <linearGradient id=\"SVGID_23_\" gradientUnits=\"userSpaceOnUse\" x1=\"539.9875\" y1=\"683.535\" x2=\"539.9875\" y2=\"555.6201\">\n    <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n    <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st25\" d=\"M540,555.6c36.6,0,94.1,17.1,94.1,64c0,46.8-57.5,64-94.1,64c-36.6,0-94.1-17.1-94.1-64\n    C445.9,572.7,503.4,555.6,540,555.6z\" @click=\"colorSet='shadow'\"/>\n  <linearGradient id=\"SVGID_24_\" gradientUnits=\"userSpaceOnUse\" x1=\"539.9875\" y1=\"396.6736\" x2=\"539.9875\" y2=\"524.5886\">\n    <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n    <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st26\" d=\"M540,524.6c36.6,0,94.1-17.1,94.1-64c0-46.8-57.5-64-94.1-64c-36.6,0-94.1,17.1-94.1,64\n    C445.9,507.5,503.4,524.6,540,524.6z\" @click=\"colorSet='highlight'\"/>\n  <linearGradient id=\"SVGID_25_\" gradientUnits=\"userSpaceOnUse\" x1=\"539.9869\" y1=\"400.9027\" x2=\"539.9869\" y2=\"450.9808\">\n    <stop  offset=\"0\" style=\"stop-color:#FFFFFF;stop-opacity:0.6\"/>\n    <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st27\" d=\"M540,451c10.1,0,19.6-1.3,29.2-5c7.9-3,19.6-9.3,19.6-20.1c0-10.7-11.7-17-19.6-20.1c-9.6-3.7-19-5-29.1-5\n    c-10.1,0-19.6,1.3-29.2,5c-7.9,3-19.6,9.3-19.6,20.1c0,10.7,11.7,17,19.6,20.1C520.4,449.7,529.9,451,540,451z\"/>\n    <text xmlns=\"http://www.w3.org/2000/svg\" transform=\"matrix(1 0 0 1 484.3381 482)\">\n      <tspan x=\"0\" y=\"0\" style=\"font-size:36px;font-family:'HYg1gj'\" v-text=\"change.name\"></tspan>\n      <tspan x=\"-40\" y=\"130\" style=\"font-size:120px;font-family:'HYg1gj'\" v-text=\"change.value\"></tspan>\n      <tspan x=\"-20\" y=\"120\" style=\"font-size:36px;font-family:'HYg1gj'\" v-text=\"change.hover\"></tspan>\n      <tspan x=\"150\" y=\"130\" style=\"font-size:36px\" v-text=\"change.name?'%':''\"></tspan>\n\n    </text>\n</g>\n<g id=\"Color_P\">\n</g>\n<g id=\"To_Pro\" @click=\"current = 'pro'\" @mouseover=\"save=change,change={hover:'高级模式'}\" @mouseout=\"change=save\">\n  <g>\n    <path class=\"st2\" d=\"M925.1,774.2c-16-4.3-32.5,5.2-36.7,21.2c-4.3,16,5.2,32.5,21.2,36.7c16,4.3,32.5-5.2,36.7-21.2\n      C950.6,794.9,941.1,778.4,925.1,774.2z M944.4,810.4c-4,14.9-19.4,23.8-34.3,19.8c-14.9-4-23.8-19.4-19.8-34.3\n      c4-14.9,19.4-23.8,34.3-19.8C939.6,780.1,948.4,795.4,944.4,810.4z\"/>\n    <g>\n      <defs>\n        <circle id=\"SVGID_44_\" cx=\"917.4\" cy=\"803.1\" r=\"28\"/>\n      </defs>\n      <clipPath id=\"SVGID_45_\">\n        <use xlink:href=\"#SVGID_44_\"  style=\"overflow:visible;\"/>\n      </clipPath>\n      <g class=\"st43\">\n\n          <image style=\"overflow:visible;\" width=\"851\" height=\"850\" xlink:href=\"hue-ring.png\" transform=\"matrix(5.837880e-002 5.837880e-002 -5.837880e-002 5.837880e-002 917.3402 753.4789)\">\n        </image>\n      </g>\n    </g>\n  </g>\n</g>\n<style>\n.v-colors .color path {\n  stroke: #888;\n  cursor: pointer;\n}\n  #spe .st4_1{fill:url(#SVGID_1_1);}\n  #spe .st5_1{fill:url(#SVGID_2_1);}\n  #spe .st0{display:none;}\n  #spe .st1{display:inline;fill:#333333;}\n  #spe .st2{fill:#F5D96C;}\n  #spe .st3{fill:url(#SVGID_1_);}\n  #spe .st4{fill:url(#SVGID_2_);}\n  #spe .st5{fill:url(#SVGID_3_);}\n  #spe .st6{fill:url(#SVGID_4_);}\n  #spe .st7{fill:url(#SVGID_5_);}\n  #spe .st8{fill:url(#SVGID_6_);}\n  #spe .st9{fill:url(#SVGID_7_);}\n  #spe .st10{fill:url(#SVGID_8_);}\n  #spe .st11{fill:url(#SVGID_9_);}\n  #spe .st12{fill:url(#SVGID_10_);}\n  #spe .st13{fill:url(#SVGID_11_);}\n  #spe .st14{fill:url(#SVGID_12_);}\n  #spe .st15{fill:url(#SVGID_13_);}\n  #spe .st16{fill:url(#SVGID_14_);}\n  #spe .st17{fill:url(#SVGID_15_);}\n  #spe .st18{fill:url(#SVGID_16_);}\n  #spe .st19{fill:url(#SVGID_17_);}\n  #spe .st20{fill:url(#SVGID_18_);}\n  #spe .st21{fill:none;stroke:url(#SVGID_19_);stroke-miterlimit:10;}\n  #spe .st22{fill:url(#SVGID_20_);}\n  #spe .st23{fill:url(#SVGID_21_);}\n  #spe .st24{fill:url(#SVGID_22_);}\n  #spe .st25{fill:url(#SVGID_23_);}\n  #spe .st26{fill:url(#SVGID_24_);}\n  #spe .st27{fill:url(#SVGID_25_);}\n  #spe .st28{fill:url(#SVGID_26_);}\n  #spe .st29{fill:url(#SVGID_27_);}\n  #spe .st30{fill:url(#SVGID_28_);}\n  #spe .st31{fill:url(#SVGID_29_);}\n  #spe .st32{fill:url(#SVGID_30_);}\n  #spe .st33{fill:url(#SVGID_31_);}\n  #spe .st34{clip-path:url(#SVGID_33_);}\n  #spe .st35{fill:url(#SVGID_34_);}\n  #spe .st36{clip-path:url(#SVGID_36_);}\n  #spe .st37{fill:url(#SVGID_37_);}\n  #spe .st38{clip-path:url(#SVGID_39_);}\n  #spe .st39{fill:url(#SVGID_40_);}\n  #spe .st40{fill:url(#SVGID_41_);}\n  #spe .st41{fill:url(#SVGID_42_);}\n  #spe .st42{fill:url(#SVGID_43_);}\n  #spe .st43{clip-path:url(#SVGID_45_);}\n  #spe .st44{opacity:0.5;fill:url(#SVGID_46_);}\n  #spe .st45{opacity:0.5;fill:url(#SVGID_47_);}\n  #spe .st46{opacity:0.5;fill:url(#SVGID_48_);}\n  #spe .st47{opacity:0.5;fill:url(#SVGID_49_);}\n  #spe .st48{opacity:0.5;fill:url(#SVGID_50_);}\n  #spe .st49{opacity:0.5;fill:url(#SVGID_51_);}\n  #spe .st00{\n    fill: none;\n    stroke: #F5D96C;\n    stroke-width: 2;\n    stroke-miterlimit: 10\n  }\n  .font{\n    font-size: 36px;\n    font-family: 'MicrosoftYaHei';\n    fill:#F5D96C;\n  }\n</style>";

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(133)

	if (module.exports.__esModule) module.exports = module.exports.default
	;(typeof module.exports === "function" ? module.exports.options : module.exports).template = __webpack_require__(134)
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/bradpitt/Documents/front/carFitting/src/interact/remolder/materials/spec_pro_color.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, (typeof module.exports === "function" ? module.exports.options : module.exports).template)
	  }
	})()}

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// <template>
	// <g id="Scale_P">
	//   <path class="st1" d="M449.4,291.1c-192.1,69.9-236,321.8-78.9,452.7c23.7,19.8,49,34.4,78,45c121.4,44.7,257.3-4.8,321.6-117
	//     c15.3-26.8,25.3-54.2,30.8-84.6C837.1,385.9,641.5,221.2,449.4,291.1z M799.2,584.8c-6.6-1.2-13.1-2.3-19.7-3.5
	//     c-0.1,0.7-0.2,1.3-0.3,2c6.6,1.2,13.1,2.3,19.7,3.5c-5.4,30.2-15.3,57.4-30.6,84c-5.8-3.3-11.5-6.7-17.3-10c-0.3,0.6-0.7,1.2-1,1.7
	//     c5.8,3.3,11.5,6.7,17.3,10c-15.4,26.5-34,48.7-57.4,68.5c-4.3-5.1-8.6-10.2-12.9-15.3c-0.5,0.4-1,0.9-1.5,1.3
	//     c4.3,5.1,8.6,10.2,12.9,15.3c-23.6,19.6-48.6,34.1-77.4,44.7c-2.3-6.3-4.6-12.5-6.8-18.8c-0.6,0.2-1.3,0.5-1.9,0.7
	//     c2.3,6.3,4.6,12.5,6.8,18.8c-28.8,10.4-57.4,15.4-88,15.5c0-6.7,0-13.3,0-20c-0.7,0-1.3,0-2,0c0,6.7,0,13.3,0,20
	//     c-30.6-0.1-59.2-5.1-88-15.5c2.3-6.3,4.6-12.5,6.8-18.8c-0.6-0.2-1.3-0.5-1.9-0.7c-2.3,6.3-4.6,12.5-6.8,18.8
	//     c-28.8-10.6-53.8-25.1-77.4-44.7c4.3-5.1,8.6-10.2,12.9-15.3c-0.5-0.4-1-0.9-1.5-1.3c-4.3,5.1-8.6,10.2-12.9,15.3
	//     c-23.4-19.8-42-42-57.4-68.5c5.8-3.3,11.5-6.7,17.3-10c-0.3-0.6-0.7-1.2-1-1.7c-5.8,3.3-11.5,6.7-17.3,10
	//     c-15.2-26.6-25.1-53.8-30.6-84c6.6-1.2,13.1-2.3,19.7-3.5c-0.1-0.7-0.2-1.3-0.3-2c-6.6,1.2-13.1,2.3-19.7,3.5
	//     c-5.2-30.2-5.2-59.2,0-89.4c6.6,1.2,13.1,2.3,19.7,3.5c0.1-0.7,0.2-1.3,0.3-2c-6.6-1.2-13.1-2.3-19.7-3.5
	//     c5.4-30.2,15.3-57.4,30.6-84c5.8,3.3,11.5,6.7,17.3,10c0.3-0.6,0.7-1.2,1-1.7c-5.8-3.3-11.5-6.7-17.3-10
	//     c15.4-26.5,34-48.7,57.4-68.5c4.3,5.1,8.6,10.2,12.9,15.3c0.5-0.4,1-0.9,1.5-1.3c-4.3-5.1-8.6-10.2-12.9-15.3
	//     c23.6-19.6,48.6-34.1,77.4-44.7c2.3,6.3,4.6,12.5,6.8,18.8c0.6-0.2,1.3-0.5,1.9-0.7c-2.3-6.3-4.6-12.5-6.8-18.8
	//     c28.8-10.4,57.4-15.4,88-15.5c0,6.7,0,13.3,0,20c0.7,0,1.3,0,2,0c0-6.7,0-13.3,0-20c30.6,0.1,59.2,5.1,88,15.5
	//     c-2.3,6.3-4.6,12.5-6.8,18.8c0.6,0.2,1.3,0.5,1.9,0.7c2.3-6.3,4.6-12.5,6.8-18.8c28.8,10.6,53.8,25.1,77.4,44.7
	//     c-4.3,5.1-8.6,10.2-12.9,15.3c0.5,0.4,1,0.9,1.5,1.3c4.3-5.1,8.6-10.2,12.9-15.3c23.4,19.8,42,42,57.4,68.5
	//     c-5.8,3.3-11.5,6.7-17.3,10c0.3,0.6,0.7,1.2,1,1.7c5.8-3.3,11.5-6.7,17.3-10c15.2,26.6,25.1,53.8,30.6,84
	//     c-6.6,1.2-13.1,2.3-19.7,3.5c0.1,0.7,0.2,1.3,0.3,2c6.6-1.2,13.1-2.3,19.7-3.5C804.5,525.6,804.5,554.6,799.2,584.8z"/>
	//   <path class="st1" d="M692.3,484.7c-30.6-84.1-123.6-127.4-207.6-96.8c-84.1,30.6-127.4,123.6-96.8,207.6
	//     c30.6,84.1,123.6,127.4,207.6,96.8C679.6,661.7,722.9,568.8,692.3,484.7z M594.8,690.5c-83,30.2-174.9-12.6-205.1-95.6
	//     c-30.2-83,12.6-174.9,95.6-205.1c83-30.2,174.9,12.6,205.1,95.6C720.6,568.4,677.8,660.2,594.8,690.5z"/>
	// </g>
	// <g id="Scale_BL2">
	//   <path class="st3_1" :fill="color" d="M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4
	//     C82,745.5,39.5,504.3,149.5,314.7z"/>
	// </g>
	// <g id="Scale_BL3">
	//   <linearGradient id="SVGID_1_1" gradientUnits="userSpaceOnUse" x1="214.4087" y1="932.3943" x2="44.3172" y2="297.604">
	//     <stop  offset="0" style="stop-color:#FFFFFF"/>
	//     <stop  offset="0.5" style="stop-color:#7A7A7A;stop-opacity:0"/>
	//     <stop  offset="1" style="stop-color:#000000"/>
	//   </linearGradient>
	//   <path class="st4_1" d="M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4
	//     C82,745.5,39.5,504.3,149.5,314.7z"/>
	// </g>
	// <g id="Scale_PL">
	//   <path class="st1" d="M251.6,885.5C83.4,745,40.9,503.8,150.9,314.2c-12.1-7-24.2-14-36.4-21c-0.3,0.6-0.7,1.2-1,1.7
	//     c11.5,6.7,23.1,13.3,34.6,20c-10.2,17.7-19.1,35.9-26.8,54.9c-6.2-2.5-12.4-5-18.5-7.5c-0.3,0.6-0.5,1.2-0.7,1.9
	//     c6.2,2.5,12.4,5,18.5,7.5c-7.6,19-13.9,38.2-18.9,58.1c-6.5-1.6-12.9-3.2-19.4-4.8c-0.2,0.6-0.3,1.3-0.5,1.9
	//     c6.5,1.6,12.9,3.2,19.4,4.8c-4.9,19.9-8.4,39.8-10.6,60.1c-6.6-0.7-13.3-1.4-19.9-2.1c-0.1,0.7-0.1,1.3-0.2,2
	//     c6.6,0.7,13.3,1.4,19.9,2.1c-2.1,20.3-2.8,40.6-2.1,61c-6.7,0.2-13.3,0.5-20,0.7c0,0.7,0,1.3,0.1,2c6.7-0.2,13.3-0.5,20-0.7
	//     c0.8,20.4,2.9,40.6,6.4,60.7c-13.1,2.3-26.3,4.6-39.4,6.9c0.1,0.7,0.2,1.3,0.3,2c13.1-2.3,26.3-4.6,39.4-6.9
	//     c3.6,20.1,8.5,39.8,14.8,59.2c-6.3,2.1-12.7,4.1-19,6.2c0.2,0.6,0.4,1.3,0.6,1.9c6.3-2.1,12.7-4.1,19-6.2
	//     c6.4,19.4,14,38.2,22.9,56.6c-6,2.9-12,5.8-18,8.8c0.3,0.6,0.6,1.2,0.9,1.8c6-2.9,12-5.8,18-8.8c9,18.4,19.1,35.9,30.5,52.9
	//     c-5.5,3.7-11.1,7.5-16.6,11.2c0.4,0.6,0.7,1.1,1.1,1.7c5.5-3.7,11.1-7.5,16.6-11.2c11.5,16.9,23.9,32.9,37.6,48.1
	//     c-5,4.5-9.9,8.9-14.9,13.4c0.4,0.5,0.9,1,1.3,1.5c5-4.5,9.9-8.9,14.9-13.4c13.7,15.2,28.3,29.2,43.9,42.4
	//     c-8.6,10.2-17.1,20.4-25.7,30.6c0.5,0.4,1,0.9,1.5,1.3C233.6,906.9,242.6,896.2,251.6,885.5z"/>
	// </g>
	// <g id="Scale_BR2">
	//   <path class="st3_1" :fill="color" d="M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1
	//     C900.2,190.4,1022.6,402.5,984.1,618.3z"/>
	// </g>
	// <g id="Scale_BR3">
	//   <linearGradient id="SVGID_2_1" gradientUnits="userSpaceOnUse" x1="968.8124" y1="649.5213" x2="803.8889" y2="34.0186">
	//     <stop  offset="0" style="stop-color:#808080;stop-opacity:1"/>
	//     <stop  offset="1" style="stop-color:#808080;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st5_1" d="M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1
	//     C900.2,190.4,1022.6,402.5,984.1,618.3z"/>
	// </g>
	// <g id="Scale_PR">
	//   <path class="st1" d="M983.1,619.2c38.5-215.7-83.9-427.8-290-502.3c4.8-13.2,9.6-26.3,14.4-39.5c0.6,0.2,1.3,0.5,1.9,0.7
	//     c-4.6,12.5-9.1,25.1-13.7,37.6c19.2,7,37.7,15.3,55.8,24.8c3.1-5.9,6.3-11.8,9.4-17.7c0.6,0.3,1.2,0.6,1.8,0.9
	//     c-3.1,5.9-6.3,11.8-9.4,17.7c18,9.6,35.2,20.4,51.8,32.4c3.9-5.4,7.8-10.8,11.8-16.2c0.5,0.4,1.1,0.8,1.6,1.2
	//     c-3.9,5.4-7.8,10.8-11.8,16.2c16.5,12.1,32,25.1,46.8,39.3c4.6-4.8,9.3-9.6,13.9-14.4c0.5,0.5,1,0.9,1.4,1.4
	//     c-4.6,4.8-9.3,9.6-13.9,14.4c14.7,14.2,28.2,29.3,40.9,45.4c5.3-4.1,10.5-8.2,15.8-12.3c0.4,0.5,0.8,1,1.2,1.6
	//     c-5.3,4.1-10.5,8.2-15.8,12.3c12.6,16.1,23.9,32.9,34.1,50.6c11.5-6.7,23.1-13.3,34.6-20c0.3,0.6,0.7,1.2,1,1.7
	//     c-11.5,6.7-23.1,13.3-34.6,20c10.2,17.7,19.1,35.9,26.8,54.9c6.2-2.5,12.4-5,18.5-7.5c0.3,0.6,0.5,1.2,0.7,1.9
	//     c-6.2,2.5-12.4,5-18.5,7.5c7.6,19,13.9,38.2,18.9,58.1c6.5-1.6,12.9-3.2,19.4-4.8c0.2,0.6,0.3,1.3,0.5,1.9
	//     c-6.5,1.6-12.9,3.2-19.4,4.8c4.9,19.9,8.4,39.8,10.6,60.1c6.6-0.7,13.3-1.4,19.9-2.1c0.1,0.7,0.1,1.3,0.2,2
	//     c-6.6,0.7-13.3,1.4-19.9,2.1c2.1,20.3,2.8,40.6,2.1,61c6.7,0.2,13.3,0.5,20,0.7c0,0.7,0,1.3-0.1,2c-6.7-0.2-13.3-0.5-20-0.7
	//     c-0.8,20.4-2.9,40.6-6.4,60.7c13.1,2.3,26.3,4.6,39.4,6.9c-0.1,0.7-0.2,1.3-0.3,2C1010.6,624.1,996.8,621.7,983.1,619.2z"/>
	// </g>
	// <g id="Color_P">
	//   <g>
	//     <defs>
	//       <path id="SVGID_1_11" d="M867.2,309.9C740,129.2,490.5,85.9,309.8,213C129.2,340.2,85.8,589.7,213,770.4s376.7,224,557.3,96.8
	//         C951,740,994.3,490.5,867.2,309.9z M698.6,764.8c-124.1,87.6-295.7,58-383.2-66.1c-87.6-124.1-58-295.7,66.1-383.2
	//         c124.1-87.6,295.7-58,383.2,66.1S822.7,677.2,698.6,764.8z"/>
	//     </defs>
	//     <clipPath id="SVGID_2_11">
	//       <use xlink:href="#SVGID_1_11"  style="overflow:visible;"/>
	//     </clipPath>
	//     <g class="st2">
	//       <g>
	//         <defs>
	//             <rect id="SVGID_3_1" x="77.8" y="77.8" transform="matrix(0.7071 -0.7071 0.7071 0.7071 -223.7432 540.0739)" width="924.6" height="924.6"/>
	//         </defs>
	//         <clipPath id="SVGID_4_1">
	//           <use xlink:href="#SVGID_3_1"  style="overflow:visible;"/>
	//         </clipPath>
	//         <g transform="matrix(1 0 0 1 0 1.525879e-005)" style="clip-path:url(#SVGID_4_1);">
	//             <image style="overflow:visible;" width="2362" height="2362" xlink:href="hue-selector.jpg" transform="matrix(0.2768 0.2768 -0.2768 0.2768 540.0553 -113.6534)">
	//           </image>
	//         </g>
	//       </g>
	//     </g>
	//   </g>
	// </g>
	// <g id="Pin_P" :transform="'rotate(' + (360-deg)+ ' 540 540)'">
	//   <linearGradient id="SVGID_5_" gradientUnits="userSpaceOnUse" x1="875.5689" y1="540.1044" x2="517.0704" y2="540.1044">
	//     <stop  offset="0" style="stop-color:#F5D96C"/>
	//     <stop  offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st3" d="M561.3,531.2c-9.7-23.2-44.2-16.3-44.2,8.9c0,25.1,34.5,32.1,44.2,8.9c0.2-0.4,0.3-0.8,0.5-1.2
	//     c104.6-1.6,209.2-3.3,313.8-4.9c0-1.9,0-3.7,0-5.6c-104.6-1.6-209.2-3.3-313.8-4.9C561.6,532,561.5,531.6,561.3,531.2z"/>
	//   <linearGradient id="SVGID_6_" gradientUnits="userSpaceOnUse" x1="878.0686" y1="540.1048" x2="514.5707" y2="540.1048">
	//     <stop  offset="0" style="stop-color:#F5D96C"/>
	//     <stop  offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st4" d="M563.1,530.5c-10.5-25.2-48.1-17.7-48.1,9.6s37.5,34.8,48.1,9.6c104.8-1.6,209.6-3.3,314.4-4.9
	//     c0-1.6,0-3.2,0-4.8c0-1.6,0-3.2,0-4.8C772.8,533.7,667.9,532.1,563.1,530.5z"/>
	// </g>
	// <g id="Pin_PL" :transform="'rotate(' + BLangle + ' 540 540)'">
	//   <g>
	//     <linearGradient id="SVGID_171_" gradientUnits="userSpaceOnUse" x1="57.5965" y1="530.0045" x2="20.0443" y2="530.0045">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_171_);" d="M20,532.4c0-1.8,0.1-3.6,0.1-5.4c9.6,0.6,19.3,1.2,28.9,1.9c2.8,1.4,5.7,2.8,8.5,4.1    C45.1,532.8,32.6,532.6,20,532.4z"/>
	//     <linearGradient id="SVGID_181_" gradientUnits="userSpaceOnUse" x1="77.9868" y1="540.1041" x2="19.9875" y2="540.1041">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_181_);" d="M20,543.8c0-2.5,0-4.9,0-7.4c19.3,0.3,38.7,0.6,58,0.9c0,1.9,0,3.7,0,5.6C58.7,543.2,39.3,543.5,20,543.8z"/>
	//     <linearGradient id="SVGID_191_" gradientUnits="userSpaceOnUse" x1="57.5965" y1="550.2053" x2="20.0443" y2="550.2053">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_191_);" d="M20.2,553.2c0-1.8-0.1-3.6-0.1-5.4c12.5-0.2,25-0.4,37.6-0.6c-2.8,1.4-5.7,2.8-8.5,4.1    C39.4,552,29.8,552.6,20.2,553.2z"/>
	//   </g>
	// </g>
	// <g id="Pin_PR" :transform="'rotate(' + BRangle + ' 540 540)'">
	//   <g xmlns="http://www.w3.org/2000/svg">
	//     <linearGradient id="SVGID_101_" gradientUnits="userSpaceOnUse" x1="1022.4805" y1="550.2055" x2="1060.0327" y2="550.2055">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_101_)" d="M1059.9,553.2c0-1.8,0.1-3.6,0.1-5.4c-12.5-0.2-25-0.4-37.6-0.6c2.8,1.4,5.7,2.8,8.5,4.1    C1040.6,552,1050.3,552.6,1059.9,553.2z"/>
	//     <linearGradient id="SVGID_111_" gradientUnits="userSpaceOnUse" x1="1002.0901" y1="540.1044" x2="1060.0895" y2="540.1044">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_111_)" d="M1060.1,543.8c0-2.5,0-4.9,0-7.4c-19.3,0.3-38.7,0.6-58,0.9c0,1.9,0,3.7,0,5.6    C1021.4,543.2,1040.7,543.5,1060.1,543.8z"/>
	//     <linearGradient id="SVGID_121_" gradientUnits="userSpaceOnUse" x1="1022.4805" y1="530.0047" x2="1060.0327" y2="530.0047">
	//       <stop offset="0" style="stop-color:#F5D96C"/>
	//       <stop offset="1" style="stop-color:#F5D96C;stop-opacity:0"/>
	//     </linearGradient>
	//     <path style="fill:url(#SVGID_121_)" d="M1060,532.4c0-1.8-0.1-3.6-0.1-5.4c-9.6,0.6-19.3,1.2-28.9,1.9c-2.8,1.4-5.7,2.8-8.5,4.1    C1035,532.8,1047.5,532.6,1060,532.4z"/>
	//   </g>
	// </g>
	// <g id="Monitor_P">
	//   <radialGradient id="SVGID_9_" cx="540.0702" cy="540.1046" r="150.0409" gradientUnits="userSpaceOnUse">
	//     <stop  offset="0" style="stop-color:#000000"/>
	//     <stop  offset="1" style="stop-color:#000000;stop-opacity:0.5"/>
	//   </radialGradient>
	//   <circle class="st7" cx="540.1" cy="540.1" r="150"/>
	//   <linearGradient id="SVGID_10_" gradientUnits="userSpaceOnUse" x1="540.0699" y1="392.0641" x2="540.0699" y2="688.1447">
	//     <stop  offset="9.271834e-008" :style="'stop-color:'+color"/>
	//     <stop  offset="1" :style="'stop-color:'+color"/>
	//   </linearGradient>
	//   <circle class="st8" cx="540.1" cy="540.1" r="148"/>
	//   <linearGradient id="SVGID_11_" gradientUnits="userSpaceOnUse" x1="540.0705" y1="396.6748" x2="540.0705" y2="524.5886">
	//     <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//     <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st9" d="M540.1,524.6c36.6,0,94.1-17.1,94.1-64c0-46.8-57.5-64-94.1-64c-36.6,0-94.1,17.1-94.1,64
	//     C446,507.5,503.5,524.6,540.1,524.6z"/>
	//   <linearGradient id="SVGID_12_" gradientUnits="userSpaceOnUse" x1="540.0699" y1="400.9027" x2="540.0699" y2="450.9808">
	//     <stop  offset="0" style="stop-color:#FFFFFF;stop-opacity:0.6"/>
	//     <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st10" d="M540.1,451c10.1,0,19.6-1.3,29.2-5c7.9-3,19.6-9.3,19.6-20.1c0-10.7-11.7-17-19.6-20.1c-9.6-3.7-19-5-29.1-5
	//     c-10.1,0-19.6,1.3-29.2,5c-7.9,3-19.6,9.3-19.6,20.1c0,10.7,11.7,17,19.6,20.1C520.5,449.7,529.9,451,540.1,451z"/>
	//   <linearGradient id="SVGID_13_" gradientUnits="userSpaceOnUse" x1="540.0705" y1="683.535" x2="540.0705" y2="555.6201">
	//     <stop  offset="9.271834e-008" style="stop-color:#FFFFFF;stop-opacity:0.4"/>
	//     <stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0"/>
	//   </linearGradient>
	//   <path class="st11" d="M540.1,555.6c36.6,0,94.1,17.1,94.1,64c0,46.8-57.5,64-94.1,64c-36.6,0-94.1-17.1-94.1-64
	//     C446,572.7,503.5,555.6,540.1,555.6z"/>
	//   <text xmlns="http://www.w3.org/2000/svg" transform="matrix(1 0 0 1 484.3381 482)">
	//     <tspan x="0" y="0" style="font-size:36px;font-family:'HYg1gj'" v-text="change.name"></tspan>
	//     <tspan x="-25" y="130" style="font-size:120px;font-family:'HYg1gj'" v-text="change.value"></tspan>
	//     <tspan x="-20" y="120" style="font-size:36px;font-family:'HYg1gj'" v-text="change.hover"></tspan>
	//     <tspan x="150" y="130" style="font-size:36px" v-text="change.name?'%':''"></tspan>

	//   </text>
	// </g>
	// <g id="To_Basic" @click="current='junior'">
	//   <g>
	//     <path class="st1" d="M925.2,774.2c-16-4.3-32.5,5.2-36.7,21.2s5.2,32.5,21.2,36.7c16,4.3,32.5-5.2,36.7-21.2
	//       C950.7,794.9,941.2,778.4,925.2,774.2z M944.5,810.4c-4,14.9-19.4,23.8-34.3,19.8c-14.9-4-23.8-19.4-19.8-34.3
	//       c4-14.9,19.4-23.8,34.3-19.8C939.6,780.1,948.5,795.4,944.5,810.4z"/>
	//     <g>
	//       <defs>
	//         <circle id="SVGID_32_" cx="917.5" cy="803.1" r="28"/>
	//       </defs>
	//       <clipPath id="SVGID_33_">
	//         <use xlink:href="#SVGID_32_"  style="overflow:visible;"/>
	//       </clipPath>
	//       <g class="st27">

	//           <image style="overflow:visible;" width="884" height="873" xlink:href="colors-ring.png" transform="matrix(6.815579e-002 0 0 6.815579e-002 887.3278 773.3801)">
	//         </image>
	//       </g>
	//     </g>
	//   </g>
	// </g>
	// <style type="text/css">
	//   #spe .st4_1{fill:url(#SVGID_1_1);}
	//   #spe .st5_1{fill:url(#SVGID_2_1);}
	//   #spe .st0{fill:#333333;}
	//   #spe .st1{fill:#F5D96C;}
	//   #spe .st2{clip-path:url(#SVGID_2_11);}
	//   #spe .st3{fill:url(#SVGID_5_);}
	//   #spe .st4{fill:none;stroke:url(#SVGID_6_);stroke-miterlimit:10;}
	//   #spe .st5{fill:url(#SVGID_7_);}
	//   #spe .st6{fill:url(#SVGID_8_);}
	//   #spe .st7{fill:url(#SVGID_9_);}
	//   #spe .st8{fill:url(#SVGID_10_);}
	//   #spe .st9{fill:url(#SVGID_11_);}
	//   #spe .st10{fill:url(#SVGID_12_);}
	//   #spe .st11{fill:url(#SVGID_13_);}
	//   #spe .st12{fill:url(#SVGID_14_);}
	//   #spe .st13{fill:url(#SVGID_15_);}
	//   #spe .st14{fill:url(#SVGID_16_);}
	//   #spe .st15{fill:url(#SVGID_17_);}
	//   #spe .st16{fill:url(#SVGID_18_);}
	//   #spe .st17{fill:url(#SVGID_19_);}
	//   #spe .st18{clip-path:url(#SVGID_21_);}
	//   #spe .st19{fill:url(#SVGID_22_);}
	//   #spe .st20{clip-path:url(#SVGID_24_);}
	//   #spe .st21{fill:url(#SVGID_25_);}
	//   #spe .st22{clip-path:url(#SVGID_27_);}
	//   #spe .st23{fill:url(#SVGID_28_);}
	//   #spe .st24{fill:url(#SVGID_29_);}
	//   #spe .st25{fill:url(#SVGID_30_);}
	//   #spe .st26{fill:url(#SVGID_31_);}
	//   #spe .st27{clip-path:url(#SVGID_33_);}
	//   #spe .st28{opacity:0.5;fill:url(#SVGID_34_);}
	//   #spe .st29{opacity:0.5;fill:url(#SVGID_35_);}
	//   #spe .st30{opacity:0.5;fill:url(#SVGID_36_);}
	//   #spe .st31{opacity:0.5;fill:url(#SVGID_37_);}
	//   #spe .st32{opacity:0.5;fill:url(#SVGID_38_);}
	//   #spe .st33{opacity:0.5;fill:url(#SVGID_39_);}
	// </style>
	// </template>

	// <script>
	var THREE = __webpack_require__(26);

	module.exports = {
	  props: ['value', 'BRangle', 'BLangle', 'current', 'deg'],
	  data: function data() {
	    return {
	      color: "",
	      colorSet: 'diffuse',
	      change: { name: '调色板' },
	      save: {}
	    };
	  },
	  computed: {
	    'color': function color() {
	      var h = this.value.h;
	      var s = this.value.s;
	      var l = this.value.l;
	      var color = new THREE.Color("hsl(" + h + "," + s + "," + l + ")");
	      return '#' + color.getHexString();
	    }
	  },
	  methods: {
	    toHex: function toHex(value) {
	      var h = value.h;
	      var s = value.s;
	      var l = value.l;
	      var color = new THREE.Color("hsl(" + h + "," + s + "," + l + ")");
	      return '#' + color.getHexString();
	    }
	  },
	  watch: {
	    value: function value(_value) {
	      var h = _value.h;
	      var s = _value.s;
	      var l = _value.l;
	      this.deg = h * 360;
	      this.BRangle = 10 - Number(s.substring(0, s.length - 1)) * 8 / 10;
	      this.BLangle = 30 - Number(l.substring(0, l.length - 1)) * 8 / 10;
	    },
	    deg: function deg(value) {
	      this.value = { h: (value / 360).toFixed(4), s: this.value.s, l: this.value.l };
	    },
	    BRangle: function BRangle(value) {
	      this.value = { h: this.value.h, s: (10 - value) * 10 / 8 + '%', l: this.value.l };
	      this.change = { name: '饱和度', value: (10 - value) * 10 / 8 };
	    },
	    BLangle: function BLangle(value) {
	      this.value = { h: this.value.h, s: this.value.s, l: (30 - value) * 10 / 8 + '%' };
	      this.change = { name: '明度', value: (30 - value) * 10 / 8 };
	    }
	  }
	};
	// </script>

/***/ },
/* 134 */
/***/ function(module, exports) {

	module.exports = "<g id=\"Scale_P\">\n  <path class=\"st1\" d=\"M449.4,291.1c-192.1,69.9-236,321.8-78.9,452.7c23.7,19.8,49,34.4,78,45c121.4,44.7,257.3-4.8,321.6-117\n    c15.3-26.8,25.3-54.2,30.8-84.6C837.1,385.9,641.5,221.2,449.4,291.1z M799.2,584.8c-6.6-1.2-13.1-2.3-19.7-3.5\n    c-0.1,0.7-0.2,1.3-0.3,2c6.6,1.2,13.1,2.3,19.7,3.5c-5.4,30.2-15.3,57.4-30.6,84c-5.8-3.3-11.5-6.7-17.3-10c-0.3,0.6-0.7,1.2-1,1.7\n    c5.8,3.3,11.5,6.7,17.3,10c-15.4,26.5-34,48.7-57.4,68.5c-4.3-5.1-8.6-10.2-12.9-15.3c-0.5,0.4-1,0.9-1.5,1.3\n    c4.3,5.1,8.6,10.2,12.9,15.3c-23.6,19.6-48.6,34.1-77.4,44.7c-2.3-6.3-4.6-12.5-6.8-18.8c-0.6,0.2-1.3,0.5-1.9,0.7\n    c2.3,6.3,4.6,12.5,6.8,18.8c-28.8,10.4-57.4,15.4-88,15.5c0-6.7,0-13.3,0-20c-0.7,0-1.3,0-2,0c0,6.7,0,13.3,0,20\n    c-30.6-0.1-59.2-5.1-88-15.5c2.3-6.3,4.6-12.5,6.8-18.8c-0.6-0.2-1.3-0.5-1.9-0.7c-2.3,6.3-4.6,12.5-6.8,18.8\n    c-28.8-10.6-53.8-25.1-77.4-44.7c4.3-5.1,8.6-10.2,12.9-15.3c-0.5-0.4-1-0.9-1.5-1.3c-4.3,5.1-8.6,10.2-12.9,15.3\n    c-23.4-19.8-42-42-57.4-68.5c5.8-3.3,11.5-6.7,17.3-10c-0.3-0.6-0.7-1.2-1-1.7c-5.8,3.3-11.5,6.7-17.3,10\n    c-15.2-26.6-25.1-53.8-30.6-84c6.6-1.2,13.1-2.3,19.7-3.5c-0.1-0.7-0.2-1.3-0.3-2c-6.6,1.2-13.1,2.3-19.7,3.5\n    c-5.2-30.2-5.2-59.2,0-89.4c6.6,1.2,13.1,2.3,19.7,3.5c0.1-0.7,0.2-1.3,0.3-2c-6.6-1.2-13.1-2.3-19.7-3.5\n    c5.4-30.2,15.3-57.4,30.6-84c5.8,3.3,11.5,6.7,17.3,10c0.3-0.6,0.7-1.2,1-1.7c-5.8-3.3-11.5-6.7-17.3-10\n    c15.4-26.5,34-48.7,57.4-68.5c4.3,5.1,8.6,10.2,12.9,15.3c0.5-0.4,1-0.9,1.5-1.3c-4.3-5.1-8.6-10.2-12.9-15.3\n    c23.6-19.6,48.6-34.1,77.4-44.7c2.3,6.3,4.6,12.5,6.8,18.8c0.6-0.2,1.3-0.5,1.9-0.7c-2.3-6.3-4.6-12.5-6.8-18.8\n    c28.8-10.4,57.4-15.4,88-15.5c0,6.7,0,13.3,0,20c0.7,0,1.3,0,2,0c0-6.7,0-13.3,0-20c30.6,0.1,59.2,5.1,88,15.5\n    c-2.3,6.3-4.6,12.5-6.8,18.8c0.6,0.2,1.3,0.5,1.9,0.7c2.3-6.3,4.6-12.5,6.8-18.8c28.8,10.6,53.8,25.1,77.4,44.7\n    c-4.3,5.1-8.6,10.2-12.9,15.3c0.5,0.4,1,0.9,1.5,1.3c4.3-5.1,8.6-10.2,12.9-15.3c23.4,19.8,42,42,57.4,68.5\n    c-5.8,3.3-11.5,6.7-17.3,10c0.3,0.6,0.7,1.2,1,1.7c5.8-3.3,11.5-6.7,17.3-10c15.2,26.6,25.1,53.8,30.6,84\n    c-6.6,1.2-13.1,2.3-19.7,3.5c0.1,0.7,0.2,1.3,0.3,2c6.6-1.2,13.1-2.3,19.7-3.5C804.5,525.6,804.5,554.6,799.2,584.8z\"/>\n  <path class=\"st1\" d=\"M692.3,484.7c-30.6-84.1-123.6-127.4-207.6-96.8c-84.1,30.6-127.4,123.6-96.8,207.6\n    c30.6,84.1,123.6,127.4,207.6,96.8C679.6,661.7,722.9,568.8,692.3,484.7z M594.8,690.5c-83,30.2-174.9-12.6-205.1-95.6\n    c-30.2-83,12.6-174.9,95.6-205.1c83-30.2,174.9,12.6,205.1,95.6C720.6,568.4,677.8,660.2,594.8,690.5z\"/>\n</g>\n<g id=\"Scale_BL2\">\n  <path class=\"st3_1\" :fill=\"color\" d=\"M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4\n    C82,745.5,39.5,504.3,149.5,314.7z\"/>\n</g>\n<g id=\"Scale_BL3\">\n  <linearGradient id=\"SVGID_1_1\" gradientUnits=\"userSpaceOnUse\" x1=\"214.4087\" y1=\"932.3943\" x2=\"44.3172\" y2=\"297.604\">\n    <stop  offset=\"0\" style=\"stop-color:#FFFFFF\"/>\n    <stop  offset=\"0.5\" style=\"stop-color:#7A7A7A;stop-opacity:0\"/>\n    <stop  offset=\"1\" style=\"stop-color:#000000\"/>\n  </linearGradient>\n  <path class=\"st4_1\" d=\"M149.5,314.7c-17.8-10.3-35.6-20.7-53.4-31C-29,499.3,19.4,773.6,210.6,933.4c13.2-15.8,26.4-31.6,39.6-47.4\n    C82,745.5,39.5,504.3,149.5,314.7z\"/>\n</g>\n<g id=\"Scale_PL\">\n  <path class=\"st1\" d=\"M251.6,885.5C83.4,745,40.9,503.8,150.9,314.2c-12.1-7-24.2-14-36.4-21c-0.3,0.6-0.7,1.2-1,1.7\n    c11.5,6.7,23.1,13.3,34.6,20c-10.2,17.7-19.1,35.9-26.8,54.9c-6.2-2.5-12.4-5-18.5-7.5c-0.3,0.6-0.5,1.2-0.7,1.9\n    c6.2,2.5,12.4,5,18.5,7.5c-7.6,19-13.9,38.2-18.9,58.1c-6.5-1.6-12.9-3.2-19.4-4.8c-0.2,0.6-0.3,1.3-0.5,1.9\n    c6.5,1.6,12.9,3.2,19.4,4.8c-4.9,19.9-8.4,39.8-10.6,60.1c-6.6-0.7-13.3-1.4-19.9-2.1c-0.1,0.7-0.1,1.3-0.2,2\n    c6.6,0.7,13.3,1.4,19.9,2.1c-2.1,20.3-2.8,40.6-2.1,61c-6.7,0.2-13.3,0.5-20,0.7c0,0.7,0,1.3,0.1,2c6.7-0.2,13.3-0.5,20-0.7\n    c0.8,20.4,2.9,40.6,6.4,60.7c-13.1,2.3-26.3,4.6-39.4,6.9c0.1,0.7,0.2,1.3,0.3,2c13.1-2.3,26.3-4.6,39.4-6.9\n    c3.6,20.1,8.5,39.8,14.8,59.2c-6.3,2.1-12.7,4.1-19,6.2c0.2,0.6,0.4,1.3,0.6,1.9c6.3-2.1,12.7-4.1,19-6.2\n    c6.4,19.4,14,38.2,22.9,56.6c-6,2.9-12,5.8-18,8.8c0.3,0.6,0.6,1.2,0.9,1.8c6-2.9,12-5.8,18-8.8c9,18.4,19.1,35.9,30.5,52.9\n    c-5.5,3.7-11.1,7.5-16.6,11.2c0.4,0.6,0.7,1.1,1.1,1.7c5.5-3.7,11.1-7.5,16.6-11.2c11.5,16.9,23.9,32.9,37.6,48.1\n    c-5,4.5-9.9,8.9-14.9,13.4c0.4,0.5,0.9,1,1.3,1.5c5-4.5,9.9-8.9,14.9-13.4c13.7,15.2,28.3,29.2,43.9,42.4\n    c-8.6,10.2-17.1,20.4-25.7,30.6c0.5,0.4,1,0.9,1.5,1.3C233.6,906.9,242.6,896.2,251.6,885.5z\"/>\n</g>\n<g id=\"Scale_BR2\">\n  <path class=\"st3_1\" :fill=\"color\" d=\"M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1\n    C900.2,190.4,1022.6,402.5,984.1,618.3z\"/>\n</g>\n<g id=\"Scale_BR3\">\n  <linearGradient id=\"SVGID_2_1\" gradientUnits=\"userSpaceOnUse\" x1=\"968.8124\" y1=\"649.5213\" x2=\"803.8889\" y2=\"34.0186\">\n    <stop  offset=\"0\" style=\"stop-color:#808080;stop-opacity:1\"/>\n    <stop  offset=\"1\" style=\"stop-color:#808080;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st5_1\" d=\"M984.1,618.3c20.3,3.6,40.5,7.2,60.8,10.8c43.8-245.3-95.5-486.6-329.8-571.3c-7,19.4-14,38.7-21,58.1\n    C900.2,190.4,1022.6,402.5,984.1,618.3z\"/>\n</g>\n<g id=\"Scale_PR\">\n  <path class=\"st1\" d=\"M983.1,619.2c38.5-215.7-83.9-427.8-290-502.3c4.8-13.2,9.6-26.3,14.4-39.5c0.6,0.2,1.3,0.5,1.9,0.7\n    c-4.6,12.5-9.1,25.1-13.7,37.6c19.2,7,37.7,15.3,55.8,24.8c3.1-5.9,6.3-11.8,9.4-17.7c0.6,0.3,1.2,0.6,1.8,0.9\n    c-3.1,5.9-6.3,11.8-9.4,17.7c18,9.6,35.2,20.4,51.8,32.4c3.9-5.4,7.8-10.8,11.8-16.2c0.5,0.4,1.1,0.8,1.6,1.2\n    c-3.9,5.4-7.8,10.8-11.8,16.2c16.5,12.1,32,25.1,46.8,39.3c4.6-4.8,9.3-9.6,13.9-14.4c0.5,0.5,1,0.9,1.4,1.4\n    c-4.6,4.8-9.3,9.6-13.9,14.4c14.7,14.2,28.2,29.3,40.9,45.4c5.3-4.1,10.5-8.2,15.8-12.3c0.4,0.5,0.8,1,1.2,1.6\n    c-5.3,4.1-10.5,8.2-15.8,12.3c12.6,16.1,23.9,32.9,34.1,50.6c11.5-6.7,23.1-13.3,34.6-20c0.3,0.6,0.7,1.2,1,1.7\n    c-11.5,6.7-23.1,13.3-34.6,20c10.2,17.7,19.1,35.9,26.8,54.9c6.2-2.5,12.4-5,18.5-7.5c0.3,0.6,0.5,1.2,0.7,1.9\n    c-6.2,2.5-12.4,5-18.5,7.5c7.6,19,13.9,38.2,18.9,58.1c6.5-1.6,12.9-3.2,19.4-4.8c0.2,0.6,0.3,1.3,0.5,1.9\n    c-6.5,1.6-12.9,3.2-19.4,4.8c4.9,19.9,8.4,39.8,10.6,60.1c6.6-0.7,13.3-1.4,19.9-2.1c0.1,0.7,0.1,1.3,0.2,2\n    c-6.6,0.7-13.3,1.4-19.9,2.1c2.1,20.3,2.8,40.6,2.1,61c6.7,0.2,13.3,0.5,20,0.7c0,0.7,0,1.3-0.1,2c-6.7-0.2-13.3-0.5-20-0.7\n    c-0.8,20.4-2.9,40.6-6.4,60.7c13.1,2.3,26.3,4.6,39.4,6.9c-0.1,0.7-0.2,1.3-0.3,2C1010.6,624.1,996.8,621.7,983.1,619.2z\"/>\n</g>\n<g id=\"Color_P\">\n  <g>\n    <defs>\n      <path id=\"SVGID_1_11\" d=\"M867.2,309.9C740,129.2,490.5,85.9,309.8,213C129.2,340.2,85.8,589.7,213,770.4s376.7,224,557.3,96.8\n        C951,740,994.3,490.5,867.2,309.9z M698.6,764.8c-124.1,87.6-295.7,58-383.2-66.1c-87.6-124.1-58-295.7,66.1-383.2\n        c124.1-87.6,295.7-58,383.2,66.1S822.7,677.2,698.6,764.8z\"/>\n    </defs>\n    <clipPath id=\"SVGID_2_11\">\n      <use xlink:href=\"#SVGID_1_11\"  style=\"overflow:visible;\"/>\n    </clipPath>\n    <g class=\"st2\">\n      <g>\n        <defs>\n            <rect id=\"SVGID_3_1\" x=\"77.8\" y=\"77.8\" transform=\"matrix(0.7071 -0.7071 0.7071 0.7071 -223.7432 540.0739)\" width=\"924.6\" height=\"924.6\"/>\n        </defs>\n        <clipPath id=\"SVGID_4_1\">\n          <use xlink:href=\"#SVGID_3_1\"  style=\"overflow:visible;\"/>\n        </clipPath>\n        <g transform=\"matrix(1 0 0 1 0 1.525879e-005)\" style=\"clip-path:url(#SVGID_4_1);\">\n            <image style=\"overflow:visible;\" width=\"2362\" height=\"2362\" xlink:href=\"hue-selector.jpg\" transform=\"matrix(0.2768 0.2768 -0.2768 0.2768 540.0553 -113.6534)\">\n          </image>\n        </g>\n      </g>\n    </g>\n  </g>\n</g>\n<g id=\"Pin_P\" :transform=\"'rotate(' + (360-deg)+ ' 540 540)'\">\n  <linearGradient id=\"SVGID_5_\" gradientUnits=\"userSpaceOnUse\" x1=\"875.5689\" y1=\"540.1044\" x2=\"517.0704\" y2=\"540.1044\">\n    <stop  offset=\"0\" style=\"stop-color:#F5D96C\"/>\n    <stop  offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st3\" d=\"M561.3,531.2c-9.7-23.2-44.2-16.3-44.2,8.9c0,25.1,34.5,32.1,44.2,8.9c0.2-0.4,0.3-0.8,0.5-1.2\n    c104.6-1.6,209.2-3.3,313.8-4.9c0-1.9,0-3.7,0-5.6c-104.6-1.6-209.2-3.3-313.8-4.9C561.6,532,561.5,531.6,561.3,531.2z\"/>\n  <linearGradient id=\"SVGID_6_\" gradientUnits=\"userSpaceOnUse\" x1=\"878.0686\" y1=\"540.1048\" x2=\"514.5707\" y2=\"540.1048\">\n    <stop  offset=\"0\" style=\"stop-color:#F5D96C\"/>\n    <stop  offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st4\" d=\"M563.1,530.5c-10.5-25.2-48.1-17.7-48.1,9.6s37.5,34.8,48.1,9.6c104.8-1.6,209.6-3.3,314.4-4.9\n    c0-1.6,0-3.2,0-4.8c0-1.6,0-3.2,0-4.8C772.8,533.7,667.9,532.1,563.1,530.5z\"/>\n</g>\n<g id=\"Pin_PL\" :transform=\"'rotate(' + BLangle + ' 540 540)'\">\n  <g>\n    <linearGradient id=\"SVGID_171_\" gradientUnits=\"userSpaceOnUse\" x1=\"57.5965\" y1=\"530.0045\" x2=\"20.0443\" y2=\"530.0045\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_171_);\" d=\"M20,532.4c0-1.8,0.1-3.6,0.1-5.4c9.6,0.6,19.3,1.2,28.9,1.9c2.8,1.4,5.7,2.8,8.5,4.1    C45.1,532.8,32.6,532.6,20,532.4z\"/>\n    <linearGradient id=\"SVGID_181_\" gradientUnits=\"userSpaceOnUse\" x1=\"77.9868\" y1=\"540.1041\" x2=\"19.9875\" y2=\"540.1041\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_181_);\" d=\"M20,543.8c0-2.5,0-4.9,0-7.4c19.3,0.3,38.7,0.6,58,0.9c0,1.9,0,3.7,0,5.6C58.7,543.2,39.3,543.5,20,543.8z\"/>\n    <linearGradient id=\"SVGID_191_\" gradientUnits=\"userSpaceOnUse\" x1=\"57.5965\" y1=\"550.2053\" x2=\"20.0443\" y2=\"550.2053\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_191_);\" d=\"M20.2,553.2c0-1.8-0.1-3.6-0.1-5.4c12.5-0.2,25-0.4,37.6-0.6c-2.8,1.4-5.7,2.8-8.5,4.1    C39.4,552,29.8,552.6,20.2,553.2z\"/>\n  </g>\n</g>\n<g id=\"Pin_PR\" :transform=\"'rotate(' + BRangle + ' 540 540)'\">\n  <g xmlns=\"http://www.w3.org/2000/svg\">\n    <linearGradient id=\"SVGID_101_\" gradientUnits=\"userSpaceOnUse\" x1=\"1022.4805\" y1=\"550.2055\" x2=\"1060.0327\" y2=\"550.2055\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_101_)\" d=\"M1059.9,553.2c0-1.8,0.1-3.6,0.1-5.4c-12.5-0.2-25-0.4-37.6-0.6c2.8,1.4,5.7,2.8,8.5,4.1    C1040.6,552,1050.3,552.6,1059.9,553.2z\"/>\n    <linearGradient id=\"SVGID_111_\" gradientUnits=\"userSpaceOnUse\" x1=\"1002.0901\" y1=\"540.1044\" x2=\"1060.0895\" y2=\"540.1044\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_111_)\" d=\"M1060.1,543.8c0-2.5,0-4.9,0-7.4c-19.3,0.3-38.7,0.6-58,0.9c0,1.9,0,3.7,0,5.6    C1021.4,543.2,1040.7,543.5,1060.1,543.8z\"/>\n    <linearGradient id=\"SVGID_121_\" gradientUnits=\"userSpaceOnUse\" x1=\"1022.4805\" y1=\"530.0047\" x2=\"1060.0327\" y2=\"530.0047\">\n      <stop offset=\"0\" style=\"stop-color:#F5D96C\"/>\n      <stop offset=\"1\" style=\"stop-color:#F5D96C;stop-opacity:0\"/>\n    </linearGradient>\n    <path style=\"fill:url(#SVGID_121_)\" d=\"M1060,532.4c0-1.8-0.1-3.6-0.1-5.4c-9.6,0.6-19.3,1.2-28.9,1.9c-2.8,1.4-5.7,2.8-8.5,4.1    C1035,532.8,1047.5,532.6,1060,532.4z\"/>\n  </g>\n</g>\n<g id=\"Monitor_P\">\n  <radialGradient id=\"SVGID_9_\" cx=\"540.0702\" cy=\"540.1046\" r=\"150.0409\" gradientUnits=\"userSpaceOnUse\">\n    <stop  offset=\"0\" style=\"stop-color:#000000\"/>\n    <stop  offset=\"1\" style=\"stop-color:#000000;stop-opacity:0.5\"/>\n  </radialGradient>\n  <circle class=\"st7\" cx=\"540.1\" cy=\"540.1\" r=\"150\"/>\n  <linearGradient id=\"SVGID_10_\" gradientUnits=\"userSpaceOnUse\" x1=\"540.0699\" y1=\"392.0641\" x2=\"540.0699\" y2=\"688.1447\">\n    <stop  offset=\"9.271834e-008\" :style=\"'stop-color:'+color\"/>\n    <stop  offset=\"1\" :style=\"'stop-color:'+color\"/>\n  </linearGradient>\n  <circle class=\"st8\" cx=\"540.1\" cy=\"540.1\" r=\"148\"/>\n  <linearGradient id=\"SVGID_11_\" gradientUnits=\"userSpaceOnUse\" x1=\"540.0705\" y1=\"396.6748\" x2=\"540.0705\" y2=\"524.5886\">\n    <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n    <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st9\" d=\"M540.1,524.6c36.6,0,94.1-17.1,94.1-64c0-46.8-57.5-64-94.1-64c-36.6,0-94.1,17.1-94.1,64\n    C446,507.5,503.5,524.6,540.1,524.6z\"/>\n  <linearGradient id=\"SVGID_12_\" gradientUnits=\"userSpaceOnUse\" x1=\"540.0699\" y1=\"400.9027\" x2=\"540.0699\" y2=\"450.9808\">\n    <stop  offset=\"0\" style=\"stop-color:#FFFFFF;stop-opacity:0.6\"/>\n    <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st10\" d=\"M540.1,451c10.1,0,19.6-1.3,29.2-5c7.9-3,19.6-9.3,19.6-20.1c0-10.7-11.7-17-19.6-20.1c-9.6-3.7-19-5-29.1-5\n    c-10.1,0-19.6,1.3-29.2,5c-7.9,3-19.6,9.3-19.6,20.1c0,10.7,11.7,17,19.6,20.1C520.5,449.7,529.9,451,540.1,451z\"/>\n  <linearGradient id=\"SVGID_13_\" gradientUnits=\"userSpaceOnUse\" x1=\"540.0705\" y1=\"683.535\" x2=\"540.0705\" y2=\"555.6201\">\n    <stop  offset=\"9.271834e-008\" style=\"stop-color:#FFFFFF;stop-opacity:0.4\"/>\n    <stop  offset=\"1\" style=\"stop-color:#FFFFFF;stop-opacity:0\"/>\n  </linearGradient>\n  <path class=\"st11\" d=\"M540.1,555.6c36.6,0,94.1,17.1,94.1,64c0,46.8-57.5,64-94.1,64c-36.6,0-94.1-17.1-94.1-64\n    C446,572.7,503.5,555.6,540.1,555.6z\"/>\n  <text xmlns=\"http://www.w3.org/2000/svg\" transform=\"matrix(1 0 0 1 484.3381 482)\">\n    <tspan x=\"0\" y=\"0\" style=\"font-size:36px;font-family:'HYg1gj'\" v-text=\"change.name\"></tspan>\n    <tspan x=\"-25\" y=\"130\" style=\"font-size:120px;font-family:'HYg1gj'\" v-text=\"change.value\"></tspan>\n    <tspan x=\"-20\" y=\"120\" style=\"font-size:36px;font-family:'HYg1gj'\" v-text=\"change.hover\"></tspan>\n    <tspan x=\"150\" y=\"130\" style=\"font-size:36px\" v-text=\"change.name?'%':''\"></tspan>\n\n  </text>\n</g>\n<g id=\"To_Basic\" @click=\"current='junior'\">\n  <g>\n    <path class=\"st1\" d=\"M925.2,774.2c-16-4.3-32.5,5.2-36.7,21.2s5.2,32.5,21.2,36.7c16,4.3,32.5-5.2,36.7-21.2\n      C950.7,794.9,941.2,778.4,925.2,774.2z M944.5,810.4c-4,14.9-19.4,23.8-34.3,19.8c-14.9-4-23.8-19.4-19.8-34.3\n      c4-14.9,19.4-23.8,34.3-19.8C939.6,780.1,948.5,795.4,944.5,810.4z\"/>\n    <g>\n      <defs>\n        <circle id=\"SVGID_32_\" cx=\"917.5\" cy=\"803.1\" r=\"28\"/>\n      </defs>\n      <clipPath id=\"SVGID_33_\">\n        <use xlink:href=\"#SVGID_32_\"  style=\"overflow:visible;\"/>\n      </clipPath>\n      <g class=\"st27\">\n\n          <image style=\"overflow:visible;\" width=\"884\" height=\"873\" xlink:href=\"colors-ring.png\" transform=\"matrix(6.815579e-002 0 0 6.815579e-002 887.3278 773.3801)\">\n        </image>\n      </g>\n    </g>\n  </g>\n</g>\n<style type=\"text/css\">\n  #spe .st4_1{fill:url(#SVGID_1_1);}\n  #spe .st5_1{fill:url(#SVGID_2_1);}\n  #spe .st0{fill:#333333;}\n  #spe .st1{fill:#F5D96C;}\n  #spe .st2{clip-path:url(#SVGID_2_11);}\n  #spe .st3{fill:url(#SVGID_5_);}\n  #spe .st4{fill:none;stroke:url(#SVGID_6_);stroke-miterlimit:10;}\n  #spe .st5{fill:url(#SVGID_7_);}\n  #spe .st6{fill:url(#SVGID_8_);}\n  #spe .st7{fill:url(#SVGID_9_);}\n  #spe .st8{fill:url(#SVGID_10_);}\n  #spe .st9{fill:url(#SVGID_11_);}\n  #spe .st10{fill:url(#SVGID_12_);}\n  #spe .st11{fill:url(#SVGID_13_);}\n  #spe .st12{fill:url(#SVGID_14_);}\n  #spe .st13{fill:url(#SVGID_15_);}\n  #spe .st14{fill:url(#SVGID_16_);}\n  #spe .st15{fill:url(#SVGID_17_);}\n  #spe .st16{fill:url(#SVGID_18_);}\n  #spe .st17{fill:url(#SVGID_19_);}\n  #spe .st18{clip-path:url(#SVGID_21_);}\n  #spe .st19{fill:url(#SVGID_22_);}\n  #spe .st20{clip-path:url(#SVGID_24_);}\n  #spe .st21{fill:url(#SVGID_25_);}\n  #spe .st22{clip-path:url(#SVGID_27_);}\n  #spe .st23{fill:url(#SVGID_28_);}\n  #spe .st24{fill:url(#SVGID_29_);}\n  #spe .st25{fill:url(#SVGID_30_);}\n  #spe .st26{fill:url(#SVGID_31_);}\n  #spe .st27{clip-path:url(#SVGID_33_);}\n  #spe .st28{opacity:0.5;fill:url(#SVGID_34_);}\n  #spe .st29{opacity:0.5;fill:url(#SVGID_35_);}\n  #spe .st30{opacity:0.5;fill:url(#SVGID_36_);}\n  #spe .st31{opacity:0.5;fill:url(#SVGID_37_);}\n  #spe .st32{opacity:0.5;fill:url(#SVGID_38_);}\n  #spe .st33{opacity:0.5;fill:url(#SVGID_39_);}\n</style>";

/***/ },
/* 135 */
/***/ function(module, exports) {

	module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\"\n  viewBox=\"0 0 1080 1080\" class=\"v-materials specular\" @click.stop=\"afterClick($event)\" id=\"spe\" v-el:svg>\n  <component is=\"color\" v-if=\"current == 'junior'\" :value.sync=\"value\" :BRangle.sync=\"BRangle\" :BLangle.sync=\"BLangle\" :current.sync=\"current\" :cancel.sync='cancel'></component>\n  <component is=\"proColor\" v-if=\"current == 'pro'\" :current.sync=\"current\" :BRangle.sync=\"BRangle\" :BLangle.sync=\"BLangle\"  :deg=\"deg\" :value.sync=\"value\" ></component>\n</svg>";

/***/ },
/* 136 */
/***/ function(module, exports) {

	module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\"\n  viewBox=\"0 0 1080 1080\" class=\"v-materials\" @click.stop=\"afterClick($event)\" id=\"regular\" v-el:svg>\n  <component is=\"color\" v-if=\"current == 'junior'\"  :value.sync=\"color\" :BRangle.sync=\"BRangle\" :BLangle.sync=\"BLangle\" :current.sync=\"current\" :colorpad.sync=\"colorpad\" :material.sync=\"material\" :cancel.sync=\"cancel\"></component>\n  <component is=\"proColor\" v-if=\"current == 'pro'\"  :current.sync=\"current\" :BRangle.sync=\"BRangle\" :BLangle.sync=\"BLangle\"  :deg=\"deg\" :value.sync=\"color\" :colorpad.sync=\"colorpad\" :material.sync=\"material\" ></component>\n</svg>\n<component is=\"specular\" v-if=\"material == 'discolor'\" :value.sync=\"specular\"></component>\n<div class=\"fastColor\">\n  <ul v-if=\"material == 'discolor'\" class=\"discolor\">\n    <li v-for=\"fastcolor in materialToColor[material]\"  @click=\"color = fastcolor['nor'],specular = fastcolor['spe']\"><div class=\"circle\" :style=\"'background:'+toHex(fastcolor['nor'])\"></div><div class=\"circle right\" :style=\"'background:'+toHex(fastcolor['spe'])\"></div></li>\n  </ul>\n  <ul v-else class= \"normal\" >\n    <li v-for=\"fastcolor in materialToColor[material]\" :style=\"'background:'+toHex(fastcolor)\" @click=\"color = fastcolor\"></li>\n  </ul>\n</div>";

/***/ },
/* 137 */
/***/ function(module, exports) {

	module.exports = "<div class=\"remolding\">\n  <component is=\"parts\"></component>\n  <component is=\"materials\"\n    v-show=\"store.currentPart == null || store.currentPart.set\"></component>\n</div>\n<style type=\"text/css\">\n  .remolding{\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    z-index: 15;\n    background: -webkit-radial-gradient(center, circle cover, rgba(0,0,0,0) 0%, rgba(0,0,0,0.01) 40%, rgba(0,0,0,0.04) 50%, rgba(0,0,0,0.09) 60%, rgba(0,0,0,0.12) 65%, rgba(0,0,0,0.2) 70%, rgba(0,0,0,0.26) 75%, rgba(0,0,0,0.31) 78%, rgba(0,0,0,0.35) 80%, rgba(0,0,0,0.38) 81%, rgba(0,0,0,0.42) 82%, rgba(0,0,0,0.45) 83%, rgba(0,0,0,0.52) 85%, rgba(0,0,0,0.75) 90%, rgba(0,0,0,0.9) 95%, #000 100%);\n  }\n</style>";

/***/ },
/* 138 */
/***/ function(module, exports) {

	module.exports = "<div class=\"v-interact\" @click=\"click()\">\n    <div class=\"v-buttons\">\n      <button :class=\"{ active: current == 'selector' }\" @click.stop=\"toggleCurrent('selector')\"></button>\n      <button class=\"active\" @click.stop=\"changeSituation()\"></button>\n      <button :class=\"{ active: current == 'remolder' }\" @click.stop=\"toggleCurrent('remolder')\"></button>\n      <button :class=\"{ active:store.rotation }\" @click=\"store.rotation = !store.rotation\"></button>\n      <button :class=\"{ active:store.music }\" @click=\"store.music = !store.music\"></button>\n      <button class=\"active\" @click=\"close()\"></button>\n    </div>\n    <vehicle-selector v-if=\"current == 'selector'\"></vehicle-selector>\n    <vehicle-remolder v-if=\"current == 'remolder'\"></vehicle-remolder>\n  </div>";

/***/ }
/******/ ]);